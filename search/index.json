[{"content":"Classification Naive Bayes Classification Bayes의 법칙에 기반해 사후확률을 이용해 분류\n장점  간단하고 빠르며 정확 computation cost 작음 (빠름) 큰 데이터셋에 적합 연속형보다 이산형 데이터에서 성능 좋음 Multiple class 예측을 위해서도 사용 가능  단점  사건 간에 독립성이 있어야 함  Logistic Regression Classification  이진분류기   Classification/Untitled.png \n  분류함수로 Sigmoid 함수 사용\n  비용함수로 평균제곱오차 사용하지 않음\n Classification/Untitled%201.png \n 위와같이 울퉁불퉁해서 글로벌 미니멈을 못찾음 따라서 새로운 비용함수인 크로스 엔트로피 를 비용함수로 사용    Multinomal Regression Classification  종속변수가 범주형이면서 3개 이상의 범주를 가질때 적용  예) 대학교로 진학할 때 어떤 전공이 인기있는지 사람들이 어떤 혈액형을 가지고 있는지 모두 통계적인 분류   분류함수로 Softmax 함수 사용  K-nearest neighbor (KNN)  Classification/Untitled%202.png \n 새로운 데이터를 입력받으면 가장 가까이 있는 것이 무엇이냐를 중심으로 새로운 데이터의 종류를 정해줌 주변의 K개의 갯수를 보고 판단 → KNN이라고 부름  K → 주변의 데이터 갯수    특징  학습단계에서는 실질적인 학습이 일어나지 않고 데이터만 저장  학습데이터가 크면 메모리 문제 게으른 학습 (Lazy learning)   새로운 데이터가 주어지면 저장된 데이터 이용해 학습  시간이 많이 걸림   데이터간의 거리 계산  수치데이터인 경우  유클리디언 거리   범주형 데이터가 포함된 경우  직접 개발     효율적인 근접 이웃 탐색  데이터의 갯수 많아지면 계산시간 증가 문제 색인 자료구조 사용  R-트리, K-D 트리 등      최근접 K개로부터 결과를 추정하는 방법  분류  출력이 범주형 값 다수결 투표: 개수가 많은 범주 선택   회귀분석  출력이 수치형 값 평균: 최근접 K개의 평균값 가중합 (Weighted Sum): 거리에 반비례하는 가중치 사용    Support Vector Machine (SVM)  Classification/Untitled%203.png \n 이진분류기 **초평면**: 분류하는 선 분류 오차를 줄이면서 동시에 margin을 최대로 하는 **Decision Boundary**를 찾음 margin: 결정 경계과 가장 가까이에 있는 학습 데이터까지의 거리 **서포트**벡터: Decision Boundary로부터 가장 가까이에 있는 학습 데이터들  제약조건 최적화  라그랑주 함수 사용  선형 분리불가 문제의 SVM  슬랙변수  선형 SVM  Classification/Untitled%204.png \n 선형인 초평면으로 공간 분할 슬랙변수를 도입하더라도 한계  데이터의 고차원 사상  Classification/Untitled%205.png \n 데이터를 고차원의 사상하면 선형 분리 가능 XOR 문제  고차원 변환의 문제점  차원의 저주 (Curse of Dimensionality) 문제 발생  학습 데이터가 차원의 수보다 적어져 성능이 저하되는 형상   테스트 데이터에 대한 일반화 (Generalization) 능력 저하 가능  Margin 최대화를 통해 일반화 능력 유지   계산 비용 증가  Kerenl Trick 사용으로 해결    Kernel Trick  고차원으로 변환하여 계산하지 않고, 원래 데이터에서 계산 커널 함수 이용  다항식 커널 (Polynomial Kernel) RBF 커널 쌍곡 탄젠트 커널 (Hyperbolic Tangent)    비선형 SVM에 의한 결정 경계 및 서포트 벡터  Classification/Untitled%206.png \nMulticlass Classification  2개 이상의 Classes를 분류  직접 분류  Random Forest Naive Bayes  2진 분류 이용  SVM Linear Logistic Regression ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/classification/","title":"Classification"},{"content":"Clustering (군집화) 군집화  Clustering%20(%E1%84%80%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%B5%E1%86%B8%E1%84%92%E1%85%AA)/Untitled.png \n 유사성에 따라 데이터를 분할하는 것 데이터를 유사한 것들끼리 모으는 것 군집간의 유사도는 크게, 군집 내의 유사도는 작게  계층적 군집화 (hierarchical clustering)  Clustering%20(%E1%84%80%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%B5%E1%86%B8%E1%84%92%E1%85%AA)/Untitled%201.png \n 군집화의 결과 계층적인 군집구조를 가짐 agglomerative (병합형) : 각 데이터가 하나의 군집을 구성하는 상태에서 시작하여 가까이 있는 군집들을 병합하며 계층적인 군집 형성 divisive (분리형) : 모든 데이터를 포함한 군집에서 점차 분리하며 계층적 구조 형성  분할 군집화 (partitioning clustering)  계층적 구조를 만들지 않고 전체 데이터를 유사한것 끼리 나눠 묶음 예) k-means 알고리즘  k-means 알고리즘   과정\n 군집의 중심 위치 무작위로 선정 군집 중심을 기준으로 군집 재구성 군집별 평균 위치 결정 군집 평균 위치로 군집 중심 조정 수렴할 떄 까지 2-4 과정 반복    특징\n 군집의 갯수 k는 미리 정해둠 초기 중심값 위치에 민감 군집화가 잘 되었다면 각 군집의 샘플이 가까운 거리에서 조밀하게 묶인다  얼마나 뭉쳐있는지 정도인 응집도는 inertia 값으로 확인 자신이 속한 군집까지의 거리를 의미하므로 낮을수록 좋음      k를 결정하는 방법\n Clustering%20(%E1%84%80%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%B5%E1%86%B8%E1%84%92%E1%85%AA)/Untitled%202.png \n Elbow method : k를 1부터 증가시키면서 수행하며 응집도 관찰 각 값에 따라 SSE (sum of squared errors) 값을 수행    Features (조건)  Clustering%20(%E1%84%80%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%B5%E1%86%B8%E1%84%92%E1%85%AA)/Untitled%203.png \n Curse of Dimentionality 학습 스키마 (Feature) 가 1개 있을때보다 2개 있을 때 좋고 이런거는 맞는데 너무 많이 넣으면 급격하게 또 내려감 이유  noise features 증가 학습이랑 인식 속도 저하   솔루션  데이터셋 양 늘리기 중요한 feature만 사용하기 (줄이기) 차원 줄이기  Principal Component Analysis (PCA) Kernel PCA Linear discriminant analysis (LDA) t-SNE: Data Visualization     ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/clustering-%EA%B5%B0%EC%A7%91%ED%99%94/","title":"Clustering (군집화)"},{"content":"Data Preprocessing 전처리 방법  데이터 정제  missing value 처리 noisy data 데이터 불일치   데이터 통합  메타데이터 상관성 분석 데이터 충돌 탐지 의미적 이질성 해소   데이터 변환  smoothing aggregation generalization normalization attribute construction   데이터 축소  data cube aggregation dimensionality reduction numerosity reduction sampling    Normalization VS Standardization  둘 다 머신러닝 알고리즘을 훈련시키는데 있어서 사용되는 특성들이 모두 비슷한 영향력을 행사하도록 값을 변환   Data%20Preprocessing/Untitled.png \n Data%20Preprocessing/Untitled%201.png \n 각 Feature들의 단위, 값의 범위가 모두 다름  따라서 특성들의 단위를 무시할 수 있도록, 또 값의 범위 또한 다들 비슷하도록 맞춰주는 것이 정규화, 표준화의 역할.    Normalization (정규화)  Data%20Preprocessing/Untitled%202.png \n Data%20Preprocessing/Untitled%203.png \n Feature들의 범위를 [0, 1]로 옮김  Standardization  Data%20Preprocessing/Untitled%204.png \n Feature들의 값들이 정규분포를 따른다고 가정하고 값들을 0의 평균, 1의 표준편차를 갖도록 변환 평균을 기준으로 얼마나 떨어져 있는지를 나타내는 값  Label Encoding  Scikit-learn은 숫자로 된 label만 취급 문자로 표현된 label을 숫자로 바꿈 ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/data-processing/","title":"Data Processing"},{"content":"Deep Neural Network DNN  MLP (다층 퍼셉트론)에서 은닉층의 갯수 증가시킴  당시에는 기술적인 문제, 컴퓨터 성능 문제가 있었음   Visual, 음성인식, 자연어 처리, 기계 번역 등에서 뛰어난 성능  DNN으로 성능개선한 이유  MLP의 문제점 개선  graadient vanishing 문제 손실함수 overfitting   Big Data GPU 성능 개선  은닉층의 역할  Deep%20Neural%20Network/Untitled.png \n MLP에서는 Feature 추출을 사람이 함 딥러닝은 Feature 추출까지 Hidden Layer에서 자동으로 함  Vanishing Gradient 현상  Deep%20Neural%20Network/Untitled%201.png \n MLP에서 발생 역전파를 통해 구했던 오차의 기울기 등이 점점 사라짐 원인  Sigmoid 활성화 함수가 원인 은닉층이 많아지면 출력층에서 계산된 그래디언트가 역전파되다가 값이 점점 작아져 사라짐   대처  새로운 활성화 함수인 ReLU 사용    ReLU  새로운 활성화 함수 max(0, x)  계산이 간단 → 빠름    손실함수 MSE (Mean Squared Error)  평균제곱오차 에측값에서 실제값을 뺀것에서 제곱한 뒤 평균을 냄  Softmax 함수  출력값들을 모두 0~1 사이 값으로 정규화 출력의 총합은 항상 1  가중치 초기화  경사하강법으로 학습 → 학습시작 시점 가중치 설정 중요 입력의 계수와 출력의 계수가 적절히, 표준편차가 균등하게 하여 오류가 전파되는 부분을 안정화 Xavier 초기화  이전 은닉층의 노드 수에 맞추어 변화된 표준편차 이용    Optimizer  학습 속도를 빠르고 안정적으로 하는 것  Momentum  학습속도를 가속시킴 전역최소값을 찾는데 도움  Optimizer의 종류  Deep%20Neural%20Network/Untitled%202.png \n 스텝 방향 스탭 사이즈 (속도)  Regularization 규제화  Deep%20Neural%20Network/Untitled%203.png \n 모델이 복잡하여 생긴 과적합 해결  Data Augmentation  데이터가 부족하여 생긴 과적합을 해결  데이터를 변형시켜 (이미지의 경우 돌리거나 등..) 데이터 양을 늘림    Drop Out  Deep%20Neural%20Network/Untitled%204.png \n 은닉층의 노드가 너무 많아 생긴 과적합을 해결 학습 시 전체 신경망 중 일부만 사용 예측할 때는 모든 노드를 사용 ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/deep-neural-network/","title":"Deep Neural Network"},{"content":"Dicision Tree Information Theory  정보량을 수치화하고 그것의 연산을 가능하게 하는 것  Quantity of Information 정보량  불확실성 확률이 낮은 사건일수록 정보량 (불확실성)은 높다 확률과 정보량은 반비례관계 \u0026ldquo;오늘 하루 종일 맑다\u0026rdquo;  \u0026lsquo;내일은 맑다\u0026rsquo; 의 불확실성 \u0026lsquo;내일은 큰 비가 온다\u0026rsquo; 의 불확실성    Information Entropy  Dicision%20Tree/Untitled.png \n H(X)가 정보 엔트로피 값이고, 아래 축은 시행에서 어떤 사건이 일어날 확률입니다. 확률이 0.5일 때 엔트로피가 가장 높은 1임을 볼 수 있고, 확률이 한 쪽으로 편향될수록 엔트로피가 낮아지는 것을 볼 수 있습니다.\n  확률 변수의 정보량 얻은 정보가 의미있는 정보인지 (정보량)를 판단 가장 랜덤일 경우 엔트로피는 1 (최대) 아닐 경우 1 이하. 고정일 경우 0   Dicision%20Tree/Untitled%201.png \n상호정보량 Mutual Information  하나의 확률변수가 다른 확률변수에 대해 제공하는 정보의 양  Decision Tree  분류, 회귀에서 사용 트리 형태로 의사결정 지식을 표현한 것   Dicision%20Tree/Untitled%202.png \n 내부 노드 : 비교 속성 단말 노드 (ternimal node) : 기대값 간선 (edge) : 속성 값  Decision Tree알고리즘  반복적인 노드 분할 과정  분할 속성 (spliting attribute) 을 선택 속성값에 따라 서브트리를 생성 데이터를 속성값에 따라 분배    분할속성 결정 방법 Information Gain (정보 이득)  어떤 분류를 통해 얼마나 information에 대한 이득이 생겼는지를 나타냄 Entropy를 통해 계산 어떤 Feature를 선택함으로써 더 데이터를 잘 구분하는지  엔트로피 계산  Dicision%20Tree/Untitled%203.png \n Dicision%20Tree/Untitled%204.png \n Dicision%20Tree/Untitled%205.png \n Dicision%20Tree/Untitled%206.png \n Dicision%20Tree/Untitled%207.png \n속성별 정보이득  IG(Pattern) = 0.246 IG(Outline) = 0.151 IG(Dot) = 0.048  분할속성 선택  정보이득이 큰것 선택  Pattern 선택     Dicision%20Tree/Untitled%208.png \nDecision Tree 개선 척도  정보이득비 (빠르게 건너뜀) 지니지수 (빠르게 건너뜀)  분할속성 평가 척도 비교  Dicision%20Tree/Untitled%209.png \n결정트리 알고리즘  ID3  범주형 속성값을 갖는 데이터   C4.5  범주형 + 수치형 속성값 ID3을 개선   CART  수치형 속성값    앙상블 Ensemble Classifier  Dicision%20Tree/Untitled%2010.png \n학습기 결합  선형 분류기와 같은 간단한 인식기로 학습을 수행 복수 개의 선형 분류기의 학습 결과를 결합해 좋은 성능의 인식기를 만듬  장점  나쁜 운을 피할 수 있다 성능향상 데이터 양, 질에 따른 어려움 극복 결정 경계가 너무 복잡한 경우 사용  결합  병렬적 결합  한번에 일괄로 분류하여 최종 결과 생성   순차절 결합  각 분류기의 결과를 순차적으로 조합    결합 방법의 분류  Filter에 의한 방법 (순차)  각 분류기 학습때마다 새로운 데이터를 생성 Boosting, Cascading   Resampling에 의한 방법 (병렬)  주어진 전체 데이터로부터 일부 집합을 추출하여 각 분류기를 학습 Bagging, MadaBoost   Rewrighting에 의한 방법  모든 분류기에 대해 동일한 학습 데이터 사용 → 각 데이터에 가중치를 부여해 학습에 대한 영향도 조절 AdaBoost    배깅 (Bagging, bootstrap aggregating)  Dicision%20Tree/Untitled%2011.png \n 부트스트랩을 통해 여러개의 학습데이터 집합을 만들고, 각 학습 데이터 집합별로 분류기를 만들어 이들이 투표나 가중치 투표를 하여 최종 판정  랜덤 포레스트 (Random Forest)  분류기로 결정트리를 사용하는 배깅 기법  부스팅 (Boosting)  Dicision%20Tree/Untitled%2012.png \n K개의 분류기를 순차적으로 만들어가는 앙상블 기법 분류 정확도에 따라 학습데이터에 가중치를 변경해가면서 분류  AdaBoost  검색필요 ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/dicision-tree/","title":"Dicision Tree"},{"content":"Dimensionality Reduction (차원축소)  Dimensionality%20Reduction%20(%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%89%E1%85%A9)/Untitled.png \n 목적에 따라 데이터의 양을 줄이는 방법  데이터의 양이 줄어들면 시간복잡도 및 공간복잡도가 줄어듬 아주 많은 차원의 데이터로 학습시키면 overfitting 되기 쉬움 모델의 간단화  사람이 이해하기 쉽고 내놓은 결과 또한 2차원, 3차원으로 나타내기 쉬움     dimention = feature  데이터의 한 Column    Feature Selection  Forward Search  F를 비어있는 공집합으로 둠 에러 E를 구하는데, 원래 데이터셋의 Feature 하나하나 F에 넣어가면서 가장 성능이 좋은 (에러가 낮은) Feature를 구해 영구적으로 등록 목표로 하는 feature 갯수 K개가 될 때 까지 반복   Backward Search  위와 반대로 F가 데이터 전체 하나하나 Feature를 퇴출시켜 가면서 최적의 Feature만 냄김 목표로 하는 feature 갯수 K가 될 때 까지 반복    Feature Extraction  위에서는 데이터 열을 선별하는 방법이지만, 이것은 여러 무더기의 데이터 열을 압축함   Dimensionality%20Reduction%20(%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%89%E1%85%A9)/Untitled%201.png \n Dimensionality%20Reduction%20(%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%89%E1%85%A9)/Untitled%202.png \n Dimensionality%20Reduction%20(%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%89%E1%85%A9)/Untitled%203.png \nPrincipal Component Analysis (PCA)  Dimensionality%20Reduction%20(%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%89%E1%85%A9)/Untitled%204.png \n Dimensionality%20Reduction%20(%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%89%E1%85%A9)/Untitled%205.png \n 데이터 손실을 최소화하는 방향으로 차원 축소 진행 ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/dimensionality-reduction-%EC%B0%A8%EC%9B%90%EC%B6%95%EC%86%8C/","title":"Dimensionality Reduction (차원축소)"},{"content":"Neural Network 신경망  인간의 뇌 신경망을 모사 최초 : 1949년 Hebb 학습 알고리즘 1958년 Perceptron  단층은 선형분리만 가능 이후 1986년 다층 퍼셉트론, 오류 역전파 학습 알고리즘 통해 실용적 문제 해결   2013년 Deep Learning  신경세포 계산 모델  Neural%20Network/Untitled.png \n 각 입력에 가중치 곱함 이를 합한것이 일정 수치를 넘으면 (임계값) Activation → 다음 세포에게 넘김  퍼셉트론  Neural%20Network/Untitled%201.png \n Neural%20Network/Untitled%202.png \n Neural%20Network/Untitled%203.png \n Neural%20Network/Untitled%204.png \n 가중치와 바이어스 값을 조절하여 결과를 도출 논리연산 AND 학습과정 연습해야할듯  퍼셉트론의 한계  Neural%20Network/Untitled%205.png \n 선형 분리는 되는데 XOR은 안됨  직선만 그어서 분리가 안된다    다층 퍼셉트론  Neural%20Network/Untitled%206.png \n 대부분의 입력 패턴은 선형으로 분리 불가 여러개의 퍼셉트론을 여러층으로 연결해 복잡한 영역을 곡면으로 둘러싸는 결정 영역을 구함  다층 퍼셉트론  입력층과 출력층 사이에 은닉층을 가지고 있는 신경망   Neural%20Network/Untitled%207.png \n역전파 알고리즘  Neural%20Network/Untitled%208.png \n 순방향으로 계산하여 출력을 계산한 후에 실제 출력과 우리가 원하는 출력 간의 오차를 계산 오차를 역방향으로 전파하며너 오차를 줄이는 방향으로 가중치를 변경 다양한 비선형 함수들을 활성화 함수로 사용  활성화 함수  미분이 가능하고 연속적인 함수   Neural%20Network/Untitled%209.png \n손실함수  오차를 계산하는 함수 MSE RMSE Cross Entropy  경사하강법  손실을 최소로 만드는 최적화 문제 손실함수의 최소값을 찾기위한 1차 미분값을 계산하고 반대 방향으로 움직임 ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/neural-network/","title":"Neural Network"},{"content":"Regression Regression (회귀)  회귀는 여러개의 독립변수와 한개의 종속변수 간 상관관계를 모델링하는 기법 Y=W1∗X1+W2∗X2+W3∗X3+⋯+Wn∗Xn  Y = 결정 값, 종속변수 (아파트 가격) X1..Xn = Feature. 독립변수 (방 개수, 방 크기 등)   W1\u0026hellip;Wn = 회귀 계수. 독립변수의 값에 영향을 미침.   Regression/Untitled.png \nLinear Regression  Regression/Untitled%201.png \n 선형회귀의 예  부모의 키와 자녀의 키 관계 조사 면적에 따른 주택의 가격 CPU 속도와 프로그램 실행 시간 예측   선형 회귀 모델  입력 데이터를 가장 잘 설명하는 함수 f(x) = mx+b에서 기울기와 절편값을 찾는 문제이다  오차의 합이 가장 낮은 함수를 찾음   기울기 → 가중치 절편 → 바이어스    손실함수 (Loss Function) = 비용함수 (Cost Function)  실제값과 예측값의 차이를 수치화해주는 함수 오차가 클수록 손실 함수의 값이 크고, 오차가 작을수록 손실 함수의 값이 작아짐 손실 함수의 값을 최소화하는 W(weight), b(bias)를 찾는 것이 학습 목표   Regression/Untitled%202.png \n손실함수 최소화 방법  Regression/Untitled%203.png \n 경사하강법 (Gradient descent method)  Gradient descent method 경사하강법  점진적으로 반복적인 계산을 통해 W 파라미터의 값을 업데이트하면서 오류값이 최소가 되는 W를 구함  최초 오류값이 100이었다면, 두번째 오류값은 90, 세번째는 80과 같이 지속해서 오류를 감소시키는 방법으로 W를 업데이트 오류값이 더이상 작아지지 않으면 그 오류값을 최소비용으로 판단하고 W값을 최적 파라미터로 변환    Multi-Variable linear regression  Regression/Untitled%204.png \nPolynomial Regression  Regression/Untitled%205.png \n","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/regression-%ED%9A%8C%EA%B7%80/","title":"Regression (회귀)"},{"content":"Supervised Learning Classification\nRegression\n 1. 분류 (Classification)  Supervised%20Learning/Untitled.png \n 데이터들을 정해진 몇 개의 부류로 대응시키는 문제 분류 문제의 학습  학습 데이터를 잘 분류할 수 있는 함수를 찾는 것 함수의 형태는 수학적 함수일 수 있고, 규칙일 수도 있음   분류기 (Classifier)  학습된 함수를 이용해 데이터를 분류하는 프로그램    분류기 학습 알고리즘  Naive Bayes Logistic Regression K-nearest neighbor (KNN) Dicision Tree Random Forest Support Vector Machine (SVM) 다층 퍼셉트론 신경망 Deep Learning 앙상블: Bagging, AdaBoost 확률 그래프 모델  이상적인 분류기  학습에 사용되지 않은 데이터에 대해 분류를 잘 함 일반화 능력이 좋은 것  데이터의 구분  Training Data  Classifier를 학습하는데 사용하는 데이터셋 많을수록 유리   Test Data  학습된 모델의 성능을 평가하기 위해 사용되는 데이터셋 학습에 사용되지 않은 데이터여야 함   Validation Data  학습 과정에서 학습을 중단할 시점을 결정하기 위해 사용하는 데이터셋    Overfitting, Underfitting  Supervised%20Learning/Untitled%201.png \n 과적합  학습 데이터를 지나치게 잘 학습 데이터는 오류와 잡음을 포함할 개연성이 큼 → 학습되지 않은 데이터에 대해 좋지 않은 성능을 보일 수 있다   부적합  학습 데이터를 충분히 학습하지 않음    Overfitting 회피방법  Supervised%20Learning/Untitled%202.png \n 학습을 진행할 수록 오류 개선 경향 지나치게 학습되면 과적합 발생 학습 과정에서 별도의 Validation Data에 대한 성능 평가  검증 데이터에 대한 오류가 감소하다가 증가하는 시점에 학습 중단    기계 학습에서의 Bias vs Variance 관계  Supervised%20Learning/Untitled%203.png \n Bias: 편향 → 인풋에 대한 라벨 예측 정확도 Variance: 분산 → 아웃풋의 다양함 예측값들과 정답이 대체로 멀리 떨어져 있으면 결과의 Bias가 높다 예측값들이 자기들끼리 대체로 멀리 흩어져 있으면 결과의 Variance가 높다  이진 분류기의 성능 평가  Supervised%20Learning/Untitled%204.png \n 두개의 부류만을 갖는 데이터에 대한 분류기   Supervised%20Learning/Untitled%205.png \n 0의 경우  실제 값은 3개, 예측은 2개만 분류. precision (예측 정확도)  예측된 2개 값 중 맞은 것 2개. 따라서 2/2 → 100%   recall (재현률)  실제 값 3개 중 2개가 예측됨. 따라서 2/3 → 0.67     1의 경우  실제 값은 1개, 예측은 3개만 분류 precision (예측 정확도)  1/3   recall (재현률)  1/1       Supervised%20Learning/Untitled%206.png \n 재현률이 높으면 정확도가 떨어짐 정확도가 높으면 재현률이 떨어짐 ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/supervised-learning/","title":"Supervised Learning"},{"content":"Unsupervised Learning Clustering (군집화)\nDimensionality Reduction (차원축소)\n 개요  결과정보가 없는 데이터들에 대해 특정 패턴을 찾는 것 군집화, 밀도추정, 차원축소 알고리즘 이용 ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/unsupervised-learning/","title":"Unsupervised Learning"},{"content":"게임트리 (minmax, alpha-beta pruning)  %E1%84%80%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(minmax,%20alpha-beta%20pruning)/Untitled.png \n1. Game Tree Search 게임트리  %E1%84%80%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(minmax,%20alpha-beta%20pruning)/Untitled%201.png \n 상대가 있는 게임에서 자신과 상대방의 가능한 게임 상태를 나타낸 트리  틱택톡, 바둑, 장기, 체스 등   게임의 결과는 마지막에 결정. 제로섬. 많은 수를 볼수록 유리  Mini-Max 알고리즘 ⭐  하단부터 상단까지 올라감\n  %E1%84%80%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(minmax,%20alpha-beta%20pruning)/Untitled%202.png \n  MAX 노드\n 자신에 해당하는 노드 자신에게 유리한 최대값 선택    MIN\n 상대방에 해당하는 노드 최소값 선택    단말 노드부터 위로 올라가면서 최소-최대 연산을 반복하여 자신이 선택할 수 있는 방법 중 가장 좋은 것으로 값 결정\n   %E1%84%80%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(minmax,%20alpha-beta%20pruning)/Untitled%203.png \n DFS Depth m, branch b → 시간복잡도 O(b^m)  알파-베타 가지치기 ⭐  %E1%84%80%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(minmax,%20alpha-beta%20pruning)/Untitled%204.png \n %E1%84%80%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20(minmax,%20alpha-beta%20pruning)/Untitled%205.png \n 검토할 필요가 없는 부분을 탐색하지 않도록 하는 기법 깊이 제한 DFS로 탐색을 할 때, 알파 값과 베타 값이 자식 노드로 전달된다 자식 노드에서는 알파와 베타 값을 비교해 쓸데없는 탐색을 중지  a- 자르기 : MIN 노드의 현재값 b가 부모노드의 a값보다 작거나 같으면, 나머지 자식 노드 탐색 중지 b- 자르기 : MAX 노드의 현재값 a가 부모노드의 b값보다 같거나 크면, 나머지 자식 노드 탐색 중지    몬테카를로  수학적이나 이론적으로 접근할 수 없을 때 사용 수많은 무작위 수 사용하여 반복 실험 → 예상확률 이미 알고있는 부분과 수학적으로 적절히 구성 ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/%EA%B2%8C%EC%9E%84%ED%8A%B8%EB%A6%AC/","title":"게임트리"},{"content":"딥러닝 인터뷰 Diff between AI, ML and Deep Learning  AI: technique which enables machines to mimic human behaviour. ML: using statical methods to enable machines to improve with experience Deep learning: Subset of ML, using multi layer neural network  Do you think deep learning is better than machine learning? if so, why?  머신 러닝은 데이터가 많아질수록 느려짐, 딥러닝은 그렇지 않음 머신 러닝은 feature를 직접 지정해줘야 함. 딥러닝은 알아서 학습  What is Perceptron? And how does it work? What is the role of weights and bias? What is the activation function? Steps of perceptron  Init the weights and threshold Provide the input and calculate the output Update the weights Repeat Steps 2 and 3  What is cost/loss function  A cost function is a measure of the accuracy of the neural network with respoect to a given training sample and expected output it provides the perfomance of a neural network.  in deep learning, the goal is to minimize the cost function. use gradient descent    Gradient descent  optimization algorithm used to minimize some function by iteratively moving in the direction of steepest descent.  Mini-batch gradient  %E1%84%83%E1%85%B5%E1%86%B8%E1%84%85%E1%85%A5%E1%84%82%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%87%E1%85%B2/Untitled.png \n more efficient compared to stochastic gradient descent generalization by finding the flat minima mini-batches allows help to approximate the gradient of the entire training set which helps us to avoid local minima  What are the steps for using a gradient descent algorithm  init random weight and bias pass an input thru the network and get values from the output layer calculate the error between the actual value and the predicted value go to each neuron which contributes to the error and then change its respective values to reduce the error reiterate until you find the best weights of the network  What are the shortcomings of a single layer perceptron?  Single layer perceptron only can classify linearly saparable data points. Complex problems requiring lots of parameters cannot be solved.  What is Multi Layer Perceptron?  %E1%84%83%E1%85%B5%E1%86%B8%E1%84%85%E1%85%A5%E1%84%82%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%87%E1%85%B2/Untitled%201.png \n MLP is a deep artificial neural network composed by multiple perceptron Input Layer + Hidden Layer + Output Layer  입력값을 받음 + 실제 계산 레이어 + 결정/추론 아웃풋    What are the different parts of a multi layer perceptron?  Input Nodes  입력값을 Hidden Nodes에 패스   Hidden Nodes  실제 계산 수행 Transfer information from input to output   Output Nodes  값 출력 및 추론 담당    What is Data Normalization and Why do we need it?   Rescale values to fit in a specific range\n To assure better convergence during backpropagation    신경망의 학습을 빠르게 하기 위해\n 각각 Unnormalized, Normalized 데이터들의 비용 함수   %E1%84%83%E1%85%B5%E1%86%B8%E1%84%85%E1%85%A5%E1%84%82%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%87%E1%85%B2/Untitled%202.png \n Normalized의 경우 어디서 시작하던 쉽게 최적값에 도달 가능    Backpropagation  Calculate the error and propagate it back to the earlier layers.  Hyper Parameter  모델링 시 사용자가 직접 세팅해주는 값 (즉 일반적으로 말하는 파라미터) Hidden Layers, Test Results, Learning rate, KNN에서의 K값 등\u0026hellip;  Dropout  %E1%84%83%E1%85%B5%E1%86%B8%E1%84%85%E1%85%A5%E1%84%82%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%87%E1%85%B2/Untitled%203.png \n Regularization technique to avoid overfitting by model complexity ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%9D%B8%ED%84%B0%EB%B7%B0/","title":"딥러닝 인터뷰"},{"content":"머신 러닝 연역적 학습 VS 귀납적 학습  연역적  모든 포유동물은 심장을 기자고 있다 모든 말은 포유동물이다 → 모든 말은 심장을 가지고 있다   귀납법  참새는 하늘을 난다 제비는 하늘을 난다 모든 새는 하늘을 난다    귀납적 학습  사례들을 일반화하여 패턴, 모델 추출 일반적인 기계학습의 대상 학습 데이터를 잘 설명할 수 있는 패턴을 찾는 것  전통적인 프로그래밍과 머신러닝  %E1%84%86%E1%85%A5%E1%84%89%E1%85%B5%E1%86%AB%20%E1%84%85%E1%85%A5%E1%84%82%E1%85%B5%E1%86%BC/Untitled.png \n 전통적인 프로그래밍 → 데이터와 규칙을 주면 답이 나옴 머신러닝 → 데이터와 답을 주면 규칙이 나옴  사람의 학습과 기계 학습의 비교  %E1%84%86%E1%85%A5%E1%84%89%E1%85%B5%E1%86%AB%20%E1%84%85%E1%85%A5%E1%84%82%E1%85%B5%E1%86%BC/Untitled%201.png \n머신러닝 응용 분야  복잡한 데이터들이 있고, 이들 데이터에 기반해 결정을 내려야 하는 분야 문자인식 자율주행 광고, 상품 추천 안면인식 등.. 보안시스템 (해킹방어)  지도학습 (Supoervised Learning)  입력 - 출력의 데이터들로부터 새로운 입력에 대한 출력을 결정할 수 있는 패턴 추출 분류 (Classification) 회귀 (Regression)  비지도학습 (Unsupervised Learning, 자율학습)  출력에 대한 정보가 없는 데이터로부터 필요한 패턴 추출 군집 (Clustering) 차원축소 (Dimension Reduction)  강화학습 (Reinforcement Learning)  출력에 대한 정확한 정보는 제공하지 않음 평가정보 (Reward)는 주어지는 문제에 대해 각 상태에서의 행동을 결정  판별모델 (Discriminative Model)  Supervised Learning 반 고흐가 그렸는지 예측하는 판별 모델 샘플 X가 주어졌을 때 레이블 Y의 확률을 Estimate   %E1%84%86%E1%85%A5%E1%84%89%E1%85%B5%E1%86%AB%20%E1%84%85%E1%85%A5%E1%84%82%E1%85%B5%E1%86%BC/Untitled%202.png \n P(Y|X)를 직접적으로 도출  데이터 X가 주어졌을 때 클래스 레이블 Y가 나타날 조건부확률을 직접적으로 도출 입력값 X의 차원이 높아질수록 계산량이 증가 → 학습이 어려워짐 대부분 지도학습에 해당  클래스 레이블 정보 Y가 필요하기 때문     Dicision Boundary를 학습하는 것이 목표  분별모델은 데이터 X가 주어졌을 때 Y1에 속할지, Y2에 속할지 구분하는데 관심    생성모델 (Generative Model)  Unsupervised Learning 새로운 데이터 셋을 생성하는 방법을 기술 이 모델에서 샘플링하면 새로운 데이터를 생성 가능 생성 모델은 확률적이여야 한다 예시) 말 이미지를 생성하는 모델  말의 외관을 결정하는 일반적인 규칙을 학습해야 한다 이 규칙은 확률적이여야 함 → 고정된 계산만 수행한다면 매번 동일한 값을 출력하기 때문 결론적으로 원본 training set에 있을 것 같지만 완전히 새롭고 다른 샘플을 생성해야함     %E1%84%86%E1%85%A5%E1%84%89%E1%85%B5%E1%86%AB%20%E1%84%85%E1%85%A5%E1%84%82%E1%85%B5%E1%86%BC/Untitled%203.png \n P(Y|X)를 간접적으로 도출  데이터 X가 생성되는 과정을 두개의 확률모형으로 모델링 베이즈 정리를 이용해 P(Y|X)를 간접적으로 도출   P(Y)와 P(X|Y)의 확분포를 학습하는 것이 목표  범주의 분포를 학습하는 것이 목표 화가의 화풍을 학습시켜 어떤 그림을 그 화풍으로 변환하는 등..   ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/","title":"머신러닝"},{"content":"용어정리 Explain the following terms.   singularity\n 특이점. 인공지능이 인간의 지능을 능가하는 기점    chatbot\n 챗봇. 인간이 아닌 기계가 인간을 응대하는 서비스. 앱 내 고객센터 등에 사용.    fuzzy logic\n 전통적인 방식은 1로 참, 0으로 거짓 fuzzy 로직은 0~1 사이에서 어떤 값이라도 나올 수 있도록 함  즉 0.7로 애매하게 참, 0.3으로 애매하게 거짓을 나타낼 수 있도록 함      fuzzy set\n 위의 퍼지 논리를 이용해 기존의 집합 개념을 확장 집합에 속하는 정도를 참, 거짓이 아닌 애매하게 속한다는 개념도 표현 가능한 소속도로 나타냄    regression\n 회귀. 여러개의 독립변수와 하나의 종속변수의 상관관계를 모델링하는 기법.    epoch\n %E1%84%8B%E1%85%AD%E1%86%BC%E1%84%8B%E1%85%A5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5/Untitled.png \n 훈련 데이터셋에 포함된 모든 데이터들이 한번씩 모델을 통과한 횟수 epoch가 10회라면 학습데이터셋 A를 10회 모델에 학습시켰다는 것 epoch를 높일수록 다양한 무작위 가중치로 학습을 해보므로 적합한 파라미터를 찾을 확률이 올라감 그러나 지나치게 높이면 overfitting됨    Batch size\n 연산 한번에 들어가는 데이터의 크기    data normalization\n 데이터 전처리 기법의 하나로 feature들을 0~1 사이의 값으로 모두 평준화하여 학습의 효율을 높임.    overfitting\n 과적합. 과도하게 학습되어 새로운 데이터에 대한 예측이 어려움.    loss function\n 손실함수. 실제 데이터와 예측값의 차이를 도출. 차이가 작을수록 좋다.    information gain\n 정보이득. 어떤 Feature를 선택해야 가장 정보적으로 이득되는지 판별하는 척도. 디씨젼 트리에서 사용.    bayes rule\n 베이즈 정리. 두 확률 변수의 사전확률과 사후 확률 사이의 관계를 나타냄.    gradient descent\n 경사하강법. 기울기를 이용해 함수의 최소값을 찾아간다.      quantities of information  불확실성의 양을 뜻한다. 확률이 낮을수록 정보량은 높다. Information theory에서 이를 이용해 정보량을 계산한다.   information entropy  어떤 정보가 주어졌을 때 해당 정보가 의미있는 정보인지 파악할 때 사용된다. 0에 가까울수록 정보량이 없는 것이고 1에 가까울수록 정보량이 많음을 의미한다.   cross entropy  교차 엔트로피. 신경망의 손실함수로 사용된다. Cross Entropy가 작으면 예측값과 실제값이 거의 일치함을 뜻한다.   mutual information  상호 정보량. 두 정보를 따로따로 보았을 때 보다 같이 보았을 때 얼마나 더 불확실성이 감소하였는가를 정량화. 두 정보의 연관성을 볼 때 사용.      artificial intelligence  AI란 사람의 행동을 모방하도록 설계된 기계 혹은 소프트웨어, 방법론을 뜻한다.   machine learning  머신러닝이란 AI를 구현하기 위해 사용되는 방법 중 하나이며 사람이 Feature들을 선별하여 학습시킨다.   deep learning  딥러닝은 머신러닝의 일종으로 히든 레이어에서 자체적으로 Feature를 학습하여 머신러닝보다 상대적으로 간편하다.      bias  편향. 결과의 정확도를 의미한다.   variance  분산. 결과의 다양성을 의미한다.      K-means  Algorithm that forms K clusters for a given K How to automatically determine K?  K값을 1씩 더해서   How can you determine which clusters are better than others for the same data  응집도를 보고 판단     Overfitting  How to avoid overfitting in terms of the amount of learning data, the learning epoch, complexity of the model  learning data, learning epoch가 많을수록, 모델의 복잡도가 높을수록 overfitting이 될 확률이 높으므로 적절하게 설정하는 것이 중요하다. 예를들어 learning data의 경우 전처리 및 차원축소 등을 실행하거나, epoch의 경우 너무 높에 설정하지 않아야하고, 모델의 복잡도가 너무 높은 경우 레귤레이션이나 드롭아웃을 통해 해결한다.        Generalization  일반화. 트레이닝 셋이 아닌 데이터를 넣어도 정확도가 최대한 유지된 채로 아웃풋이 나오도록 하는 것.   Optimization  최적화. 아웃풋의 오류가 가장 적은 하이퍼 파라미터들을 찾는 것   ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC/","title":"머신러닝 용어정리"},{"content":"베이즈 정리 \u0026amp; 확신도 불확실성의 원인  약한 관련성의 지식  IF와 THEN의 연관성의 강도가 약하다 약한 인과성이나 애매한 연관관계 베이즈 정리, 확신도 사용 표현   부정확한 언어 사용  자연어는 모호하고 부정확 자주 본다? 퍼지이론 사용 표현   불완전한 데이터에 기반한 지식  알려지지 않은 것으로 간주하고, 근사적인 추론 진행   상충되는 지식의 통합  모순된 견해와 상충된 지식의 통합    베이즈 정리  %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled.png \n %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%201.png \n베이즈 정리 예시  %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%202.png \n %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%203.png \n베이즈 추론  %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%204.png \n 지식의 규칙 표현  사건 E가 일어났을 때 H가 일어날 확률  %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%205.png \n %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%206.png \n단일 증거 E에 기반을 둔 다중 가설 H1, H2\u0026hellip; Hm에 대한 식  %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%207.png \n증거 E1, E2\u0026hellip;Em과 가설 H1, H2, Hm\u0026hellip;.에 관한 식  %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%208.png \n다른 증거 간의 조건부 독립성 (Naive Bayesian)  %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%209.png \n %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2010.png \n %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2011.png \n %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2012.png \nForecast-Bayesian Reasoing LS (Likelihood of Sufficiency)  %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2013.png \n 충분 가능성 증거 E가 있을 때 가설 H를 신뢰하는 정도를 의미  LN (Likelihood of Necessity)  %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2014.png \n 필요 가능성 증거 E가 없을 때 (아닐 때) 가설 H를 불신하는 정도를 의미  예시  %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2015.png \n확률을 이용한 규칙의 불확실성 표현  LS값이 크다 = 증거가 관찰되면 가설이 성립될 확률이 크다 LN값이 작다 = 증거가 없다면 (아니라면) 가설이 성립되지 않을 확률이 크다  사전 확률과 사후 확률 사전 확률  %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2016.png \n 현재 가지고 있는 정보를 기초로 하여 정한 초기 확률 확률 시행 전에 이미 가지고 있는 지식을 통해 부여한 확률 예) 동전을 던져 앞면이 나올 확률  사후 확률  사건 발생 후에 어떤 원인으로부터 일어난 것이라고 생각되어지는 확률 추가된 정보로부터 사전 정보를 새롭게 수정한 확률 베이즈 정리로부터 구할 수 있음  가설의 사후 확률을 얻는 방법  %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2017.png \n %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2018.png \n %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2019.png \n확신도  전문가가 제안하는 가설이 믿을만한가를 표시한 정도 -1~1 구간의 값으로 표현   %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2020.png \n %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2021.png \n %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2022.png \n %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2023.png \n %E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B3%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20\u0026amp;%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%89%E1%85%B5%E1%86%AB%E1%84%83%E1%85%A9/Untitled%2024.png \n","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/%EB%B2%A0%EC%9D%B4%EC%A6%88-%EC%A0%95%EB%A6%AC%EC%99%80-%ED%99%95%EC%8B%A0%EB%8F%84/","title":"베이즈 정리와 확신도"},{"content":"부정확한 언어 - 퍼지이론 불확실한 지식  주관적  예쁘다 → 불분명    불확실성의 원인  약한 관련성의 지식  IF와 THEN의 연관성의 강도가 약하다 약한 인과성이나 애매한 연관관계 베이즈 정리, 확신도 사용 표현   부정확한 언어 사용  자연어는 모호하고 부정확 자주 본다? 퍼지이론 사용 표현   불완전한 데이터에 기반한 지식  알려지지 않은 것으로 간주하고, 근사적인 추론 진행   상충되는 지식의 통합  모순된 견해와 상충된 지식의 통합    Boolean Logic  자연어의 단어 (word)는 집합의 궁극적인 표현 일반집합  집합에 속하거나, 속하지 않거나 집합에 명확한 경계를 긋고, 집합의 원소에는 1, 원소가 아닌것에는 0으로 소속시킴    Fuzzy Logic  %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled.png \n %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%201.png \n %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%202.png \n 모호한 대상을 다루는 논리 퍼지 집합, 즉 모호한 정도를 조절할 수 있는 집합에 대한 이론 온도, 높이, 빠르기, 거리, 미모 등이 경계가 불투명한 척도 0~1 사이에 있는 연속된 논리값을 사용  Fuzzy Set의 소속 정도를 사용한 언어항 표현  %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%203.png \n퍼지 집합 표기  %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%204.png \n언어변수  %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%205.png \n 퍼지변수  퍼지 집합 한정사 (Hedge)  %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%206.png \n %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%207.png \n퍼지 규칙의 추론 방법  %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%208.png \n 퍼지화. X1, Y1를 입력받고 이를 어느 정도 소속도로 정할 지 결정 규칙 평가. 퍼지 입력을 받아 퍼지 규칙의 IF에 적용 출력으로 나온 규칙의 통합. 모든 규칙의 출력을 단일화 역퍼지화. 퍼지 추론의 결과를 실수값으로 변경   맘다니 / 스게노형으로 나뉨  맘다니형 추론  %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%209.png \n %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%2010.png \n %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%2011.png \n %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%2012.png \n확률  %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%2013.png \n독립사건/배타적사건  %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%2014.png \n 동시에 일어날 수 없는 사건 주사위 실험에서 1, 6이 나오는 두 사건은 상호 배타적  결합 확률  사건 A와 B가 동시에 일어날 확률   %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%2015.png \n조건부 확률  %E1%84%87%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%AA%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%20-%20%E1%84%91%E1%85%A5%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB/Untitled%2016.png \n","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/%EB%B6%80%EC%A0%95%ED%99%95%ED%95%9C-%EC%96%B8%EC%96%B4-%ED%8D%BC%EC%A7%80%EC%9D%B4%EB%A1%A0/","title":"부정확한 언어 - 퍼지이론"},{"content":"유전 알고리즘 Genetic Algorithm  %E1%84%8B%E1%85%B2%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7/Untitled.png \n최적화 문제  가장 근접한 해를 찾는 방법 Hill-Climbing 알고리즘  산꼭대기 그거 미분을 통해 가장 가파른 경사를 알아내는 알고리즘   유전 알고리즘 (GA)  GA에서 출력을 얻을 수 있는 함수가 정의되면 어디서나 적용 가능 환경에 적합한 측도인 적합도를 늘리는 쪽으로 진화를 반복    염색체  %E1%84%8B%E1%85%B2%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7/Untitled%201.png \n %E1%84%8B%E1%85%B2%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7/Untitled%202.png \n 주어진 문제에 대한 가능한 해들의 집합을 표현한 자료구조 Encoding: 문제 공간을 염색체들의 형태로 변경 Decoding: 염색체들을 문제 공간으로 변경  평가함수  현재의 염색체가 얼마나 문제를 잘 해결하고 있는지 나타내는 함수  적합도를 반환    유전자 연산 (operation)  %E1%84%8B%E1%85%B2%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7/Untitled%203.png \n 염색체 선택 (selection)  적합도 값이 우수한 염색체들이 부모로 선택   유전자 교배 (crossover)  부모 염색체에서 유전자들을 서로 고환   돌연변이 (mutation)  염색체에서 임의 위치의 유전자 값을 바꿈    선택연산자 (Fitness Function)  룰렛 휠   %E1%84%8B%E1%85%B2%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7/Untitled%204.png \n %E1%84%8B%E1%85%B2%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7/Untitled%205.png \n교배연산자 (Crossover)   임의의 교배 위치 선택\n  단순 교배 (simple crossover)\n %E1%84%8B%E1%85%B2%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7/Untitled%206.png \n 하나의 부분만 교배 빠르게 부모와 변함 양쪽이 같은 값을 가지고 있는 부분은 바뀌지 않음    이점 교배 (two-point crossover)\n %E1%84%8B%E1%85%B2%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7/Untitled%207.png \n 두개 부분을 교체    단일교배 (uniform crossover)\n  역위 (inversion)\n  돌연변이  %E1%84%8B%E1%85%B2%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7/Untitled%208.png \n 다양한 개체군 유지 아주 낮은 돌연변이률  예제  %E1%84%8B%E1%85%B2%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7/Untitled%209.png \n %E1%84%8B%E1%85%B2%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7/Untitled%2010.png \n유전자 알고리즘의 장단점  예측한 그대로 동작하는 알고리즘이 존재하는 문제에는 의미가 없음 수행 시간 예측이 불가 최적의 솔루션이 필요없는, 기존의 방법으로 해결할 수 없는 문제에 종종 사용됨  유전자 프로그래밍  %E1%84%8B%E1%85%B2%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7/Untitled%2011.png \n 8 Queen, TSP ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/%EC%9C%A0%EC%A0%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","title":"유전 알고리즘"},{"content":"전문가시스템 🤖 1. 지식 및 전문가시스템  1960~1970 1차 AI 붐 → 1차 겨울: 계산기능한계, 논리체계한계 1980~1990 2차 AI 붐 → 2차 겨울: AI HW 시장 붕괴, Data 부족, 규칙학습 불가능 2010~20XX 3차 AI 붐 : 머신러닝, 딥러닝  데이터  %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled.png \n 데이터  특정 분야에서 관측된 아직ㅈ 가공되지 않은 것 오류나 잡음 포함 가능   정보  데이터를 가공하여 어떤 목적이나 의미를 갖도록 한 것   지식 지혜  경험과 학습을 통해서 얻은 지식보다 높은 수준의 통찰    지식  %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%201.png \n 정보를 취합하고 분석하여 얻은 대상에 대해 사람이 이해한 것 일반화, 규칙 표현형식  암묵지  당연한, 형식을 갖추어 표현하기 어려운 학습과 경험을 통해 쌓은 지식   형식지  비교적 쉽게 형식을 갖추어 표현할 수 있는 지식     표현 대상  절차적 지식  문제 해결의 규칙이나 절차 등 Symbolic   선언적 지식  어떤 대상의 특성에 대한 지식 색상 등.. Non-Symbolic      Production Rule  사실: Boolean 규칙: If ~ Then 형태의 문장 규칙 획득 및 표현  예) 신호등이 녹색일 때는 건널목을 안전하게 건널 수 있고, 빨간색일때는 길을 건너지 말아야 한다 대상, 속성, 행동/판단 정보 추출  대상: 신호등 속성: 녹색, 빨간색 행동/판단: 건던다, 멈춘다   표현  IF 신호등 = 녹색 THEN 건넌다, ELIF 신호등 = 빨간색 THEN 멈춘다     규칙을 통한 지식 표현  인과관계  원인을 조건부에, 결과는 결론부에 표현   추천  상황을 조건부에, 추천내용을 결론부에   지시  상황을 조건부에, 지시 내용을 결론부에   전략  일련의 규칙들로 표현   휴리스틱  일반적으로 바람직한 것을 표현      규칙기반 시스템  지식을 규칙의 형태로 표현 규칙들을 사용해 문제에 대한 해를 찾는 지식기반시스템  전문가 시스템  %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%202.png \n %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%203.png \n 특정 문제정역에 대해 전문가 수준의 해를 찾아주는 시스템 첫번째 겨울 이후 제한된 문제에 집중  전통적인 프로그램과 전문가시스템 비교  전통적인 프로그램은 항상 같은 순서 (알고리즘) 으로 처리 전문가시스템은 기술된 단계의 순서를 따르지 않음  정확하지 않은 추론 허용 확신도에 따라 불완전/불확실한 데이터를 처리    추론 엔진  %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%204.png \n추론  구축된 지식과 주어진 데이터를 이요하여 가설을 검증하거나, 새로운 사실을 유도하거나, 관련된 정보를 유추 생성 시스템 (Production System)  전향 추론 (foward reasoning)  %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%205.png \n 규칙의 조건부와 만족 규칙의 결론부를 실행  후향 추론  %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%206.png \n 결론부에 가지고 있는 규칙을 찾아서 조건부의 조건들이 모두 만족하는지 확인  전문가 시스템 구조  %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%207.png \n 지식/규칙베이스 : 사실, 규칙 작업메모리  사용자로부터 받은 문제에 대한 정보 관리 추론과정의 중간결과를 저장, 유도된 최종해 저장 작업 메모리에 저장되는 모든 것을 사실이라고 함   추론 엔진  실행할 수 있는 규칙을 찾아서, 해당 규칙을 실행하는 역할 패턴 매칭 - 경합 해소 - 규칙 실행의 과정 반복    경합 해소 전략  규칙 우선순위  작업 메모리의 사실과 규칙베이스에 있는 규칙의 조건부를 대조 일치하는 규칙을 찾는 과정   최신 우선 최초 우선 상세 우선  가장 상세한 조건부를 갖는 규칙    전문가시스템 개발 도구  LISP, Prolog Jess, CLIPS, EXSYS, SEOPS  전문가 시스템 장점  IF - THEN 규칙  전문가의 지식을 자연스럽게 표현 독립적이고 이해하기 쉬움   지식베이스와 추론엔진 분리  다른 영역에돋 쉽게 적용 가능   확신도를 사용하면 불완전하고 불확실한 지식 표현 가능  전문가 시스템 단점  지식을 학습할 수 없음  전문가가 새로운 지식을 추가, 변경해야 함   비효율적인 탐색 규칙이 많아지면 상호관계가 불명확해짐. 유지보수가 어려움.  2. Sementic Network 의미망  %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%208.png \n 지식을 이항 관계의 집합으로 표현 방향성 그래프를 이용해 지식 표현  노드  대상, 개념, 행위, 상태, 사건   간선  관계가 있는 노드들을 연결 관계에 따른 방향 관계의 이미를 나타내는 라벨 부여      관계 🔵 is-a   상위 클래스와 하위 클래스 관계 ex) 조류, 동물\n  또는 클래스와 객체의 관계 (트위티, 종달새)\n  계층 관계 표현.\n 상위 계층의 속성을 상속    추이적 (transitive) 관계 만족 → inheritance\n %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%209.png \n  🔵 has-a   전체-부분 관계\n  part-of와 역관계\n has-a(X,Y) 이면 part-of(Y,X) 성립    추이적 관계 만족\n %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%2010.png \n  다항 관계 표현  %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%2011.png \n 다항 관계를 이항 관계로 전개 사물화: 다항 관계를 객체로 간주하여 표현 예) 길동이는 지난 가을부터 현재까지 고양이를 키우고 있다  의미망에서 추론  상속을 사용 질문에 대한 의미망과 지식을 나타내는 의미망을 비교   %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%2012.png \n 질문 예) 펭귄은 알을 낳는가?  can(펭귄, 알낳기)에 해당 is-a 관계의 간선을 따라 조류 노드로 이동 can(조류, 알낳기)가 있으므로 질문의 답은 참    시맨틱 네트워크 장점  지식을 시각적으로 표현하영 직관적 이해 용이 노드 추가, 변경으로 쉽게 지식의 추가 변경 가능 계층 관계를 정의하여 속성의 상속 관계 지정 가능 복잡한 지식을 구조화하여 표현 가능  시맨틱 네트워크 단점  지식의 양이 많아지면 관리 복잡 개념이나 관계를 정의하는 표준 지침이 없음  통일성 부족 공유나 재사용에 대한 고려 없음   논리적 결합 관계나 인과 관계를 기술하려고 하면 and, or, implies와 같 은 링크 도입 필요  일관성을 떨어뜨리고 추론과정을 복잡   기본적으로 정적인 지식의 표현  추론 과정에서 동적으로 지식의 내용을 바꾸려면 그래프를 동적으 로 바꿀 수 있도록 해야 함    3. 프레임  %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%2013.png \n 특정 객체, 개념에 대한 전형적인 지식을 슬롯의 집합으로 표현 객체지향의 느낌  스크립트  %E1%84%8C%E1%85%A5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%A1%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7/Untitled%2014.png \n 일반적으로 발생할 수 있는 전형적인 상황에 대한 절차적 지식을 표현 일련의 사건을 시간적 순서를 고려하여 기술  온톨로지  어떤 영역의 지식을 개념, 특성, 속성, 제약조건, 개체에 대한 정보가 기술 영역에 대한 공통된 어휘 사용 서로간 토의를 통해 합의를 이룬 것을 표현 예시  아마존 쇼핑 카탈로그 워드넷  영어 단어의 어휘목록과 어휘목록 사이의 다양한 의미관계 기록     시맨틱 웹  웹의 데이터를 소프트웨어 에이전트가 이해하여 지능적으로 활용 가능하도록 하는 것 XML 사용 의미 해석을 위해서는 RDF 사용    심볼 그라운딩 문제  컴퓨터가 기호로 표기된 실제 세계의 의미를 이해할 수 없음  딥러닝을 이용해 학습시키기    프레임 문제  컴퓨터가 하나의 프레임에 갇혀 하나의 목표만 보고 움직임 관계있는 지식을 사용하지 않음 ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/%EC%A0%84%EB%AC%B8%EA%B0%80-%EC%8B%9C%EC%8A%A4%ED%85%9C/","title":"전문가 시스템"},{"content":"탐색  %E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8/Untitled.png \n👾 1. Search Space \u0026amp; Search 탐색  문제의 해가 될 수 있는 것들의 집합을 공간으로 간주하고, 문제의 최적의 해를 찾기위해 공간을 체계적으로 찾아보는 것 탐색문제의 예  선교사-식인종 강건너기 문제 8퍼즐 문제 8퀸 문제 틱택토 루빅스큐브 순회판매자 문제    상태  특정 시점에 문제의 세계가 처해 있는 모습  세계  문제에 포함된 대상들과 이들의 상황을 포괄적으로 표현한 것  상태 공간  문제 해결 과정에서 초기 상태로부터 도달할 수 있는 모든 상태들의 집합 문제의 해가 될 가능성이 있는 모든 상태들의 집합  초기상태  문제가 주어진 시점의 시작 상태  목표상태  문제에서 원하는 최종 상태  상태 공간 그래프  상태공간에서 각 행동에 따른 상태의 변화를 나타낸 그래프  노드: 상태 링크: 행동   일반적인 문제에서는 상태공간이 매우 큼  미리 상태 공간 그래프를 만들기 어렵다 탐색과정애서 그래프 생성    🤖 2. Blind Search 맹목적 탐색  정해진 순서에 따라 상태공간 그래프를 점점 생성해 가면서 해를 탐색하는 방법  깊이 우선 탐색 (DFS)  초기 노트에서 시작하여 깊이 방향을 ㅗ탐색 목표 노드에 도달하면 종료 더 이상 진행할 수 없으면 백트래킹 방문한 노드는 재방문하지 않음  너비 우선 탐색 (BFS)  초기 노드에서 시작하여 모든 자식노드를 확장하여 생성 목표 노드가 없으면 형제 노드에서 다시 자식 노드 확장  8퍼즐 문제 DFS  루트 노드에섯 현재 노드까지의 경로 하나만 유지 가능 상태 : 9!/2 = 184,440   %E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8/Untitled%201.png \nBFS  전체 트리를 메모리에서 관리   %E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8/Untitled%202.png \n균일 비용 탐색  %E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8/Untitled%203.png \n 경로 비용 g(n)이 제일 낮은 노드 n을 확장 Sibiu → Bucharest 로 갈 때  Sibiu에서 볼 수 있는 도시는 Rim, Fag 따라서 80 비용인 Rim부터 감 → Pit 확장 이제 Pit과 Fag가 보인다. 97 비용인 Pit 가고 Buch 확장 이제 99인 Fag와 101이 Buch가 보인다. Fag가기 이제 비용 101인 Pit → Buch로 간다 80 + 97 + 101 = 278 (최적) 이제 비용 211인 Fag → Buch로 간다. 99 + 211 = 310    반복적 깊이심화 탐색  %E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8/Untitled%204.png \n 깊이 한계가 있는 깊이 우선 탐색을 반복적으로 사용 최상의 싶이 한계를 찾아내는 방법 목표를 발견할 때 까지 깊이 한계를 증가시켜 나감 깊이우선탐색 + 너비우선탐색 장점 모두 가짐  맹목적 탐색 방법의 비교  깊이 우선 탐색  메모라 공간 사용 효율적 최단 경로 해 탐색 보장 불가   너비 우선 탐색  최단 경로 해 탐색 보장 메모리 공간 사용 비효율   반복적 깊이심화 탐색  최단 경로 해 보장 메모리 공간 사용 효율적 반복적인 깊이 우선 탐색에 따른 비효율  실제 비용은 크게 늘지 않음 각 노드가 10개의 자식노드를 가질 때 너비 우선 탐색 대비 약 11% 정도 추가 노드 생성   탐색공간이 크기 해답의 깊이가 알려져 있지 않은 경우 선호    양방향 탐색  초기 노드와 목적 노드에서 동시에 너비 우선 탐색 진행 중간에 만나도록 하여 초기 노드에서 목표 노드로의 최단 경로를 찾음  1. Informed Search 정보이용 탐색  휴리스틱 탐색  시간이나 정보가 불충분하여 신속하게 어림짐작 하기 최적의 해를 구하는 것이 아니라 적절한 해를 빠르게 찾는 방법   언덕 오르기 방법, 최상 우선 탐색, 빔 탐색, A* 알고리즘 등 최단 경로 문제에서 목적지까지 남은 직선 거리  거리는 짧지만 비용이 많이 소요될 여지가 있음    휴리스틱 비용 추정의 예  %E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8/Untitled%205.png \n언덕 오르기 방법  %E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8/Untitled%206.png \n 현재 노드에서 휴리스틱에 의한 평가값이 가장 좋은 이웃 노드 하나를 확장해 나가는 탐색 방법  Greedy Search 기울기가 제일 가파른 곳부터 계속해서 탐욕적으로 나아가는 방법   그러나 최적의 값을 도출하지 못할 수 있음  에를들어 중간에서 왼쪽으로 가야 최고점에 도달하는데 오른쪽으로 가버리면 최고점에 도달하지 못하고, 중간봉우리에서 끝나게 됨    모의 담금법  %E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8/Untitled%207.png \n Greedy Search, Stochastic Search 담금질을 하듯 기울기를 조절하여 왔다갔다하면서 최적점을 찾음  최상 우선 탐색  %E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8/Untitled%208.png \n 확장중인 노드들 중에서 목표 노드까지 남은 거리가 가장 짧은 노드를 확장하여 검색 남은 거리를 정확히 알 수 없으므로 휴리스틱 사용  제자리가 아닌 타일의 개수    A* 알고리즘  %E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8/Untitled%209.png \n 추정한 전체 비용 f(n)을 최소로 하는 노드를 확장해 가는 방법 f(n) = g(n) + h(n)  노드 n을 경유하는 전체 비용 현재 노드 n까지 이미 투입된 비용 g(n)과 목표 노드까지의 남은 비용 h(n)의 합   h(n) : 남은 비용의 정확한 예측 불가  휴리스틱 함수로 예측    빔 탐색  휴리스틱에 의한 평가값이 우수한 일정 개수의 확장 가능한 노드만을 메모리에 관리하면서 최상 우선 탐색을 적용 ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","title":"탐색 알고리즘"},{"content":"튜링 테스트와 기초 1. 튜링테스트란 무엇인가?  기계에 지능이 있는지를 인간과의 대화 수준으로 판단하고자 하는 시험입니다. 1950년 엘런 튜링이 제안하여 튜링테스트라 명명되었습니다. 응답은 키보드로만 이루어지고, 둘 중 어느쪽이 컴퓨터인지 판별할 수 없다면 시험 통과  중국인방실험은 무엇인가?  튜링테스트에 의문을 제기하고자 설계된 시험 중국어를 모르는 사람이 들어있는 방에 중국어 질문들과 이에 따른 답변을 적은 종이를 준다면 중국어를 모르는 사람이더라도, 컴퓨터로 따지자면 사람의 말을 모르는 기계라도 소통이 가능하다는 맹점을 지적한 실험입니다.  2. 인공지능의 두번의 겨울의 이유와 극복 첫번째 겨울  인공지능의 첫번째 겨울은 70년대에 왔습니다. 이전의 많은 기대치에 비해 좋은 성적을 거두지 못한 AI연구는 동력과 투자를 잃고 내려앉게 됩니다. 신경망 이론 또한 세찬 비난을 받고 묻히게 됩니다.  첫번째 겨울 극복  그러나 80년대 \u0026lsquo;전문가 시스템\u0026rsquo;이 대두되며 일본을 필두로 다시 AI에 투자를 시작하게 됩니다. 신경망 이론 또한 역전파 등 새로운 방법을 통해 사장 직전이었던 신경망 이론을 다시금 발전시킵니다.  인공지능의 두번째 겨울  인공지능의 두번째 겨울은 80년대 말에 다시 옵니다. 데스크탑 컴퓨터들이 발전으로 인한 겨울  굳이 비싼 AI 전문가 시스템인 XCON을 살 이유가 없어짐 AI 하드웨어 시장이 갑자기 무너진 것입니다 또한 전문가 시스템의 경우 특별한 경우에만 유용한 반면 데스크탑은 범용성이 뛰어나 어느 작업이든 가능했습니다.    두번째 겨울 극복  2010년대 말, 알파고를 위시한 AI산업이 대두되며 AI 시장이 다시금 화려하게 부활하게 되었습니다.  3. 인공지능, 기계학습, 딥러닝 인공지능  인공지능, 즉 AI란 인간이 지닌 지적 능력을 인공적으로 구현한 것을 말합니다.  기계학습  기계 학습은 기본적인 규칙만 주어진 상태에서 입력받은 정보를 활용해 스스로 학습하는 것입니다.  딥러닝  딥러닝은 입력과 출력 사이에 있는 인공 뉴런들을 여러개 쌓고 연결한 인공신경망 기법을 다룬 연구입니다. 인공지능 구현에는 여러가지 방법이 있는데, 기계 학습이 그 중 하나이고, 기계 학습 구현에 딥러닝이 사용될 수 있다고 간단히 정의할 수 있습니다.  4. 외국어를 번역하는 것은 지금도 어려운 문제이다. 왜 번역문제가 어려운가? 딥러닝을 이용한 번역은 왜 성능이 좋은가?  자연 언어의 경우 컴퓨터에게 이를 이해시키는 것은 힘듭니다. 특히 뉘앙스의 차이나, 줄임말, 문학에서의 시적 허용 등.. 따라서 1대 1 대응으로 번역을 하게 되면 과도하게 딱딱하거나 엉뚱한 번역이 되어버립니다. 딥러닝을 사용하면 해당 용례에 따른 답변을 제시받아 스스로 학습 뉘앙스나 줄임말의 경우도 어느정도의 정확도로 컴퓨터에게도 추측이 가능하기에 기존의 1대1 대응 방식보다 성능이 좋게 됩니다. ","date":"2021-07-07T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/%ED%8A%9C%EB%A7%81-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%99%80-%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-%EA%B8%B0%EC%B4%88/","title":"튜링 테스트와 머신러닝 기초"},{"content":"Notes for dealing with problems while installing flutter\nFlutter.io Android License Status Unknown You need to use JDK8 for flutter, so if you have a JDK version upon 8, you need to install JDK8.\nFlutter App stuck at “Running Gradle task \u0026lsquo;assembleDebug\u0026rsquo;… ”  remove $HOME$/.gradle clean gradle ./gradlew clean Build gradle ./gradlew build  Installing flutter on MAC using asdf package manager brew install asdf --HEAD brew install android-sdk brew install android-studio brew install haxm brew cask install adoptopenjdk8 brew tap dart-lang/dart brew install dart asdf plugin add flutter asdf install flutter latest # add to ~/.zshrc file . $(brew --prefix asdf)/asdf.sh ","date":"2020-09-19T14:16:38+09:00","permalink":"https://yansigit.github.io/blog/little-tips-installing-flutter/","title":"Little Tips Installing Flutter"},{"content":"CPU\nCPU 1. 인터럽트 폴링 방식  image \n CPU가 직접 입출력장치에서 데이터를 가져오거나 내보냄 CPU가 입출력장치의 상태를 주기적으로 검사  일정한 조건을 만족할 때 데이터를 처리   CPU가 명령어 해석과 실행과 더불어 모든 입출력을 관리해야 하므로 작업 효율이 떨어짐  인터럽트 방식  image \n 입출력 관리자가 입출력을 대신 전담 CPU의 작업과 저장장치의 I/O를 독립적으로 운영  시스템의 효율을 높임 I/O를 수행하는 동안 CPU가 다른 작업을 할 수 있음    인터럽트  입출력 관리자가 CPU에 보내는 완료 신호  인터럽트 번호  많은 주변장치 중 어떤 것의 작업이 끝났는지를 CPU에 알려주기 위해 사용하는 번호 윈도우에서는 IRQ라고 부름  인터럽트 벡터  여러 개의 입출력 장치를 한꺼번에 처리하기 위해 여러개의 인터럽트를 하나의 배열로 만든 것  2. 인터럽트 방식의 동작 과정  image \n CPU가 입출력 관리자에게 데이터 입출력 명령을 보냄 입출력 관리자는 명령받은 데이터를 메모리에 가져다놓거나 메모리의 데이터를 저장장치로 옮김 데이터 전송이 완료되면 입출력 관리자는 완료 신호를 CPU에 보냄  3. 직접 메모리 접근  image \n 입출력 관리자가 CPU의 허락 없이 메모리에 접근할 수 있는 권한 메모리는 CPU의 작업 공간  데이터 전송을 지시받은 입출력 관리자는 직접 메모리 접근 권한이 있어야 작업 처리 가능    4. 메모리 매핑 입출력  image \n 메모리의 일정 공간을 입출력에 할당 보통 메모리(.)에 해당하는 어드레스 영역, I/O에 해당하는 어드레스 영역이 별개로 존재 그러므로 다른 명령어를 통해서 접근하게 됨 그런데 이 방식에서는 메모리의 일정 공간을 I/O를 위해 할당  5. 싸이클 훔치기  CPU와 직접 메모리 접근이 동시에 메모리에 접근하면 보통 CPU가 메모리 사용 권한을 양보 CPU의 작업 속도보다 입출력장치의 속도가 느리기 때문에 직접 메모리 접근에 양보하는 것  I/O 작업을 기다리고 있는 프로그램이 있을 수 있기 때문    6. 병렬 처리 개념  동시에 여러 개의 명령어를 처리해 작업의 능률을 올리는 방식  파이프라인 기법  image \n 하나의 코어에 여러 개의 스레드를 이용하는 방식  슈퍼스칼라 기법  image \n 듀얼코어 CPU를 이용해 2개의 작업을 동시에 처리  병렬 처리의 고려사항   상호 의존성이 없어야 병렬 처리가 가능\n 각 명령이 서로 독립적이고 앞의 결과가 뒤의 명령에 영향을 미치지 않아야 함    각 단계의 시간을 일정하게 맞춰야 병렬 처리가 원만하게 이루어짐\n image \n 각 단계의 시간이 들쭉날쭉하면 다음 작업이 밀리게 되어 병렬 처리의 효과가 떨어질 수 있다.    전체 작업 시간을 몇 개로 나눌지 잘 따져봐야 한다\n 병렬 처리의 깊이 N (위 이미지의 높이) 이론적으로는 N이 커질수록 동시에 작업할 수 있는 갯수가 증가  그러나 작업을 너무 많이 나누면 오히려 작업을 이동하고 새로운 작업을 불러오는 딜레이가 많이 걸려 성능 하락 따라서 적절하게 설정하는 것이 중요      7. CPU에서 명령어가 실행되는 과정  명령어 패치 (.): 다음에 실행할 명령어를 메모리에서 불러와 레지스터에 저장 명령어 해석 (.): 명령어 해석 실행 (.): 해석한 결과를 토대로 명령어 실행 쓰기 (.): 실행된 결과를 메모리에 저장  파이프라인 기법  image \n슈퍼스칼라 기법  image \n 파이프라인을 처리할 수 있는 코어를 여러개 구성 복수의 명령어를 동시에 실행  슈퍼파이프라인 기법  image \n 파이프라인의 각 단계를 또 세분화 한 클록 내에 여러 명령어를 처리 다음 명령어가 빠른 시간 내에 처리될 수 있어 처리속도 향상  슈퍼파이프라인 슈퍼스칼라 기법  image \n 슈퍼파이프라인 기법을 여러 코어에서 실행  8. 무어의 법칙, 암달의 법칙 무어의 법칙  CPU의 속도가 24개월마다 2배 빨라진다는 내용 초기의 CPU에만 적용되었다  암달의 법칙  컴퓨터 시스템의 일부를 개선할 때 예를들어 CPU의 속도를 2배 개선하더라도 전체 시스템의 성능이 2배 빨라지지 않는다는 것 ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-cpu/","title":"운영체제 - CPU"},{"content":"CPU 스케줄링\nCPU 스케줄링 1. CPU 스케줄링  운영체제에서 식당 관리자의 역할을 담당\n  여러 프로세스들의 상황을 고려, CPU 및 자원 할당 결정\n  image \n image \n고수준 스케줄링  시스템 내의 전체 작업 (프로세스) 수를 조절하는 것  예를 들어 최대 200개로 제한   어떤 작업을 시스템이 받아들일지 또는 거부할지를 결정 동시에 실행 가능한 프로세스의 총 개수가 정해짐 장기 스케줄링, 작업 스케줄링, 승인 스케줄링이라고도 함  저수준 스케줄링  어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정 아주 짧은 시간에 일어나기 때문에 단기 스케줄링이라고도 함  중간수준 스케줄링  중지 \u0026amp; 활성화  일부 프로세스를 일시정지 상태로 옮김으로서 나머지 프로세스가 원만하게 작동하도록 함   저수준 스케줄링이 원만하게 이루어지도록 완충  2. CPU 스케줄링의 목적  image \n공평성  모든 프로세스가 자원을 공평하게 배정받아야 한다  효율성  시스템 자원이 노는 시간 없이 사용되도록 스케줄링 노는 자원을 사용하려는 프로세스에는 우선권 부여  안정성  우선순위 사용, 중요 프로세스가 먼저 사용하도록 배정 시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원 보호  확장성  프로세스가 증가해도 시스템이 안정적으로 작동하도록 함 시스템 자원이 늘어나면 혜택이 반영되게 함  반응 시간 보장  적절한 시간 안에 프로세스의 요구에 반응  무한 연기 방지  특정 프로세스의 작업이 무기한 연기되어서는 안 됨  3. 선점형 \u0026amp; 비선점형 스케줄링  image \n선점형 스케줄링  운영체제가 필요하다고 판단되면 실행중인 프로세스의 작업을 중단하고 새로운 작업을 시작 하나의 프로세스가 CPU를 독점할 수 없음  대화형 시스템이나 시분할 시스템에 적합 대부분의 현대형 시스템에서 사용중   대부분의 저수준 스케줄러는 선점형 스케줄링 방식을 사용  비선점형 스케줄링  해당 프로세스가 CPU를 사용하면 종료되거나 자발적으로 대기 상태에 들어가기 전까지 계속해서 실행 스케줄러의 작업량이 작고 문맥 교환에 의한 낭비도 적음 CPU 사용 기간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 여러 프로세스가 기다리게 됨  전체 시스템의 처리율 떨어짐   과거의 일괄 작업 시스템에서 사용하던 방식  4. 프로세스 우선순위  커널 프로세스의 우선순위가 일반 프로세스보다 높음 우선순위가 높은 프로세스가 CPU를 먼저, 오래 차지 시스템에 따라 높은 숫자가 높은 우선순위를 나타내기도, 낮은 숫자가 높은 우선순위를 나타내기도 함  5. CPU 집중 프로세스  CPU 집중 프로세스  수학 연산과 같이 CPU버스트가 많은 프로세스 CPU를 많이 사용하는 프로세스   입출력 집중 프로세스  파일 저장 복사 등 입출력 버스트가 많은 프로세스    우선 배정  (저수준) 스케줄링을 할 때 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 시스템 효율 향상\n  image \n6. 전면 프로세스 \u0026amp; 후면 프로세스 전면 프로세스  GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스 (.에서도) 현재 입력 \u0026amp; 출력을 사용하는 프로세스 사용자와 상호작용이 가능하여 상호작용 프로세스라고도 함  후면 프로세스  사용자와 상호작용이 없는 프로세스 사용자의 입력 없이 작동하기 때문에 일괄 작업 프로세스라고도 함 전면 프로세스의 우선순위가 후면 프로세스보다 높음  CPU 스케줄링 시 고려 사항  image \n1. 큐 준비 상태의 다중 큐  image \n 프로세스가 준비 상태에 들어올 때  자신의 우선순위에 해당하는 큐를 찾음 해당 큐의 마지막에 삽입됨   CPU 스케줄러는 우선순위가 가장 높은 큐의 맨 앞에 있는 프로세스 6 (. 6)에 CPU 할당  우선순위 배정 방식  고정 우선순위 방식  운영체제가 우선순위를 부여하면 프로세스가 끝날 때 까지 바뀌지 않음 구현하기 쉽다. 우선순위가 불변이기에 그러나 시스템의 상황은 변하기 마련이기에 작업 효율이 떨어질 수 있다   변동 우선순위 방식  작업 중간에 우선순위가 변경 구현이 어려우나 시스템의 효율성을 높일 수 있다.    대기 상태의 다중 큐  여기서는 같은 입출력을 요구한 프로세스끼리 모아놓음   image \n 장치에서 인터럽트가 발생되면 해당 인터럽트를 기다리는 프로세르를 깨우고 준비상태로 들어감  다중 큐 비교  준비 큐  한 번에 하나의 프로세스를 꺼내어 CPU를 할당   대기 큐  여러 개의 프로세스 제어 블록을 동시에 꺼내어 준비 상태로 옮김 대기 큐에서 동시에 끝나는 인터럽트를 처리하기 위해 인터럽트 벡터라는 자료 구조 사용    다중 큐 구조  image \n","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/","title":"운영체제 - CPU 스케줄링"},{"content":"CPU 스케줄링 알고리즘\nCPU 스케줄링 알고리즘 1. 스케줄링 알고리즘  image \n평가 기준  CPU 사용률  전체 시스템의 동작 시간 중 실제 CPU가 사용된 시간을 측정 가상 이상적인 수치는 100%  그러나 여러 가지 이유로 90%도 미치지 못함     처리량 (.)  단위 시간 당 작업을 마친 프로세스의 수 이 수치가 클수록 좋은 알고리즘     image \n  대기시간\n 프로세스가 생성된 후 디스패치되어 실행되기 전 까지 대기하는 시간    응답시간\n 첫 작업을 시작한 후 첫 번째 출력이 나오기까지 시간    실행 시간\n 프로세스 작업이 시작된 후 종료되기까지의 시간    반환 시간\n 대기 시간을 포함해 실행이 종료될 때 까지의 시간    평균 대기 시간\n 모든 프로세스의 대기 시간을 합한 뒤 프로세스의 수로 나눈 값   image \n  FCFS 스케줄링  image \n First Come First Served (선착순) 한번 실행되면 그 프로세스가 끝나야 다음 프로세스 실행 가능 큐가 하나  모든 프로세스는 우선순위 동일    FCFS 스케줄링 성능  image \n  평균 대기 시간\n image \n$$(.+27+42)÷3=23$$\n  FCFS 스케줄링 평가  처리 기간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 계속 기다려야 실행 가능 현재 작업중인 프로세스가 입출력 작업을 요구할 경우 CPU가 작업하지 않고 쉬어버림  작업 효율이 떨어짐    SJF 스케줄링  image \n 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU 할당 최단 작업 우선 스케줄링이라고도 함  SJF 스케줄링 성능  image \n  평균 대기 시간\n image \n$$(.+24+36)÷3=20$$\n  SJF 스케줄링 평가  운영체제가 프로세스의 종료 시간 예측 어려움 작업시간이 길다는 이유만으로 계속 밀림  아사 현상 공평성이 떨어짐 에이징(.)을 통해 완화 가능  프로세스가 양보할 수 있는 상한선을 정함 자신의 순서를 양보할 때 마다 나이를 한살씩 추가 최대 몇살까지만 양보하도록 규정      HRN 스케줄링  SJF의 아사현상을 해결하기 위해 만들어진 비선점형 알고리즘 최소 응답률 우선 스케줄링이라고도 함 서비스를 받기 위해 기다린 시간 + CPU 사용 시간을 고려해 스케줄링 우선순위: 대기시간/CPU 사용 시간 + 1 (우선순위가 클수록 우선순위가 높다)  HRN 스케줄링의 성능  image \n 반환시간  P1: 0~30 = 30 P2: 3~39 = 36 P3: 6~57 = 51   평가  아사 현상을 완화 대기 시간이 긴 프로세스의 우선순위를 높여 CPU 할당 확률을 높임 우선순위 할당에 CPU 사용 시간이 개입하므로 완전히 공평하지는 않음    라운드 로빈 스케줄링  한 프로세스가 타임 슬라이스 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식 선점형 알고리즘  중간에 종료되거나 자발적으로 종료되지 않아도 운영체제에 의해 CPU 사용권을 빼앗길 수 있음 선점형 알고리즘 중 가장 단순하고 대표적인 방식   프로세스들이 작업을 완료할 때 까지 계속 순환   image \n 반환 시간  P1: 0~39 = 39 P2: 3~47 = 44 P3: 6~29 = 23    라운드 로빈 고려사항  타임 슬라이스의 크기와 문맥 교환  타임 슬라이스의 크기가 너무 작으면 문맥 교환에 따른 추가 시간이 너무 길어짐 타임 슬라이스가 큰 경우 하나의 작업이 끝난 뒤 다음 작업이 시작되는 것 처럼 보여 FCFS 스케줄링과 다를게 없음   따라서 타임 슬라이스는 최대한 작게 설정하되 문맥 교환에 걸리는 시간을 고려해 적당하게 설정  SRT 스케줄링과 성능  라운드 로빈 스케줄링 + 남아있는 작업 시간이 가장 적은 프로세스를 선택   image \nSRT 스케줄링의 평가  실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산해야함  운영체제의 부담이 조금 커질 수 있음   운영체제가 프로세스의 종료 시간을 예측하기 어려움 아사 현상이 일어남  우선순위 스케줄링  프로세스의 중요도에 따른 우선순위를 반영한 스케줄링 알고리즘   image \n우선순위 적용  우선순위는 비선점형 방식과 선점형 방식 모두 적용 가능  SJF 스케줄링 : 작업 시간이 짧은 프로세스 HRN 스케줄링 : 작업 시간이 짧거나 대기 시간이 긴 프로세스 SRT 스케줄링 : 남은 시간이 짧은 프로세스   고정 우선순위 알고리즘  한번 우선순위를 부여받으면 종료될때까지 우선순위 고정 단순하게 구현 가능 변동적인 시스템의 상황 반영 불가능  효율 떨어짐     변동 우선순위 알고리즘  일정 시간마다 우선순위 변동  우선순위 계산, 반영 복잡   효율적인 운영 가능    우선순위 스케줄링 평가  준비 큐에 있는 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU 할당  공평성 위배 프로세스의 우선순위를 매번 재계산해야 하므로 시스템의 효율을 떨어뜨림   아사 현상을 일으킴 커널 프로세스가 우선  다단계 큐 스케줄링  image \n 우선순위에 따라 큐를 여러개 사용 우선순위는 고정형 우선순위 상단의 큐에 있는 작업이 모두 끝나야 하단에 있는 큐 작업이 시작  다단계 피드백 큐 스케줄링  image \n 프로세스가 CPU를 한번씩 할당받아 실행될 때 마다 우선순위가 낮아짐  다단계 큐에서 우선순위가 낮은 프로세스의 실행이 연기되는 문제 완화   우선순위가 낮아진다고 해도 커널 프로세스가 일반 프로세스의 큐에 삽입되지는 않음 우선순위에 따라 타임 슬라이스의 크기가 다름  아래 우선순위의 타임 슬라이스가 더 큼 한번 CPU를 잡을 때 많이 작업하라고..   마지막 큐에 있는 프로세스는 무한대의 타임 슬라이스를 얻음 마지막 큐는 FCFS 스케줄링 방식을 사용 ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","title":"운영체제 - CPU 스케줄링 알고리즘"},{"content":"RAID\nRAID RAID RAID (. Array of Independent Disks)  디스크 장애 발생 시 이를 복구하는 시스템 스트라이핑을 통한 입출력 속도 증가 하나의 원본 디스크와 같은 크기의 디스크에 같은 내용을 동시에 저장  하나의 디스크가 고장나면 다른 디스크를 사용해 복구   RAID 0,1,10 외에 RAID 2,3,4,5,6,50,60 등이 있음  스트라이핑  저장소를 스트립이라는 고정 크기 블록으로 나누어 데이터 저장  연속된 파일 스트립은 대체로 구별된 디스크에 배치 파일에 대한 요청이 한 번에 여러 디스크를 사용해 이루어짐 디스크 요청의 평균 크기를 고려해 결정   스트라이프 (.) : 디스크 배열의 각 디스크에서 동일한 위치에 있는 스트랩의 집합   image \n RAID 시 예를 들어 4개의 디스크를 사용해 400Bytes를 저장한다면  각 디스크에 100Bytes씩 한꺼번에 저장 4배 속도 가능   스트립의 크기는 개발자, 시스템에 따라 가변적  RAID 0  단순 스트라이핑 같은 규격의 디스크를 병렬로 연결  여러 데이터를 여러 디스크에 동시에 저장하거나 가져옴  이론적으로는 입출력 속도가 디스크의 갯수에 따라 증가   복구 기능이 없음  장애가 발생하면 데이터를 잃음     레이드를 사용하면 디스크 하나만 고장나도 전체 데이터 손실이 일어날 수 있음  따라서 복구 기능없는 RAID 0은 잘 사용하지 않음    RAID 1  image \n 하나의 데이터를 2개의 디스크에 나누어 저장  장애 시 백업 디스크로 활용   데이터가 똑같이 여러 디스크에 복사됨 같은 크기의 디스크를 최소 2개 이상 필요  짝수개의 디스크로 구성   저장하는 데이터와 같은 크기의 디스크가 하나 더 필요  비용이 증가 다만 가장 안전함    RAID 2 (비트 수준 해밍 ECC 패러티)  image \n 오류 교정 코드 (.)를 따로 관리  ECC를 별도의 디스크에 따로 보관 1101|101 등 오류가 발생하면 이 코드를 이용해 디스크 복구   ECC 저장을 위한 추가 디스크를 필요로 함  RAID 1 보다는 작은 저장공간을 요구 오류 교정 코드를 계산하는 데 많은 시간을 소비해 잘 사용하지는 않음   각 디스크에 비트 단위로 저장  보통 4비트를 교정하기 위한 코드는 3비트가 필요    RAID 3  image \n 오류 검출 패러리 이용 방식  오류 검출 패러티는 보통 1비트만을 사용  1101|1 등 짝수, 홀수 오류 검출 패러티 등\u0026hellip; RAID 2보다 작은 저장공간 요구     비트 혹은 바이트 수준에서 스프라이트 구성  데이터가 모든 디스크에 나누어 저장   검출만 하면 어떻게 오류를 복구 하냐?  디스크 컨트롤러를 통해 어느 디스크가 고장났는지 알 수 있음 따라서 오류 검출만 하면 해당 디스크에 저장된 비트를 반전시켜 오류 복구 가능   RAID 2 보다는 적지만 코드 계산을 위한 오버헤드가 있음  RAID 4  image \n RAID 3과 유사하나 데이터를 블록 단위로 스트라이핑  RAID 3은 무조건 모든 디스크가 바빠야 하는데 그걸 해소하기 위함 데이터가 저장되는 디스크와 패맅 비트가 저장되는 디스크만 동작    RAID 5  image \n 블록수준 분산 패리티 패리티 비트를 하나의 디스크가 아니라 여러 디스크에 분산하여 보관함으로써 패리티 비트 디스크의 병목 현상을 완화  즉 RAID 4의 경우 데이터를 쓰면 무조건 Parity 디스크도 사용해야하기 때문에 해당 디스크 하나에 병목현상이 몰림   RAID 5의 경우 패리티 비트를 해당 데이터가 없는 디스크에 보관 한 디스크에 장애가 발생하면 다른 디스크에 있는 패리티 비트를 이용하여 데이터를 복구할 수 있음  RAID 6  image \n RAID 5와 같은 방식이지만 패리티 비트가 2개여서 디스크 2개의 장애를 복구할 수 있음 패리티 비트를 2개씩 운영하기 때문에 RAID 5보다 계산량이 많고 4개의 디스크당 2개의 추가 디스크가 필요하다는 단점이 있음  RAID 10  image \n 미러링 기능을 가진 RAID 1과 빠른 데이터 전송이 가능한 RAID 0을 결합한 형태 디스크를 RAID 0으로 먼저 묶으면 RAID 0+1이 되고, RAID 1로 먼저 묶으면 RAID 10이 됨 RAID 0+1의 경우 장애가 발생했을 때 복구하기 위해 모든 디스크를 중단해야 하지만 RAID 10은 일부 디스크만 중단하여 복구할 수 있음  RAID 50과 RAID 60  RAID 50 : RAID 5로 묶은 두 쌍을 다시 RAID 0으로 묶어 사용 RAID 60 : RAID 6으로 묶은 두 쌍을 다시 RAID 0으로 묶어 사용   image \n","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-raid/","title":"운영체제 - RAID"},{"content":"가상 메모리\n가상 메모리 1. 가상 메모리 시스템 필요한 이유  프로그래머가 시스템의 메모리 크기를 일일히 고려해 프로그래밍하기 쉽지 않음 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공해줌 가상 메모리를 사용하면 프로세스는 운영체제가 어디에 있는지 물리 메모리의 크기가 어느 정도인지 신경쓰지 않고 메모리를 마음대로 사용 가능  가상 메모리의 구성  프로세스가 바라보는 메모리 영역  실제 물리 메모리가 어느 크기이던 간에 공간 할당 가능 게다가 그 공간은 연속적임   메모리 관리자가 바라보는 메모리 영역  실제 물리 메모리는 가상 메모리보다 작을 수 있음 물리 메모리의 부족한 부분은 스왑 영역으로 보충 가상 메모리에서 메모리 관리자가 사용할 수 있는 메모리의 전체 크기는 물리 메모리 + 스왑 영역   가상 메모리 주소와 물리 메모리 주소는 다르다  따라서 동적 주소 변환을 통해 가상 주소 → 실제 메모리 물리 주소로 변환 필요 동적 주소 변환을 거치면 프로세스가 아무 제약 없이 사용자 데이터를 물리 메모리에 배치할 수 있음    가상 메모리 분할 방식  image \n 가변 분할 방식을 이용한 세그먼테이션  외부 단편화 등의 문제가 있음   고정 분할 방식을 이용한 페이징 기법  기본적으로 페이징 기법을 사용하나 페이지 테이블 관리가 필요   가상 메모리 시스템에서는 두 기법의 단점을 보완한 세그먼테이션-페이징 혼용 기법 주로 사용  메모리 매핑 테이블  image \n 가상 메모리 시스템에서 메모리 관리자는 가상 주소와 물리 주소를 1대1 매핑 테이블로 관리  페이징 기법  image \n 고정 분할 방식을 이용한 가상 메모리 관리 기법 물리 주소 공간을 같은 크기로 나누어 사용 가상 주소는 항상 0번지부터 시작 페이지와 프레임  가상 주소와 물리 주소는 같은 크기로 나눠짐 가상주소의 각 분할된 영역을 페이지라고 부름 물리주소의 각 분할된 영역을 프레임이라고 부름 페이지와 프레임의 크기는 같기 때문에 페이지는 어떤 프레임에도 배치 가능 어떤 페이지가 어떤 프레임에 있는지에 대한 매핑 정보는 페이지 테이블에 담겨 있음 페이지 테이블에 invalid는 해당 페이지가 스왑 영역에 있다는 의미    페이징 기법의 주소 변환  image \n 가상 주소 18번지가 어느 페이지에 있는지 찾음  18번지는 페이지 1의 8번째 위치 (. = \u0026lt;1, 8\u0026gt;)   페이지 테이블의 페이지 1로 가서 해당 페이지가 프레임3에 있다는 것을 확인 프로세스가 저장하려는 값을 프레임 3의 8번 위치에 저장  즉, VA = \u0026lt;1,8\u0026gt; → PA = \u0026lt;3, 8\u0026gt;    VA = \u0026lt;P, D\u0026gt; 구하는 공식  image \n 한 페이지의 크기가 10B인 가상 메모리 시스템에서 가상 주소 32번지  P=3 (/posts/가상-메모리/10의 몫) D=2 (/posts/가상-메모리/10의 나머지)   한 페이지의 크기가 512B인 시스템에서 가상 주소 2049번지  P=4 (/posts/가상-메모리/512의 몫) D=1 (/posts/가상-메모리/512의 나머지) 다른방법 (실제 사용하는 방법)  가상주소 2049 라고 가정했을 때, 2비트로 표현하면 1000 0000 0001 한 페이지의 크기가 512라면, 2^9이므로 9bit. 즉, Offset의 비트 수는 9bit. Offset의 비트수는 9bit로 되어있다. 즉 0 0000 0001 이 D가 된다 P는 자동적으로 100이 된다 다시 10진수로 표현하면 P = 100 → 4, D = 1 → 1      16비트 CPU에서 한 페이지의 크기가 2^10(.)B일 때  image \n 주소공간은 16비트로 표시 위와같이 한 페이지의 크기가 2^10이므로, 10bit가 Offset으로 쓰이게 됨 한 프로세스가 사용할 수 있는 가상 메모리의 크기는 2^16(.,536)B 사용자는 0~65,535번지까지 가상 주소 공간 사용 가능 가상 주소로 사용할 수 있는 16bit 중 6bit는 페이지 번호로, 10bit는 Offset   image \n 전체 페이지의 수는 2^6, 즉 64개이고 페이지 0번~63번까지 존재 물리 주소도 가상 주소와 같이 2^10B로 나뉨, 프레임은 0부터 31까지만 있다고 가정 페이지 테이블은 엔트리가 0~63으로 총 64개. 보통 가상 주소의 페이지 수를 따름.  프로세스가 980번지에 저장된 데이터를 요청할 때 나누기 이용  가상 주소 980번지의 페이지 P, 거리 D를 구함  P=0 (/posts/가상-메모리/1024의 몫) D=980 (/posts/가상-메모리/1024의 나머지) VA=\u0026lt;0, 980\u0026gt;   페이지 테이블로 가서 페이지 0이 프레임 2에 저장되어 있다는 것을 확인 물리 메모리의 프레임 2 시작 지점으로부터 980번지 떨어진 곳에 접근하여 데이터를 가져옴  2048+980 = 3028번지    2진수 이용  이진수를 사용하는 것이 더 직관적 가상주소 980번지: 0000 0011 1101 0100  \u0026lt;P,D\u0026gt; = \u0026lt;000000, 1111010100\u0026gt;   2번 프레임: 00010  \u0026lt;F,D\u0026gt; = \u0026lt;00010, 1111010100\u0026gt; 3028번지    다수의 프로세스가 있는 페이징 시스템  image \n 프로세스마다 페이지 테이블이 존재  프로세스의 수가 많아지면 페이지 테이블의 크기가 커짐 이에 따라 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어듬   페이지 테이블 크기를 적절히 유지하는 것이 핵심  물리 메모리 내 페이지 테이블의 구조  image \n 각 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터에 보관 물리 메모리의 크기가 작을 때는 페이지 테이블의 일부도 스왑 영역으로 옮겨짐  페이지 테이블 매핑 방식 직접 매핑  image \n 페이지 테이블 전체가 물리 메모리에 올라옴 별다른 부가작업 없이 주소 변환이 가능 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터가 가지고 있음 VA=\u0026lt;P,D\u0026gt; → PA=\u0026lt;F, D\u0026gt;  연관 매핑  image \n 테이블의 일부는 고속 TLB에 저장, 나머지는 물리메모리에 위치  TLB : 변환 참조 버퍼 맵에 유지하는 페이지 테이블 엔트리들은 가장 최근 참조한 페이지들 쓴거는 다시 쓸 가능성이 높다는 추측에 근거 (지역성)   메모리에 접근하기 위해 먼저 TLB에 접근  TLB 히트 : 원하는 페이지 번호가 있음. 곧바로 물리 주소로 변환 TLB 미스 : 원하는 페이지 번호가 없음. 물리 메모리에 저장된 직접매핑테이블을 이용해 프레임 번호로 변환   TLB 미스가 빈번하게 일어날 경우 시스템의 성능 떨어짐  다수준 페이지 테이블 (계층적 페이징)  image \n table 단편화 : 소수의 페이지 테이블 엔트리만 사용 디렉토리 매핑이라고도 부름 페이지 테이블을 같은 크기의 여러 묶음으로 나누고 각 묶음의 시작 주소를 가진 디렉터리 테이블을 하나 더 생성해 관리 전체 페이지 테이블은 스왑 영역에 있으며 일부 테이블만 묶음 단위로 메모리로 옮김 해당 묶음이 현재 메모리에 있는지 스왑 영역에 있는지를 표시하는 디렉터리 메모리를 생성 디렉터리 테이블을 살펴보면 원하는 테이블 묶음이 어디있는지 파악 가능  전체를 찾아보지 않아도 해당 페이지가 프레임에 있는지 알 수 있다   계층을 만들어 구현  각 수준은 하위 수준 테이블을 가리키는 포인터를 저장 최하위 수준은 페이지-페이지 프레임 매핑을 담고 있는 테이블로 구성   페이지 테이블이 일정 크기의 묶음으로 나뉨  따라서 VA=\u0026lt;P, D\u0026gt;가 아닌 Va=\u0026lt;P1, P2, D\u0026gt;  P1 : 디렉터리 테이블에서 위치 정보 P2 : 묶음 내에서의 위치 정보   페이지 테이블을 10개씩 한 묶음으로 나눈 경우  0~9번 테이블 : 0번 디렉토리 10~19번 테이블: 1번 디렉토리 가상 주소 32번지 : \u0026lt;0, 3, 2\u0026gt; 가상 주소 127번지 : \u0026lt;1, 2, 7\u0026gt;     디렉터리 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터가 가지고 있음 프로세스가 특정 주소를 요구하면 VA=\u0026lt;P1, P2, D\u0026gt;로 변환  P1을 이용해 디렉터리 테이블에서 주소를 찾음   원하는 테이블이 물리 메모리에 있으면 묶음 테이블의 시작 주소가 명시되어 있음  역매핑  image \n image \n 페이지의 번호를 기준으로 하던 다른 방식과 달리, 물리 메모리의 프레임 번호를 기준으로 테이블을 구성 테이블은 \u0026lt;프레임 번호, 프로세스 아이디, 페이지 번호\u0026gt;로 구성 프로세스 수와 상관없이 테이블이 하나만 존재하므로 테이블의 크기가 매우 작음 프로세스가 가상 메모리에 접근할 때 프로세스 아이디와 페이지 번호를 모두 찾아야 하는 단점이 있음  세그먼테이션 기법 세그먼테이션 테이블  image \n 세그먼트의 크기를 나타내는 limit와 물리 메모리상의 시작 주소를 나타내는 address가 있음 각 세그먼트가 자신에게 주어진 메모리 영역을 넘어가면 안됨  세그먼트의 크기 정보에는 크기를 뜻하는 size 대신 limit를 사용   세그먼테이션 기법에서도 스왑 영역 사용  프로세스 A의 32번지에 접근할 때 주소 변환 과정  image \n 가상 주소 VA = \u0026lt;0, 32\u0026gt; 세그먼테이션 테이블에서 세그먼트 0의 시작 주소를 알아냄 (.) 거기에 거리 32를 더하여 물리 주소 (.) 번지를 구함  이 때 메모리 관리자는 거리가 세그먼트의 크기보다 큰지 점검 만약 크다면 메모리 오류를 출력하고 해당 프로세스 강제종료   물리 주소 (.) 번지에 접근해 원하는 데이터를 읽거나 씀  메모리 접근 권한  image \n 메모리의 특정 번지에 저장된 데이터를 사용할 수 있는 권한 읽기, 쓰기, 실행, 추가 권한이 있음  프로세스의 영역별 메모리 접근 권한  image \n 코드 영역: 자기 자신을 수정하는 프로그램은 없기 때문에 읽기, 실행 데이터 영역: 데이트는 읽기전용 데이터, 읽기/쓰기 모두 가능한 데이터로 나뉜다  변수 / 상수    페이징 기법에서 메모리 접근 권한까지 고려한 페이지 테이블 예  페이지마다 접근 권한이 다르기 떄문에 페이지 테이블의 모든 행에는 메모리 접근과 관련된 권한 비트를 추가 메모리 관리자는 주소 변환이 이루어질 때 마다 페이지 테이블의 권한 비트를 이용해 유용한 접근인지 체크 페이지 테이블에 권한 비트가 추가되면 테이블의 크기가 커지게 됨   image \n세그먼테이션-페이징 혼용 기법  image \n 세그먼트 테이블을 두어 세그먼트 별로 권한 비트를 나눠서 설정해줌  테이블 크기를 줄여주는 효과    세그먼테이션-페이징 혼용 기법에서 동적 주소 변환 과정  image \n 사용자가 가상 주소 VA = \u0026lt;S, P, D\u0026gt; 요청  \u0026lt;세그먼트 번호, 페이지 번호, Distance\u0026gt;   세그먼테이션의 테이블의 해당 세그먼트 번호로 가서 자신의 영역을 벗어나는지, 권한이 없는 페이지에 접근하는지 등 확인 페이지 테이블에서 해당 페이지가 어느 프레임에 저장되었는지 확인 (없다면 스왑 영역에서 가져옴) 물리 메모리에 있는 프레임에서 D만큼 떨어진 곳에 접근해 데이터에 접근 ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC/","title":"운영체제 - 가상 메모리"},{"content":"가상메모리 관리\n가상메모리 관리 프로세스의 일부만 메모리로 가져오는 이유  메모리를 효율적으로 관리하기 위해서  메모리가 꽉 차면 관리가 어려움   응답 속도를 향상시키기 위해서  용량이 큰 프로세스를 전부 메모리로 가져오려면 응답이 늦어질 수 있음   포토샵을 쓴다면 메인 프로그램만 올리고 필터는 사용자가 필요할 때 마다 메모리로 가져오는 것이 효율적이라는 것  요구 페이징  사용자가 요구할 때 해당 페이지를 메모리로 가져오는 것 페이지를 미리 가져오는 방식은 가져온 페이지를 쓰지 않을 경우 메모리를 낭비하게 됨 따라서 요구 페이징이 메모리의 절약, 효율적 관리, 응답 속도 향상 등의 장점을 가짐  요구 페이징과 스왑 영역  페이지가 스왑 영역에 있는 경우  요구 페이징으로 인해 처음부터 물리 메모리에 올라가지 못함 메모리가 꽉 차서 스왑 영역으로 옮긴 경우    페이지 테이블 엔트리 (.의 구성)  image \n 페이지 번호 프레임 번호 플래그 비트  접근 비트 : 페이지가 메모리에 올라온 후 사용한 적이 있는가 변경 비트 : 페이지가 메모리에 올라온 후 데이터의 변경이 있었는가 유효 비트 : 페이지가 실제 메모리에 있는가 읽기, 쓰기, 실행 권한 비트    유효 비트  image \n 페이지가 물리 메모리에 있는지, 스왑 영역에 있는지 표시  유효 비트가 0일 때 : 페이지가 메모리에 있다 유효 비트가 1일 때 : 페이지가 스왑 영역에 있다    페이지 부재  프로세스가 페이지를 요청했을 때, 메모리에 그 페이지가 없는 상황 페이지 부재가 발생하면 스왑 영역에서 해당 페이지를 물리 메모리로 옮겨야 함   image \n페이지 부재 처리 과정  image \n 프로세스가 페이지 3을 요청하면 페이지 테이블의 유효 비트가 1이기 때문에 페이지 부재 발생 메모리 관리자는 스왑 영역의 0번에 있는 페이지를 메모리의 비어 있는 프레임인 5로 가져옴 (스왑 인) 프레임 5로 접근하여 해당 데이터를 프로세스에 넘김  페이지 교체  페이지 부재가 발생하면 스왑 영역의 페이지를 메모리로 올리고 페이지 테이블을 갱신 빈 프레임이 없을때는 메모리에 있는 프레임 중 하나를 스왑으로 보내야함  페이지 교체 알고리즘  어떤 페이지를 스왑 영역으로 보낼 것인지 결정  대상 페이지  페이지 교체 알고리즘에 의해 스왑 영역으로 보낼 페이지  메모리가 꽉 찬 상태에서 페이지 부재가 발생했을 때 조치  image \n 페이지의 유효 비트가 1이라 페이지 부재 발생 메모리가 꽉 차서 페이지 하나를 스왑으로 보내야 함  대상 페이지의 유효비트가 0에서 1로, 주소 필드 값이 메모리 주소에서 스왑 영역의 주소로 바뀜   스왑 영역에 있던 페이지는 메모리(프레임)으로 올라감 (스왑 인)  해당 페이지의 유효비트는 1에서 0으로, 주소 필드 값이 스왑 주소에서 프레임 번호로 바뀜    세그먼테이션 오류와 페이지 부재  세그먼테이션 오류  사용자의 프로세스가 주어진 메모리 공간을 벗어나거나, 접근 권한이 없는 곳에 접근할 때 발생 해당 프로세스를 강제 종료하여 해결   페이지 부재  해당 페이지가 물리 메모리에 없을 때 발생하는 오류 메모리 관리자는 스왑 영역에서 해당 페이지를 불러 물리 메모리로 옮긴 후 작업을 진행    지역성  기억장치에 접근하는 패턴이 특정 영역에 집중되는 성질  즉 계속 특정 부분 데이터만 계속 사용된다는 거   페이지 교체 알고리즘이 \u0026lsquo;대상 페이지\u0026rsquo;를 지정할 때 지역성을 바탕으로 함  지역성의 종류  image \n 공간의 지역성  현재 위치에서 가까운 데이터에 접근할 확률이 먼 거리에 있는 데이터에 접근할 확률보다 높음   시간의 지역성  현재를 기준으로 가장 가까운 시간에 접근한 데이터가 오래된 데이터보다 사용될 확률이 높음   순차적 지역성  여러 작업이 순서대로 진행되는 경향이 있음   ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC/","title":"운영체제 - 가상메모리 관리"},{"content":"공유자원과 임계구역\n공유자원과 임계구역 1. 공유 자원  여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 공동으로 이용되기에 누가 언제 데이터를 읽거나 쓰느냐에 따라 결과가 달라질 수 있음  경쟁 조건  2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황 공유 자원 접근 순서에 따라 실행 결과가 달라짐   image \n image \n2. 임계 구역  위의 예에서 balance(예금) 부분. 즉 공유 자원 접근 순서에 따라 달라지는 프로그램 영역 어떤 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역 밖에서 기다려야하며, 그 프로세스가 나와야 들어갈 수 있음  생산자-소비자 문제  image \n sum=3 일 때 동시 접근이 가능하게 되면  producer의 sum+1, customer의 sum-1이 실행 순서에 따라 랜덤으로 출력되어버림   하드웨어 자원의 경우에도 문제가 일어날 수 있음  해결 조건 상호 배제  한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역 접근X  한정 대기  어떤 프로세스도 무한 대기하지 않아야 함  진행의 융통성  한 프로세스가 다른 프로세스의 진행을 방해해서는 안됨  임계구역 해결 코드: 공유 변수로 잠금을 직접 구현  image \n lock=true인 경우 무한 루프 돌면서 대기 lock=false인 경우 lock을 걸고 임계 구역에서 작업하다가 lock을 해제하고 나옴  문제점  image \n lock=false일 때, lock=true로 걸고 임계 구역에 진입해야 하는데 그 직전에 타임아웃이 걸린다면?  다른 프로세스도 임계 구역에 진입하게 되고, 해당 타임아웃으로 대기하고 있던 프로세스도 대기가 끝나 실행될 때 또 임계구역에 진입해버린다 동시에 임계구역에 진입해버릴 수 있다는 것    임계 구역 해결 코드: 상호 배제 조건을 충족하는 코드  image \n 상호 배제 조건은 만족하지만, 여기서는 타임아웃 타이밍에 따라 상호 무한루프에 빠질 수 있는 위험이 있다.  임계 구역 해결 코드: 상호 배제와 한정 대기 조건을 만족  image \n 상호 배제와 한정 대기 조건을 만족 그러나 만약 P1이 자주 실행되어야 하는 상황이라면?  P1은 P2가 실행되어 락을 바꿔줄 때 까지 반드시 대기해야 한다 (반드시 번갈아가며 실행되야하므로) 그러므로 진행의 융통성을 충족하지 않음    임계 구역 문제 해결: 하드웨어의 지원  while(.==true); 문과 lock=true 문을 한꺼번에 실행 → testandset(\u0026amp;lock)==true\n  검사-지정 코드를 이용하면 명령어 실행 중간에 타임아웃이 걸려 임계구역을 보호하지 못하는 문제가 발생하지 않음\n  image \n 이 명령어는 원자성 (쪼개질 수 없음) 을 가져 중간에 인터럽트 될 수 없다.  임계 구역 문제 해결: 피터슨 알고리즘  image \n 임계구역 해결의 세 가지 조건 모두 만족 2개의 프로세스만 사용 가능하다는 한계  임계 구역 문제 해결: 데커 알고리즘  image \n 임계구역 해결의 세 가지 조건 모두 만족 2개의 프로세스만 사용 가능하다는 한계  임계 구역 문제 해결: 세마포어  프로세스가 작업을 마치면 다음 프로세스에 임계구역을 사용하라는 동기화 신호를 보냄\n  image \n image \n image \n Semaphore(.) : 전역변수 RS를 n으로 초기화. n은 현재 사용 가능한 자원의 수 P() : 잠금을 수행하는 코드  RS\u0026gt;0이면 (사용 가능한 자원이 있으면) : RS를 1만큼 감소시키고 임계구역 진입 RS≤0이면 : 0보다 커질 때 까지 block()   V() : 잠금 해제와 동기화를 같이 수행  RS 값을 1 증가시킴 세마포어에서 기다리는 다른 프로세스에게 wake_up() 신호를 보내 임계구역에 진입해도 좋다는 신호 보냄   뮤텍스랑 같음 간편하게 구현 가능 이거도 현재는 잘 안쓰이긴 함  BINARY 세마포어 사용 예  초기값이 1 상호 배제를 위해 사용 (하나 들어가면 아무도 못들어감)   image \nCOUNTING 세마포어 예  초기값이 1 이상 한개 이상의 자원이 있을 때 사용  여러개의 프로세스가 임계구역에 접근 가능     image \n세마포어의 잘못된 사용 예 (실수)  image \n 실수하여 세마포어를 쓰지 않고 공유자원에 접근하는 경우  그냥 바로 접근이 가능해 임계구역 보호 불가능   실수하여 P()를 두번 써버림  wake_up()신호가 발생되지 않아 세마포어에서 대기하고 있는 프로세스들 무한 대기   V()와 P()를 반대로 사용  역시 상호 배제가 적용되지 않은 상태로 되버리므로 임계구역 보호 불가능    임계구역 해결 방법: 모니터  공유자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공\n  자원을 보호하고 프로세스 간에 동기화를 시킴\n 작동 원리  image \n 임계구역으로 들어가려는 프로세스는 직접 P() 혹은 V()를 사용하지 않음 대신 모니터에게 작업을 요청 모니터는 요청받은 작업을 모니터 큐에 저장하고 순서대로 처리, 결과만 프로세스에 알려줌  모니터  모니터는 데이터와 프로시저 (메소드, 함수)를 포함하는 객체  모니터 안에서만 접근 가능   모니터 경계에서는 상호 배제를 엄격히 지켜야 함  한번에 한 스레드만 모니터 진입 가능 모니터는 상호 배제 보장   모니터가 사용되고 있을 때 들어가려는 스레드는 대기해야 함 모니터 안의 데이터는 모니터 내의 프로시저를 통해서만 접근 가능 상호배제, 동기화 두가지 모두 구현  동기화  예를 들어 생산자와 소비자의 예에서 소비자가 아직 미처 소비하지도 않았는데 계속해서 데이터를 공급하는 경우 한정된 큐에서 계속해서 공급하면 오버플로우 발생 그러므로 생산자는 소비자가 버퍼를 비웠을 때 공급하고, 소비자는 생산자가 버퍼를 채웠을 때 소비해야 하며 이를 동기적으로 실행하는 것이 동기화.   동기화를 구현하기 위해 조건 변수 구현   조건 변수\nwait(.) signal(.) 어떤 조건 변수에 대해서 동작을 수행할 때 까지 대기하고 있다가 해당 동작이 완료되면 기다리고 있는 프로세스에게 시그널을 보내면 깨어나 모니터를 얻음\n      모니터 코드  image \n 제공하는 인터페이스만 간단히 사용하면 끝  모니터 내부 코드  image \n자바 모니터  멀티 스레드를 사용하는 자바 응용 프로그램에서 상호 배제와 동기화를 제공 Synchronized 키워드  자바 객체에 상호 배제 기능 부여   Wait() 메소드  객체에 대한 잠금을 해제하고 상태 변수를 기다림   스레드는 notify() 혹은 notifyAll() 메소드를 호출해 신호 보냄 ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B3%B5%EC%9C%A0%EC%9E%90%EC%9B%90%EA%B3%BC-%EC%9E%84%EA%B3%84%EA%B5%AC%EC%97%AD/","title":"운영체제 - 공유자원과 임계구역"},{"content":"교착상태\n교착상태 1. 교착 상태  2개 이상의 프로세스가 다른 프로세스의 작업이 끝나기만을 기다리며 작업을 더 이상 진행하지 못하는 상태  아사상태와의 차이점  아사상태 : 운영체제가 잘못된 정책을 사용해 특정 프로세스의 작업이 지연되는 문제 교착상태 : 프로세스나 스레드가 결코 일어날 수 없는 특정 이벤트를 기다리는 것  발생 : 공유할 수 없는 자원을 사용할 때  image \n 위의 예에서는 P1, P2 둘 다 프린터, CD 레코더를 써야하는 상황 그러나 두 개 프로세스가 하나씩을 계속 점유하고 있기 때문에 무한 대기에 빠지게 됨  발생 : 공유 변수  image \n lock1, lock2가 모두 True가 되어 버릴 경우 두 프로세스 모두 한루프에 빠지게 됨  발생 : 응용 프로그램 데이터베이스같은 응용 프로그램에서도 교착상태 발생\n자원 할당 그래프  프로세스가 어떤 자원을 사용중이고 어떤 자원을 기다리고 있는지를 방향성이 있는 그래프로 그린 것 프로세스는 원, 자원은 사각형으로 표현   image \n다중 자원  여러 프로세스가 자원을 동시에 사용 수용할 수 있는 프로세스 수를 사각형 안에 작은 동그라미로 표현   image \n식사하는 철학자 문제  image \n 두 개의 포크를 사용해 칠면조를 먹어야 하는 상황 왼쪽에 있는 포크를 잡은 뒤 오른쪽에 있는 포크를 잡아야만 식사 가능  모두 동시에 식사를 시작한다고 가정한다면 다들 왼쪽에 있는 포크를 이미 집었으므로 가용 자원 없음 따라서 식사를 마칠 수 없으므로 교착상태에 빠지게 됨    조건   철학자들은 서로 포크를 공유할 수 없음\n → 자원을 공유하지 못하면 교착 상태가 발생    각 철학자는 다른 철학자의 포크를 빼앗을 수 없음\n → 자원을 빼앗을 수 없으면 자원을 놓을 때 까지 기다려야 하므로 교착상태 발생    각 철학자는 왼쪽 포크를 잡은 채 오른쪽 포크를 기다림\n → 자원 하나를 잡은 상태에서 다른 자원을 기다리면 교착 상태 발생    자원 할당 그래프가 원형\n → 자원을 요구하는 방향이 원을 이루면 양보를 하지 않기에 교착상태 발생 즉 원을 이루면 선후관계가 불분명하여 문제가 계속 맴돈다는 의미   image \n (사각형이라면 이런 문제는 없었을 것) (제일 왼쪽 철학자는 어차피 포크 2개를 가질 수 없어 식사가 불가능하다)    2. 교착상태 필요 조건  다음 4가지 조건이 모두 발생해야만 교착상태 발생\n  한가지라도 만족하지 않으면 교착상태 발생하지 않음\n 자원의 특징 조건  상호 배제  한 프로세스가 사용하는 자원은 다른 프로세스와 공유할 수 없는 자원이여야 함\n 비선점  한 프로세스가 사용중인 자원은 다른 프로세스가 빼앗을 수 없는 비선점 자원이여야 함\n프로세스의 행위 조건  점유와 대기  프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태여야 함\n 원형 대기  점유와 대기를 하는 프로세스 간의 관계가 원을 이루어야 함\n3. 교착상태 해결 방법 교착 상태 예방  교착상태 필요조건 4가지가 발생하지 않도록 예방\n  시스템에 제약을 가장 많이 둠\n  교착상태 조건 4가지에 대해 각각의 방식이 존재\n A. 상호 배제 예방  시스템 내에 상호 배타적인, 즉 독점적으로 사용 가능한 모든 자원을 없애버리는 방법 현실적으로는 모든 자원을 공유하도록 것은 불가능  B. 비선점 예방  모든 자원을 빼앗을 수 있도록 만드는 방법 그러나 아사 현상을 일으키고 뺏을 수 없는 자원이 있을수 밖에 없기에 불가능  C. 점유와 대기 예방  image \n image \n 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 함 전부 할당하거나 아예 할당하지 않는 방법 장점  자원 사용 방식을 변화시켜 교착 상태를 처리한다는 점에서 의미가 있음   단점  그러나 프로세스가 자신이 사용하는 모든 자원을 자세히 알기는 어려움 자원의 활용성이 떨어짐 많은 자원을 사용하는 프로세스가 적은 자원을 사용하는 프로세스보다 불리  아사 현상   결국 일괄 작업 방식으로 동작    D. 원형 대기 예방  image \n image \n 모든 자원에 숫자를 부여하고 숫자가 큰 방향으로만 자원 할당  마우스를 할당받은 상태에서 프린터를 할당받을 수는 있지만 프린터를 할당받은 상태에서는 마우스나 하드디스크를 할당받을 수 없음   위의 예에서 P2는 R2를 할당받았지만 R1을 할당받을 수 없기에 강제종료됨  따라서 P1은 R2를 할당받고 정상적으로 실행 가능   단점  작업 진행에 유연성이 떨어짐  사용자는 P2 → P1 순서로 실행하고 싶을수도 있다   자원의 번호를 어떻게 부여할 것인가?    E. 결론  상호배제와 비선점은 예방이 사실상 불가능 점유와 대기, 원형 대기는 프로세스 작업 방식을 제한하고 자원을 낭비  교착 상태 회피  교착상태가 발생하지 않도록 자원 할당량을 조절하여 교착 상태를 회피 프로세스에 자원을 할당할 때 어느 수준 이상의 자원을 나누어주면 교착상태가 발생하는지 파악, 해당 수준 이하로만 자원을 나누어주는 방법 교착상태가 발생하는 범위에 있으면 프로세스를 대기시킴 상태 예방보다는 제약이 적음  A. 안정 상태와 불안정 상태  image \n 안정 상태  각 프로세스의 기대 자원과 비교해, 가용 자원이 크거나 같은 경우가 한 번 이상인 경우 즉, 각 프로세스의 기대 자원이 5,7,8,10 이고 가용 자원이 5일 경우에도 시스템은 안정 상태   할당된 자원이 적으면 안정 상태가 크고 할당된 자원이 많으면 불안정 상태가 크다 교착 상태는 불안정 상태의 일부분  불안정 상태가 커질수록 교착상태 발생 가능성 높아짐   교착 상태 회피는 안정 상태를 유지할 수 있는 범위 내에서 자원을 할당해 교착 상태 회피  B. 은행원 알고리즘  image \n image \n 은행이 대출을 해주는 방식. 즉, 대츨 가능한 금액 범위 내이면 허용하지 그렇지 않으면 거부하는 것 위의 예는 라면 10개, 스파게티 20개가 있을 때  손님을 가용한 범위인 10 까지만 받겠다는 것 (모든 손님이 라면을 원할 수 있으므로)   변수 용어  전체 자원 가용 자원 (= 전체자원 - 프로세스들에 할당된 자원들) 최대 자원 : 각 프로세스가 선언한 최대 사용 가능한 자원 수 할당 자원 : 실제 각 프로세스에 할당된 자원 수 기대 자원 (= 최대 자원 - 할당 자원)   자원 할당 기준  각 프로세스의 기대 자원 ≤ 가용 자원    C. 교착 상태 회피의 문제점  프로세스가 자신이 사용할 모든 자원을 미리 선언해야함 시스템의 전체 자원 수가 고정적이여야 함 자원이 낭비됨  교착 상태 검출과 회복  시스템에 제약을 아예 두지 않음 자원 할당 그래프를 모니터링하며 교착 상태가 발생하는지 살펴보다가 교착 상태가 발생하면 교착 상태 회복 단계 진행  A. 타임아웃 이용해 검출  image \n 특정 시간 동안 작업이 진행되지 않은 프로세스를 교착 상태가 발생한것으로 간주 교착 상태가 자주 발생하지 않을것이라 가정하고 사용 타임아웃되면 프로세스가 종료됨 데이터베이스에서 타임아웃의 문제  일부 데이터의 일관성이 깨질 수 잇음 따라서 체크포인트와 롤백 사용, 작업을 하다 문제가 발생하면 과거의 체크포인트로 돌아감    B. 자원 할당 그래프를 이용해 검출  image \n 자원 할당 그래프에 사이클이 있으면 교착 상태 시간이 오래 걸림. 시스템 내의 전체 프로세스와 자원의 싸이클을 검출해야 하므로.  C. 교착 상태 회복  교착 상태가 검출된 후 교착 상태를 푸는 후속 작업을 하는 것 교착 상태 회복 단계에서는 교착 상태를 유발한 프로세스를 강제로 종료함 방법  교착 상태를 일으킨 모든 프로세스를 동시 종료 교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료  우선순위가 낮은 프로세스를 먼저 종료 우선순위가 같은 경우 시간이 짧은 프로세스를 먼저 종료 두 위의 조건이 같으면 자원을 많이 사용하는 프로세스를 먼저 종료      4. 다중 지원과 사이클  image \n 다중 자원이 포함된 자원 할당 그래프에서는 대기 그래프와 그래프 감소 방법을 이용해 사이클을 찾음\n 대기 그래프  자원 할당 그래프에서 프로세스와 프로세스 간에 기다리는 관계만 나타낸 그래프  그래프 감소  대기 그래프에서 작업이 끝날 가능성이 있는 그래프의 화살표와 관련 프로세스의 화살표를 연속적으로 지워나가는 작업  교착 상태가 발생하지 않는 경우  image \n교착 상태가 발생한 경우  image \n","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C/","title":"운영체제 - 교착상태"},{"content":"네트워크 저장장치\n네트워크 저장장치 DAS (. Attached Storage)  image \n 서버와 같은 컴퓨터에 직접 연결된 저장장치를 사용하는 방식 HAS (. Attached Storage) 라고도 부름 윈도우의 파일 공유(여러 컴퓨터 중 하나를 파일 공유 서버로 지정하고 나머지 컴퓨터에서 서버로 지정된 컴퓨터에 접근하여 파일을 이용하는 방식으로 운영) 단점  서버 컴퓨터 운영체제 지원하는 파일 시스템만을 사용 데이터의 관리나 백업을 사용자가 직접 해야 함    NAS (. Attached Storage)  image \n 기존의 저장장치를 LAN이나 WAN에 붙여서 사용하는 방식 NAS 전용 운영체제를 가진 독립적인 장치로 새로운 하드디스크를 추가하거나 뺄 수 있음 저장장치를 네트워크상에 두고 여러 클라이언트가 네트워크를 통해 접근하게 함으로써 공유 데이터의 관리 및 데이터의 중복 회피가 가능  SAN (. Area Network)  image \n 데이터 서버, 백업 서버, RAID 등의 장치를 네트워크로 묶고 데이터 접근을 위한 서버를 두는 형태 시스템이 제공하는 인터페이스를 통해 데이터에 접근 저장장치에 필요한 장치들을 네트워크로 묶어 하나의 시스템을 구성하기 때문에 다양한 서비스를 제공 데이터의 공유, 백업, 보안 등이 서버를 통해 자동으로 이루어짐 데이터 서버나 백업 서버를 같이 구축하여 NAS보다 구축 비용이 많이 듦 ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98/","title":"운영체제 - 네트워크 저장장치"},{"content":"네트워크와 인터넷\n네트워크와 인터넷 네트워크 구성 방식 : 강결합 시스템  image \n 강결합 시스템  네트워크로 연결된 모든 컴퓨터의 프로세서가 하나의 메모리를 공유하는 방식 모든 컴퓨터는 메모리를 공유하면서 같은 운영체제 사용 약결합 시스템에 비해 속도가 빠름 프로세서들이 하나의 공유 메모리를 사용하여 통신하기 때문에 공유 메모리를 서로 사용하려고 경쟁하며, 이러한 경쟁을 결합 교환 방법으로 해결    네트워크 구성 방식 : 약결합 시스템  image \n 약결합 시스템  둘 이상의 독립된 시스템을 연결한 것 자신만의 운영체제, 메모리, 프로세서, 입출력장치를 가지고 독립적으로 운영되다가 필요할 때 통신선을 이용하여 메시지 전달이나 원격 프로시저 호출(.)로 통신 컴퓨터들이 서로 독립적으로 작동하기 때문에 하나의 시스템에 장애가 발생해도다른 시스템에 영향을 미치지 않음    LAN 토폴리지의 종류  image \n 스타형 : 중간에 네트워크를 관장하는 시스템을 두고 방사형으로 기기를 연결 링형 : 모든 기기를 원형으로 연결 버스형 : 중앙의 버스에 독립적으로 기기를 붙여 네트워크를 구성  분산 시스템  네트워크상에 분산되어 있는 컴퓨터가 작업을 처리하고 그 내용이나 결과를 서로 교환  분산 시스템의 장점  네트워크로 연결된 기기가 여러 자원을 공유할 수 있음 작업 분배(. balancing)를 통해 여러 기기가 작업을 나누어 처리할 수 있음 데이터나 처리를 분산함으로써 연산 속도를 향상할 수 있음 장애가 발생해도 시스템을 복구할 수 있음  분산 시스템에 사용되는 운영체제  네트워크 운영체제  각 컴퓨터가 독자적인 운영체제를 가진 채 사용자 프로그램을 통해 분산 시스템이 구현된 것 낮은 수준의 분산 시스템 운영체제 기기마다 운영체제가 다름 지역적으로 널리 분산된 대규모 네트워크에서 사용하기 때문에 사용자가 기기 및 운영체제의 종류와 사용법을 알고 있어야 함   분산 운영체제  시스템 내에 하나의 운영체제가 존재하고, 전체 네트워크를 통틀어서 단일 운영체제로 운영 전체 시스템을 일관성 있게 설계할 수 있음    CGI  동적인 데이터를 HTML에 삽입하기 위해 프로세스에 질문을 하고 그 결과값을 HTML 형태로 웹 데몬에 전달하는 프로세스가 필요해서 개발  P2P 시스템  image \n 비구조적 P2P 시스템 : 전체 노드에 대한 정보는 서버가 가지고 있고, 실제 데이터 전송은 일대일로 연결된 말단 노드를 통해 이루어지는 구조 구조적 P2P 시스템 : 각 노드가 전체 네트워크 정보가 아닌 부분적인 네트워크 정보를 유지. 파일 보유 정보를 여러 노드가 공유함으로써, 시스템의 한 노드가 사라지더라도 데이터 공유가 지속적으로 이루어짐  클라우딩 컴퓨팅 특징  위치에 무관한 자원 공동 사용 어디서나 연결 가능 온 디맨드 셀프 서비스 신속한 탄력성 사용한 만큼 지불 장점  비용 절감 시간 절감 사용 편의 확장성 재해 예방    LaaS, PaaS, Saas  IaaS (. As A Service)  물리적 서버(., Memory, O/S), 스토리지, 네트워크를 가상화하여 유연하게 제공하는 인프라 서비스   PaaS (. As A Service)  기업이 웹 어플리케이션 등의 어플리케이션을 개발하고 실행하기 위한 환경을 서비스 형태로 제공   SaaS (. As A Sevice)  기업 또는 일반 소비자가 다양한 어플리케이션(.)을 인터넷 및 웹브라우저를 통해 서비스로 제공    클라우딩 컴퓨팅 확산 근거  빅 데이터 시장 활성화 모바일 시장 활성화 클라우드 스트리밍 녹색 성장  고효율, 저탄소 Green IT를 위한 기업 투자 증가   ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%99%80-%EC%9D%B8%ED%84%B0%EB%84%B7/","title":"운영체제 - 네트워크와 인터넷"},{"content":"디스크 스케줄링\n디스크 스케줄링 디스크 스케줄링  트랙의 이동을 최소화하여 탐색 시간을 줄이는 것이 목적  아래 예시들에서 공통으로 이용할 트랙 접근 순서  image \nFCFS 디스크 스케줄링 (. Come First Served)  요청이 들어온 순서대로 서비스 헤드가 이동한 총거리 : 7+9+6+8+20+4+5+6=65   image \nSSTF 디스크 스케줄링 (. Seek Time First)  image \n image \n 현재 헤드가 있는 위치에서 가장 가까운 트랙부터 서비스 다음에 서비스할 두 트랙의 거리가 같다면 먼저 요청받은 트랙을 서비스 헤드가 이동한 총거리 : 1+3+3+1+3+12+3+5=31 효율성은 좋지만 아사 현상을 일으킬 수 있어 사용하지 않음  계속 요청이 들어오는 경우 먼 곳에 있는 곳의 트랙은 아예 접근 못할수도    블록 SSTF 디스크 스케줄링  image \n 큐에 있는 트랙 요청을 일정한 블록 형태로 묶음 모든 트랙은 블록 안에서만 움직임 헤드가 이동한 총거리 : 2+9+3+8+20+3+1+5=51 에이징을 사용하여 공평성을 보장하지만 FCFS에 비해 성능 향상은 제한적  SCAN 디스크 스케줄링  image \n image \n 헤드가 움직이기 시작하면 맨 마지막 트랙에 도착할 때까지 뒤돌아가지 않고 계속 앞으로만 전진하면서 요청받은 트랙을 서비스 헤드가 이동한 총거리 : 1+3+3+5+3+17+2+1+3=38 동일한 트랙이나 실린더 요청이 연속적으로 발생하면 헤드가 더 이상 나아가지 못하고 제자리에 머물게 되어 - 바깥쪽 트랙이 아사 현상을 겪는 문제가 발생  예를들어 11번을 처리하고 왼쪽으로 나아가는데, 만약 큐에 자꾸 10번 요청이 계속 들어오면 10번만 처리해줘야하는 문제   엘리베이터를 생각하면 쉬움  C-SCAN 디스크 스케줄링 (. SCAN)  image \n image \n SCAN 디스크 스케줄링을 변형한 것 - 헤드가 한쪽 방향으로 움직일 때는 요청받은 트랙을 서비스하고 반대 - 방향으로 돌아올 때는 서비스하지 않고 이동만 함 헤드가 이동한 총거리 : 1+3+3+5+3+24+1+3+1+2=46 동일한 트랙(실린더) 요청이 연속적으로 발생하면 바깥쪽 트랙이 아사 현상을 겪음  LOOK 디스크 스케줄링  image \n image \n 더 이상 서비스할 트랙이 없으면 헤드가 끝까지 가지 않고 중간에서 방향을 바꿈 헤드가 이동한 총거리 : 1+3+3+5+17+2+1+3=35 SCAN은 끝까지 가는데 이건 처리할게 그 방향에 없다면 U턴  C-LOOK 디스크 스케줄링  image \n C-SCAN 디스크 스케줄링의 LOOK 버전 한쪽 방향으로만 서비스하는 C-SCAN 디스크 스케줄링과 유사한데, 차이점은 더 이상 서비스할 트랙이 없으면 - 헤드가 중간에서 방향을 바꿀 수 있다는 것 헤드가 이동한 총거리 : 1+3+3+5+20+3+1+2=38  SLTF 디스크 스케줄링 (. Latency Time First)  디스크의 회전을 줄이기 위한 스케줄링 큐에 들어온 요청을 디스크의 회전 방향에 맞춰 재정렬한 후 서비스   image \n","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/","title":"운영체제 - 디스크 스케줄링"},{"content":"메인보드\n메인보드 메인보드의 포트  image \n CPU 포트 : CPU를 꽂는 곳 램 포트 : 램을 수직으로 꽂는 곳 그래픽 포트 : 외부 그래픽카드를 연결하는 포트 SATA : 하드디스크 같은 저장장치를 연결하는 직렬 ATA 포트 PCI : 그 외의 주변장치는 메인보드에 주변장치를 연결하는 포트  직렬 포트와 병렬 포트  버스의 통신 방식은 크게 직렬 방식과 병렬 방식으로 구분 직렬 방식에서는 데이터가 한 줄로 이동하고 병렬 방식에서는 데이터가 여러 줄로 동시에 이동  USB 포트  키보드, 마우스, 프린터, 카메라, 저장장치 등 다양한 주변장치를 연결하기 위해 만든 표준 연결 포트  포트 연결 단자  image \n USB : USB 메모리나 카메라 등 다양한 주변장치를 연결할 수 있는 범용 포트 SATA : 컴퓨터 내부에 있는 각종 저장장치를 연결할 때 사용 D-SUB : 가장 오래된 모니터 연결 단자로 대개 파란색 DVI : 컴퓨터 디스플레이와 디지털 프로젝터 같은 디지털 디스플레이 장치의 화질에 최적화된 표준 영상 인터페이스 HDMI : 비압축 방식의 디지털 비디오/오디오 인터페이스 규격  CD의 규격  CD DVD 블루레이  그래픽카드의 발전  CPU는 복잡한 그래픽 계산에 적합하게 설계되지 않음 현대의 컴퓨터 시스템에는 그래픽카드에 그래픽 계산만 전담하는 GPU가 추가됨 일반적인 작업은 CPU가 담당하고 그래픽 작업은 GPU가 담당하는 형태로 바뀜 ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%94%EC%9D%B8%EB%B3%B4%EB%93%9C/","title":"운영체제 - 메인보드"},{"content":"물리 메모리 관리\n물리메모리 관리 1. 메모리 주소  1Byte 단위로 나뉨 보통 0번지부터 시작 메모리에 있는 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 메모리 주소 레지스터를 사용  2. 메모리 관리의 복잡성  폰 노이만 구조 컴퓨터에서 유일한 작업공간  모든 프로그램은 메모리에 올라와야 실행 가능   일괄처리 시스템  한번에 하나의 프로그램만 실행 메모리 관리가 단순   시분할 시스템  운영체제를 포함한 모든 응용 프로그램이 모두 메모리에 올라감 관리가 복잡    메모리 관리의 이중성  프로세스 입장에서는 메모리를 독차지하려 함 메모리 관리자 입장에서는 되도록 관리를 효율적으로 하고싶어함  3. 언어 번역 프로그램의 종류  컴파일러 : 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한꺼번에 실행 인터프리터 : 소스코드를 한 행씩 번역하며 실행  컴파일러의 목적  오류 발견 코드 최적화  컴파일러와 인터프리터의 차이  image \n컴파일 과정  image \n 소스코드 작성 및 컴파일  에러찾기와 최적화   목적 코드 (기계어), 라이브러리 연결 동적 라이브러리를 포함하여 최종 실행  기존 라이브러리는 내부 함수가 변경되면 재컴파일 해야함 동적 라이브러리는 실행시에 포함되므로 재컴파일 필요 없음 (., SO)    3. 메모리 관리자  메모리 관리를 담당하는 하드웨어 어떠한 프로세스가, 어떤 위치의 메모리에 올려져야 할지, 어디 재배치할지 할지 결정  메모리 관리자의 작업 및 정책  가져오기 작업/정책  프로세스와 데이터를 메모리로 가져오는 작업 프로세스가 필요로 하는 데이터를 언제 메모리로 가져올지 정책으로 결정   배치 작업/정책  가져온 프로세스와 데이터를 메모리의 어떤 부분에 올릴지 정책을 통해 결정   재배치 작업/정책  꽉 차 있는 메모리에 새로운 프로세스를 가져오기 위해 오래된 프로세스를 내보냄 이 때 어떤 프로세스를 내보낼 지 정책을 통해 결정    물리 주소 공간, 논리 주소 공간  물리 주소 공간  하드웨어 입장에서 바라본 주소 공간. 컴퓨터마다 크기가 다름   논리 주소 공간  사용자 입장에서 바라본 주소 공간    단순 메모리 구조  image \n 일괄 처리 시스템에서 사용 메모리를 운영체제 영역, 사용자 영역 두개로 나누어 관리 사용자 프로세스는 운영체제 영역을 피해 메모리에 적재 사용자 프로세스를 메모리에 올릴 때 메모리의 최상위 **(.)**부터 적재  그러나 메모리를 거꾸로 사용하기 위해 주소를 변경하는것은 복잡해 잘 사용안함    경계 레지스터  운영체제 영역과 사용자 영역 경계 지점의 주소를 가진 레지스터 (.) CPU 내에 있는 경계 레지스터가 사용자 영역이 운영체제 영역으로 침범하는 것을 막아줌 메모리 관리자는 사용자가 작업을 요청할 때 마다 경계 레지스터의 값을 벗어나는지 검사  경계 레지스터를 벗어나는 작업을 요청하는 프로세스가 있다면 그 프로세스를 종료    절대 주소  실제 물리 주소  상대 주소  사용자 영역이 시작되는 번지를 0번지로 변경해 사용 사용자 프로세스 입장에서 바라본 주소 절대 주소와 관계없이 항상 0번지부터 시작  절대 주소와 상대 주소의 차이  image \n상대 주소를 절대 주소로 변환하는 과정  image \n 메모리 접근 시 상대 주소를 사용하면 결과적으로 절대 주소로 변환됨 상대 주소값 + 재배치 레지스터값 = 절대 주소 재배치 레지스터  주소 변환의 기본이 되는 주소값을 가진 레지스터 메모리에서 사용자 영역의 시작 주소값이 저장됨    4. 메모리 오버레이  프로그램의 크기가 실제 메모리보다 클 때, 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법\n 작동 방식  image \n 프로그램이 실행되면 필요한 모듈만 메모리에 올라옴 한정된 메모리에서 메모리보다 더 큰 프로그램 실행 가능 프로그램 전체가 아닌 일부만 메모리에 올라와도 실행 가능  5. 스왑 영역  메모리가 모자라서 쫓겨난 프로세스를 저장장치의 특별한 공간에 모아두는 영역 저장장치는 장소만 빌려주고 메모리 관리자가 관리하는 영역 사용자는 실제 메모리 + 스왑 영역의 크기를 합쳐 전체 메모리로 인식  스왑인  스왑 영역에서 메모리로 데이터를 가져오는 작업  스왑아웃  메모리에서 스왑 영역으로 데이터를 내보내는 작업  6. 메모리 분할 방식  메모리에 여러 개의 프로세스를 배치하는 법\n  image \n image \n가변 분할 방식  프로세스의 크기에 따라 메모리를 나누는 것 연속 메모리 할당 장점  프로세스를 한 덩어리, 연속적으로 처리해 처리가 쉬움   단점  프로세스 하나가 종료되면 중간에 비어있는 메모리 처리 등 메모리 관리가 복잡    고정 분할 방식  프로세스의 크기와 상관없이 메모리를 같은 크기로 나누는 것 비연속 메모리 할당 장점  메모리를 일정한 크기로 나눠 관리하기에 메모리 관리 수월   단점  메모리 낭비가 일어날 수 있음    가변 분할 방식의 자리 배정  image \n image \n 대기중인 프로세스가 들어갈 수 있을만한 자리가 반드시 나야함  가변 분할 방식과 외부 단편화  image \n 가변 분할 방식에서 발생할 수 밖에 없는 중간의 작은 빈 공간을 외부 단편화라고 함  외부 단편화 해결법  image \n 메모리 배치 방식 최적화  최초 배치  프로세스를 메모리에 배치할 때 메모리에서 적재 가능한 공간을 순서대로 검색하여 첫번째로 발견한 공간에 프로세스를 배치 빈 공간을 모두 확인할 필요 없음   최적 배치  메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 배치 빈 공간을 모두 확인해야 함  그러나 딱 맞는 공간을 찾을 경우 단편화 발생하지 않을 수 있다. 딱 맞는 공간이 없을 때는 작은 조각을 만들수밖에 없음     최악 배치  빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스를 배치 빈 공간을 모두 확인해야 함  프로세스를 배치하고 남는 공간이 크기 때문에 쓸모가 있음 빈 공간의 크기가 클 때는 효과적이지만 점점 줄어들수록 작은 조각을 만들 수 밖에 없음       조각 모음  과정  프로세스의 동작을 멈춤 프로세스를 적당한 위치로 이동 (프로세스의 상대 주소값 변경) 작업을 마친 후 프로세스 다시 시작   현재 실행중인 프로세스를 종료하고 메모리를 옮겨야 하므로 실제로는 사용 잘 안함    고정 분할 방식의 자리 배정  image \n image \n C같은 경우 C1, C2로 나뉘는데  C2가 들어갈 메모리 공간이 없으므로 스왑 영역으로 들어가게 된다.    고정 분할 방식과 내부 단편화  각 메모리 족가에 프로세스를 배치하고 공간이 남는 현상 내부 단편화를 줄이기 위해 메모리 칸 크기에 신중해야 하지만 얼마로 나누느냐에 대한 정답은 없음  가변 분할 방식과 고정 분할 방식 비교  image \n분할 방식 : 버디 시스템  가변 분할 방식과 고정 분할 방식의 장점들을 취합하려 시도   메모리를 1/2 크기로 잘라가며 프로세스 크기에 적절한 메모리 공간을 할당함 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어감 프로세스가 종료되면 주변의 빈 조각과 합쳐서 하나의 큰 덩어리를 만듬  자리 배정 방법  image \n image \n image \n버디 시스템 특징  가변 분할 방식처럼 메모리가 프로세스 크기대로 나뉨 고정 분할 방식처럼 하나의 구역에 다른 프로세스가 들어갈 수 없고, 내부 단편화 발생 비슷한 크기의 조각이 서로 모이는 효과가 있음  작은 조각을 통합해 큰 조각을 만들기 용이함    7. 변수와 메모리 할당  image \n image \n image \n 컴파일러는 변수를 사용할 때마다 사용 범위를 넘는지 점검 컴파일러는 모든 변수를 메모리 주소로 바꾸어 기계어로 된 실행 파일을 만듬 컴파일러에 의해 만들어진 변수의 주소는 상대주소임 ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%AC%BC%EB%A6%AC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC/","title":"운영체제 - 물리 메모리 관리"},{"content":"스레드\n스레드 1. 스레드의 정의  CPU 스케줄러가 CPU에 전달하는 일 하나 명령어의 한 줄기 혹은 프로그램 제어 흐름 프로세스에 있는 스레드들은 병행으로 실행되며 공통의 목표를 이루려고 협력 CPU가 처리하는 작업의 단위는 프로세스로부터 전달받은 스레드  운영체제 입장에서 작업 단위는 프로세스 (하나의 요리) CPU 입장에서의 작업 단위는 스레드 (요리를 위한 작업들)   프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위  2. 프로세스와 스레드의 차이  image \n 프로세스끼리는 약하게 연결되어 있지만, 스레드끼리는 강하게 연결되어 있음 보다시피 요리끼리는 연결고리가 약하지만 요리를 만들기 위한 작업들의 경우 공통의 목표를 이루기 위해 병행으로 실행되며 협력하는 모습  3. 멀티태스크와 멀티스레드 멀티태스크  여러 개의 프로세스가 병렬적으로 실행 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법  멀티스레드  하나의 프로세스에 여러 개의 스레드로 구성된 것 프로세스 내 작업을 여러 개의 스레드로 분할함으로서 작업의 부담을 줄이는 프로세스 운영 기법 소프트웨어적 기법: 운영체제가 프로세스를 작은 단위의 스레드로 분할하여 운영하는 것  멀티프로세싱  여러개의 CPU를 사용해 여러 개의 스레드를 동시에 처리하는 작업 환경  CPU 멀티스레드  한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용해 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법 하드웨어적 기법: 하나의 CPU에서 여러 스레드를 병렬적으로 동시에 처리하도록 설계  2. 멀티스레드의 구조와 예 멀티태스킹의 낭비 요소  image \n fork() 시스셈 호출로 프로세스를 복사하면  코드 영역과 데이터 영역의 일부가 중복되어 존재  필요 없는 정적 영역이 여러개가 됨   부모-자식 관계이지만 서로 독립적인 프로세스임 따라서 이러한 낭비 요소들을 제거할 수 없음   멀티스레드는 코드, 파일 등의 자원을 공유함으로서 자원의 낭비를 막고 효율성을 향상시킴  자바 스레드 코드의 예  image \nfork() 시스템 호출로 작성한 코드 예  image \n 정적 영역이 2배가 되어 자원 낭비가 심하다  멀티스레드의 장점  image \n 응답성 향상  단일 스레드일때보다 스레드 당 작업을 할당하여 응답성이 향상될 수 있음   자원 공유 효율성 향상 다중 CPU 지원  멀티스레드의 단점  모든 스레드가 자원을 공유  한 스레드에 문제가 생기면 전체 프로세스에 영향을 미침    3. 멀티스레드 모델 커널 스레드  image \n 커널이 직접 생성하고 관리 하나의 사용자 스레드가 하나의 커널 스레드와 연결 (. to 1 모델) 독립적으로 스케줄링  특정 스레드가 대기 상태에 들어가도 다른 스레드는 작업 계속 가능   커널 레벨에서 모든 작업을 지원  멀티 CPU 사용 가능   커널의 기능을 사용하므로 보안에 강하고 안정적 문맥 교환 시 오버헤드 발생  느리게 작동할 수 있음    사용자 스레드  image \n 라이브러리에 의해 구현된 스레드 사용자 프로세스 내에 여러 개의 스레드가 커널의 스레드 하나와 연결 (. to N 모델) 라이브러리가 직접 스케줄링을 하고 작업에 필요한 정보를 처리  문맥 교환이 필요없다 (. 스케줄링은 오버헤드가 심함)   커널 입장에서는 여러개의 스레드가 있는지 알 수 없어 하나로 보임  커널 스레드가 입출력 작업을 위해 대기 상태에 들어가면 모든 사용자 스레드가 같이 대기하게 됨   한 프로세스의 타임 슬라이스를 여러 스레드가 공유  여러 개의 CPU를 동시에 사용할 수 없음   예) 자바 스레드  멀티레벨 스레드  image \n 사용자 레벨 스레드와 커널 레벨 스레드를 혼합 (. to N 모델) 커널 스레드가 대기 상태에 들어가면 다른 커널 스레드가 대신 작업  사용자 레벨 스레드보다 유연하게 작업 처리 가능   커널 레벨 스레드를 같이 사용  여전히 문맥 교환 오버헤드 발생   빠르게 움직여야 하는 스레드는 사용자 레벨 스레드로 안정적으로 움직여야 하는 스레드는 커널 레벨 스레드로 작동 ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8A%A4%EB%A0%88%EB%93%9C/","title":"운영체제 - 스레드"},{"content":"스레싱\n스레싱 스레싱  잦은 페이지 부재로 하드디스크 입출력이 너무 많아져 작업이 멈춘 것 같은 상태  스레싱 발생 시점  CPU가 작업하는 시간보다 스왑 영역으로 페이지를 보내고 새로운 페이지를 메모리에 가져오는 작업이 빈번해져서 CPU가 작업할 수 없는 상태에 이르게 되는 시점 물리 메모리의 크기를 늘리면 스레싱 발생 지점이 늦춰져서 프로세스를 원만하게 실행할 수 있음   image \n스레싱과 프레임 할당  프로세스에 너무 적은 프레임을 할당하면 페이지 부재가 빈번히 일어남 프로세스에 너무 많은 프레임을 할당하면 페이지 부재는 줄지만 메모리가 낭비됨 프로세스에 프레임을 할당하는 방식은 크게 정적 할당과 동적 할당으로 구분  정적 할당 균등 할당  프로세스의 크기과 상관 없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당 크기가 큰 프로세스의 경우 필요한 만큼 프레임을 할당받지 못함  페이지 부재 빈번 크기가 작은 프로세스의 경우 메모리 낭비    비례 할당  프로세스의 크기에 비례하여 프레임 할당 고정 할당보다는 좀 더 현실적  그러나 실행중에 필요로 하는 프레임을 유동적으로 반영하지 못함 사용하지 않을 메모리를 미리 확보하는 셈이라 공간 낭비    동적 할당 - 작업집합 모델  image \n 최근 일정 시간 동안 참조된 페이지들을 집합으로 만들고, 이 집합에 있는 페이지들을 물리 메모리에 유지  작업집합 크기 : 작업집합 모델에서 물리 메모리에 유지할 페이지 크기 작업집합 윈도우 : 작업집합에 포함되는 페이지 범위   델타 동안 참조된 10개의 페이지 중 작업집합에는 WS(.)={1, 7, 5, 2, 3}이 삽입되며, 이 페이지들은 다음번 윈도우에 도달할 때까지 물리 메모리에 보존   image \n 작업집합 크기  작업집합에 들어갈 최대 페이지 수 작업 집합 갱신 주기 (.번 페이지 접근시 마다)    작업 집합 윈도우의 크기와 프로세스 실행 성능  작업집합 윈도우를 너무 크게 잡으면 필요 없는 페이지가 메모리에 남아서 다른 프로세스에 영향을 미침 윈도우를 너무 작게 잡으면 필요한 페이지가 스왑 영역으로 옮겨져서 프로세스의 성능이 떨어짐 적정크기의 작업집합을 유지함으로써 메모리를 효율적으로 관리 할 수 있음  동적할당 - 페이지 부재 빈도  image \n 페이지 부재 횟수를 기록하여 페이지 부재 비율을 계산하는 방식 페이지 부재 비율이 상한선을 초과하면 프레임을 추가하여 늘림 페이지 부재 비율이 하한선 밑으로 내려가면 할당한 프레임을 회수 페이지 부재 빈도 방식은 프로세스를 실행하면서 추가적으로 페이지를 할당하거나 회수하여 적정 페이지 할당량을 조절  전역 교체와 지역 교체  image \n 전역 교체  전체 프레임을 상대로 교체 알고리즘 적용   지역 교체  현재 실행중인 프로세스의 프레임만을 대상으로 교체 알고리즘 적용    지역 교체의 장단점  장점 : 자신에게 할당된 프레임의 전체 개수에 변화가 없기 때문에 페이지 교체가 다른 프로세스에 영향을 미치지 않음 단점 : 자주 사용하는 페이지가 스왑 영역으로 옮겨져 시스템의 효율이 떨어짐  페이지 테이블의 크기  image \n 페이지 테이블이 차지하는 공간은 1,048,576개 X 20Bit = 약 2.62MB (각 프로세스마다)  프로세스의 프레임 공유 예  image \n image \n 예를 들어 크롬을 두개 실행했을 경우 실행 부분은 메모리를 공유하고 데이터 부분만 따로 사용  쓰기 시점 복사  image \n 예를들어 크롬을 포크했을 때 기존의 메모리를 사용하고 있다가 데이터의 변화가 있을 때 그제서야 데이터 영역을 복사해 새로 할당해 주는 것  데이터의 변화가 있을 때 까지 복사를 미루는 방식 메모리를 효율적으로 사용하기 위함   ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8A%A4%EB%A0%88%EC%8B%B1/","title":"운영체제 - 스레싱"},{"content":"인터럽트와 프로세스 통신\n인터럽트와 프로세스 통신 1. 인터럽트 심화 폴링  입출력을 요청하면 운영체제가 직접 주기적으로 입출력장치를 확인하여 처리  인터럽트  입출력 관리자에게 입출력을 요청하고 입출력이 완료되면 이벤트를 발생시켜 알림 동기적 인터럽트  프로세스가 실행중인 명령어로 발생 다른 사용자의 메모리 영역 접근, 오버플로우, 언더플로우, 수를 0으로 나누는 산술 연산 등   비동기적 인터럽트  하드딛스크 읽기 오류, 메모리 불량 등 하드웨어적 오류 사용자가 직접 작동하는 키보드 인터럽트, 마우스 인터럽트    인터럽트 처리 과정  image \n 인터럽트가 발생하면 현재 실행중인 프로세스는 일시정지, 재시작하기 위해 상태 정보를 PCB에 임시 저장함 인터럽트 컨트롤러가 실행되어 인터럽트 처리 순서 결정 먼저 처리할 인터럽트가 결정되면 인터럽트 벡터에 등록된 인터럽트 핸들러 (해당 이벤트를 처리할 함수의 시작 주소) 실행 핸들러가 인터럽트 처리를 마치면 일시정지된 프로세스가 다시 실행되거나 종료  커널 모드  운영체제와 관련된 커널 프로세스가 실행되는 상태  사용자 모드  사용자 프로세스가 실행되는 상태  이중 모드  운영체제가 커널 모드와 사용자 모드를 전환하며 일 처리를 하는 것 궁극적인 목적은 자원 보호  시스템 호출과 API  image \n 사용자 프로세스가 자원에 접근하려면 시스템 호출을 이용해야 함 사용자 프로세스는 API가 준비해놓은 다양한 함수를 이용해 시스템 자원에 접근  2. 프로세스 통신 종류  image \n 프로세스 내부 데이터 통신  한 프로세스 내에 2개 이상의 스레드가 존재하는 경우의 통신 전역 변수, 파일을 이용해 데이터를 주고받음   프로세스 간 데이터 통신  한 PC에 있는 여러 프로세스끼리 통신 공용 파일 또는 운영체제가 제공하는 파이프 이용   네트워크를 이용한 데이터 통신  여러 컴퓨터가 네트워크로 연결되어 있을 때 통신 소켓을 이용    분류  image \n통신 방향에 따른 분류  양방향 통신  데이터를 동시에 양쪽 방향으로 전송 가능 일반적인 통신 소켓 통신   반양방향 통신  양쪽 방향으로 통신 가능하나 동시 전송 불가 무전기   단방향 통신  한쪽 방향으로만 데이터 전송 모스 신호 전역 변수, 파이프    통신 구현 방식에 따른 분류  대기가 있는 통신  동기화를 지원하는 통신 방식 데이터를 받는 쪽은 데이터가 도착할 때 까지 대기   대기가 없는 통신  동기화를 지원하지 않는 통신 방식 데이터를 받는 쪽은 Busy Waiting을 통해 데이터가 도착했는지 여부를 직접 확인    프로세스 간 통신 방식  image \n 데이터를 주거나 받는 쓰기 연산과 읽기 연산으로 이루어짐  공유메모리 방식  공동으로 관리하는 메모리를 사용해 데이터를 주고받음 데이터를 보내는 쪽은 공유메모리에 쓰기, 받는 쪽은 공유메모리 읽기 유닉스 공유메모리 관련 함수: shmget(), shmat()  파일을 이용한 통신  image \n 파일 열기  open(“com.txt”, O_RDWR) : com.txt 파일을 읽기와 쓰기를 할 수 있는 형태로 준비 파일이 열리면 open 함수는 그 파일에 접근할 수 있는 권한인 파일 기술자 fd를 사용자에게 반환   읽기 또는 쓰기 연산  write(., “Test”, 5) : fd, 즉 com.txt 파일에 Test라는 문자열을 쓰라는 뜻 read(., buf, 5) : fd, 즉 com.txt 파일에서 5B를 읽어 변수 buf에 저장   파일 닫기  close(.) : fd가 가리키는 파일, 즉 com.txt 파일을 닫음    파이프를 이용한 통신  image \n 파이프로 양방향 통신을 하려면 파이프 2개 사용 운영체제가 제공하는 동기화 통신 방식  파일 입출력과 같이 open() 함수로 기술자를 얻고 close() 함수로 마무리   파이프에 쓰기 연산, 읽기 연산을 통해 송신 수신  이름 없는 파이프  일반적인 파이프  이름 있는 파이프  FIFO라는 특수 파일을 이용해 서로 관련없는 프로세스 간 통신에 사용  소켓을 이용한 통신  image \n 여러 컴퓨터에 있는 프로세스끼리 통신 통신하고자 하는 프로세스는 자신의 소켓과 상대의 소켓을 연결 (바인딩) 소켓에 쓰기 연산을 하면 데이터가 전송되고 읽기 연산을 하면 데이터를 받게 됨 ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%99%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%ED%86%B5%EC%8B%A0/","title":"운영체제 - 인터럽트와 프로세스 통신"},{"content":"입출력 시스템\n입출력 시스템 주변장치  image \n 저속 주변장치 : 키보드, 마우스 등 고속 주변장치 : 그래픽카드, 하드디스크 등  채널  데이터가 지나다니는 통로  채널 공유와 채널 분리  채널을 모든 주변장치가 공유하면 데이터 전송 속도가 느려짐 그래서 전송 속도가 비슷한 장치끼리 묶어 장치별로 채널 할당  전체 데이터 속도를 향상시킬수 있음    입출력 버스 구조 - 초기  image \n 모든 장치가 하나의 버스를 사용 CPU가 작업을 진행하다가 입출력 명령을 만나면 직접 입출력장치에서 데이터를 가져오는 폴링방식 이용  입출력 버스 구조 - 입출력 제어기 사용  image \n 버스는 메인버스와 입출력 버스의 2개의 채널로 나뉨  메인버스 : 고속으로 작동하는 CPU와 메모리가 사용 입출력 버스 : 주변장치가 사용   입출력 제어기를 사용하면 느린 입출력장치로 인해 CPU와 메모리의 작업이 느려지는 것을 막을 수 있어 전체 작업 효율 향상  입출력 버스의 분리   입출력 제어기를 사용하면 작업 효율을 높일 수 있지만, 저속 주변장치 때문에 고속 주변장치의 데이터 전송이 느려지는 문제가 있음\n  이를 해결하기 위해 입출력 버스를 고속 입출력 버스와 저속 입출력 버스로 분리하여 운영\n  고속 입출력 버스에는 고속 주변장치를 연결하고 저속 입출력 버스에는 저속 주변장치를 연결\n  두 버스 사이의 데이터 전송은 채널 선택기가 관리\n  입출력 버스로 감당하기 어려워진 그래픽카드는 입출력 버스에서 분리하고 메인버스에 바로 연결하여 사용\n  결론적으로 현대의 컴퓨터는 CPU와 메모리를 연결하는 메인버스, CPU와 그래픽카드를 연결하는 그래픽 버스, 고속 입출력 버스와 저속 입출력 버스를 사용\n image \n직접 메모리 접근 (. Memory Access)  image \n CPU의 도움 없이도 메모리에 접근할 수 있도록 입출력 제어기에 부여된 권한 입출력 제어기에는 직접 메모리에 접근하기 위한 DMA 제어기가 마련되어 있음 입출력 제어기는 여러 채널에 연결된 주변 장치로부터 전송된 데이터를 적절히 배분하여 하나의 데이터 흐름을 만듦 채널 선택기는 여러 채널에서 전송된 데이터 중 어떤 것을 메모리로 보낼지 결정  입출력과 인터럽트  인터럽트는 주변장치의 입출력 요구나 하드웨어의 이상 현상을 CPU에 알려주는 역할을 하는 신호 각 장치에는 IRQ라는 고유의 인터럽트 번호가 부여되어 있음 인터럽트가 발생하면 CPU는 IRQ를 보고 어떤 장치에서 인터럽트가 발생했는지 파악  인터럽트의 종류  외부 인터럽트 : 입출력장치로부터 오는 인터럽트뿐 아니라 전원 이상이나 기계적인 오류 때문에 발생하는 인터럽트를 포함 내부 인터럽트 : 프로세스의 잘못이나 예상치 못한 문제 때문에 발생하는 인터럽트 시그널 : 사용자가 직접 발생시키는 인터럽트 (일반적으로는 인터럽트로 분류하지는 않음)  인터럽트 백터  image \n 여러 인터럽트 중 어떤 인터럽트가 발생했는지 파악하기 위해 사용하는 자료 구조 인터럽트 벡터의 값이 1이면 인터럽트가 발생했다는 의미  인터럽트 핸들러  인터럽트의 처리 방법을 함수 형태로 만들어놓은 것 운영체제는 인터럽트가 발생하면 인터럽트 핸들러를 호출하여 작업함 사용자 인터럽트인 시그널의 경우 자신이 만든 인터럽트 핸들러를 등록할 수도 있음  버퍼  image \n 속도가 다른 두 장치 속도 차이를 완화하는 역할을 하는 저장 공간 이중 버퍼를 사용하면 한 버퍼는 데이터를 담는 용도로 쓰고 또 한 버퍼는 데이터를 가져가는 용도로 쓸 수 있어 유용  하드웨어 안전 제거  image \n 버퍼가 다 차지 않으면 버퍼가 다 찰 때까지 입출력장치에 자료가 전송되지 않는데, 이 상태에서 저장장치를 제거하면 버퍼 안의 데이터가 저장되지 않는 문제가 발생 하드웨어 안전 제거를 사용하면 버퍼가 다 차지 않아도 강제로 버퍼의 내용이 저장장치로 옮겨짐 (플러시)   ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%8B%9C%EC%8A%A4%ED%85%9C/","title":"운영체제 - 입출력 시스템"},{"content":"파일 시스템\n파일 시스템 파일 시스템  image \n 사용자가 직접 파일을 보관하는 대신 파일 관리자를 두어 저장 장치의 관리를 맡기는 시스템 파일 관리자가 파일 테이블을 사용하여 파일을 관리 사용자가 특정 파일에 접근하려면 파일 관리자로부터 파일에 접근할 수 있는 권한을 획득해야 함   image  r  image \n (운영체제 입장에서) 블록은 저장장치에서 사용하는 가장 작은 단위로, 한 블록에 주소 하나가 할당 블록은 여러 개의 섹터로 구성되며 블록의 크기는 시스템마다 다름 블록 크기를 작게 설정하면 내부 단편화 현상이 줄어들어 저장장치를 효율적으로 쓸 수 있지만, 파일이 여러 블록으로 나뉘어 파일 입출력 속도가 느려짐 큰 파일을 많이 사용할 때는 블록 크기를 크게 잡는 것이 좋음  파일 속성의 종류  image \n파일 헤더와 고유 헤더  image \n 파일 헤더 : 파일 테이블에서 관리하며 파일의 이름, 종류, 크기, 시간, 접근 권한 등과 같은 일반적인 내용과 파일이 저장장치의 몇 번째 블록에 있는지에 대한 정보를 가지고 있음 고유 헤더 : 데이터 파일에는 응용 프로그램이 직접 관리하는 고유 헤더가 따로 달려 있는데 파일의 버전 번호, 크기, 특수 정보 등 응용 프로그램이 필요로 하는 정보가 있음  파일 작업의 종류  image \n순차 파일 구조  image \n  파일 내용이 하나의 긴 줄로 늘어선 형태\n  장점\n 모든 데이터가 순서대로 기록되기 때문에 저장 공간에 낭비되는 부분이 없음 구조가 단순하여 테이프는 물론 플로피디스크나 메모리를 이용한 저장장치에도 적용할 수 있음 순서대로 데이터를 읽거나 저장할 때 매우 빠르게 처리됨    단점\n 파일에 새로운 데이터를 삽입하거나 삭제할 때 시간이 많이 걸림 특정 데이터로 이동할 때 직접 접근이 어렵기 때문에 앞에서부터 순서대로 움직여야 하기 때문에 데이터 검색에 적당하지 않음  인덱스 파일 구조  image \n 인덱스 테이블을 이용하여 순차 접근과 직접 접근이 가능 현대의 파일 시스템은 인덱스 파일 구조로, 파일을 저장할 때는 순차 파일 구조로 저장하고 파일에 접근할 때는 인덱스 테이블을 보고 원하는 파일에 직접 접근  직접 파일 구조  image \n 저장하려는 데이터의 특정 값에 어떤 관계를 정의하여 물리적인 주소로 바로 변환하는 파일 구조 특정 함수(해시 함수)를 이용하여 직접 접근이 가능한 파일 구조 이때 사용하는 함수를 해시 함수hash function라고 함 실제로 많이 쓰이는 구조는 아님  직접 파일 구조의 장단점  해시 함수를 이용하여 주소를 변환하기 때문에 데이터 접근이 매우 빠름 전체 데이터가 고르게 저장될 수 있는 해시 함수를 찾기가 어려움 해시 함수를 잘 찾았다고 하더라도 저장 공간이 낭비되는 문제도 있음  디렉터리 파일  image \n 디렉터리도 파일임 일반 파일에는 데이터가 담기고 디렉터리에는 포함된 파일 정보가 담김 디렉터리 헤더에는 디렉터리의 이름, 만든 시간, 접근 권한 등의 정보가 기록됨 디렉터리 헤더에는 실제 내용이 담긴 블럭의 위치도 저장됨  해당 블럭으로 가면 실제 디렉터리 파일이 담고 있는 내용 (해당 파일들의 헤더들)이 저장되어 있음 이런식으로 디렉터리 헤더 → 디렉터리 내용 (파일 헤더 위치) → 파일 헤더 → 파일 내용 형식으로 내려간다고 보면 됨    마운트  유닉스에서 여러 개의 파티션을 통합하는 명령어   image \n image \n 논리적으로 통합하는 것이지, 실제 파일시스템, 파티션들이 통합되는 것은 아님    2개의 파티션을 하나의 파일 시스템으로 만든 예  image \n파일 내 블록을 연결하는 방식  연속 할당 방식  파일을 구성하는 데이터를 디스크상에 연속적으로 배열하는 간단한 방식 단점  파일을 저장하거나 삭제하다 보면 빈 공간이 생김 디스크에 남은 공간 중 파일의 크기와 맞는 연속된 공간이 없을 때는 연속 할당이 불가능 실제로 사용되지 않음     불연속 할당 방식  비어 있는 블록에 데이터를 분산하여 저장하고 이에 관한 정보를 파일 시스템이 관리하는 방식 연결 리스트를 이용한 연결 할당과 인덱스를 이용한 인덱스 할당이 대표적    불연속 할당 방식 연결 할당 방식  image \n 파일에 속한 데이터를 연결 리스트로 관리하는 방식 파일 테이블에는 시작 블록에 대한 정보만 저장  나머지 데이터는 시작 블록부터 연결 리스트를 이용해 연결하여 저장   체인으로 연결한 것처럼 보여서 체인 할당이라고도 함 연결리스트 방식과 윈도우의 FAT(. Allocation Table) 방식이 있음 단점  내용을 추가하거나 검색할 때 연결리스트를 하나하나 탐색해가야 하기 때문에 실제로 사용하지 않음    File Allocation Table (.) 방식  image \n 연결리스트에서 다음 블록을 가르키는 포인터 정보만 빼다가 테이블을 따로 만들었다고 생각하면 편함 테이블은 메모리에 올려놓고 계속 동기화를 시켜줌  자료구조 자체도 작고 테이블이 메모리 위에 있으므로 디스크 작업량 부하 없이 빠르게 탐색 가능   단점  어떠한 이유로 (시스템 다운, USB 비정상 추출) 메모리에 있는 파일 할당 테이블이 디스크의 파일 할당 테이블과 동기화되지 않는다면 파일 시스템에 오류 발생    인덱스 할당  image \n 테이블의 블록 포인터가 데이터 블록을 연결하는 것이 아니라, 데이터의 인덱스를 담고 있는 인덱스 블록(inode)을 연결 인덱스 블록은 실제 데이터의 위치에 관한 정보를 순서대로 보관 테이블이 꽉 차서 더 이상 데이터를 연결할 수 없을 때는 인덱스 블록을 연결하는 간접 인덱스 블록(. index block)을 만들어 테이블을 확장할 수 있음  즉 추가적인 인덱스 블록을 사용한다는 것   유닉스의 I-node가 이 방식을 사용 현재는 저널링 방식을 쓰는중. 예전에 쓰던 방식  인덱스 할당 방식의 예  image \n 예를들어 블록 포인터가 10개의 데이터 블록을 가르킬 수 있다면  만약 10개 이상의 데이터 블록을 가르켜야 한다면 간접 포인터를 통함  간접 포인터는 데이터 블록이 아니라 또다른 인덱스 블록을 가르킴      빈 공간 리스트  image \n 파일 시스템은 디스크의 빈 공간을 효율적으로 관리하기 위해 빈 블록의 정보만 모아놓은 빈 공간 리스트를 유지 파일 시스템에서는 파일 테이블의 헤더를 삭제하고 사용했던 블록을 빈 공간 리스트에 등록하는 것을 파일이 삭제된 것으로 간주 어떤 데이터를 지우고 새로운 데이터를 디스크에 넣을 때 방금 지워진 블록에 할당되는 것이 아니라 리스트에 있던 블록 중 맨 앞에 있는 블록에 할당  유닉스 파일 시스템의 접근 패턴  image \n 맨 앞자리는 파일의 종류를 나타냄 나머지 아홉 자리는 rwx라는 세 덩어리로 구성 rwx 덩어리 중  첫 번째 덩어리 : 파일의 소유자owner권한 부여 두 번째 덩어리 : 소유자가 속한 그룹group의 권한 부여 세 번째 덩어리 : 소유자도 아니고 같은 그룹도 아닌 제삼자others의 권한 부여    chmod  image \n","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C/","title":"운영체제 - 파일 시스템"},{"content":"파일, 파이프, 소켓 프로그래밍\n파일, 파이프, 소켓 프로그래밍 파일  아무리 큰 파일이라도 파일 내의 데이터는 개념적으로 한줄로 저장됨  파일 기술자  open() 함수로 파일을 열면 파일 기술자 fd를 얻음 파일 기술자는 파일 접근 권한 외에 offset 정보도 보관 처음 파일이 열리면 offset은 맨 앞 읽기 혹은 쓰기를 하면 offset은 계속 전진  파일을 이용한 통신  %E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF,%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B3,%20%E1%84%89%E1%85%A9%E1%84%8F%E1%85%A6%E1%86%BA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%208848e4dfa61e4194b37ece89c0fd9933/Untitled.png \n파이프를 이용한 통신  %E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF,%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B3,%20%E1%84%89%E1%85%A9%E1%84%8F%E1%85%A6%E1%86%BA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%208848e4dfa61e4194b37ece89c0fd9933/Untitled%201.png \n 파이프는 파일 기술자를 fd[2]와 같이 2개의 원소를 가진 배열로 정의 fd[0] = 읽기용 fd[1] = 쓰기용 해당 코드에서는 부모에서는 close(.[1]), 자식에서는 close(.[0]) 으로 해당 로직에서 쓰지 않는 파이프는 종료해주고 있다.  소켓을 이용한 네트워킹  %E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF,%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B3,%20%E1%84%89%E1%85%A9%E1%84%8F%E1%85%A6%E1%86%BA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%208848e4dfa61e4194b37ece89c0fd9933/Untitled%202.png \n %E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF,%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B3,%20%E1%84%89%E1%85%A9%E1%84%8F%E1%85%A6%E1%86%BA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%208848e4dfa61e4194b37ece89c0fd9933/Untitled%203.png \n %E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF,%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B3,%20%E1%84%89%E1%85%A9%E1%84%8F%E1%85%A6%E1%86%BA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%208848e4dfa61e4194b37ece89c0fd9933/Untitled%204.png \n","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%8C%8C%EC%9D%BC-%ED%8C%8C%EC%9D%B4%ED%94%84-%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","title":"운영체제 - 파일, 파이프, 소켓 프로그래밍"},{"content":"페이지 교체 알고리즘\n페이지 교체 알고리즘 페이지 교체 알고리즘  image \n 스왑 영역으로 보낼 페이지를 결정하는 알고리즘 메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정  페이지 부재를 줄이고 시스템의 성능 향상    페이지 교체 알고리즘의 성능 평가  image \n 다양한 방법이 있음 여기서는 페이지 부재 횟수, 페이지 성공 횟수를 비교 위는 첫번째는 A에 접근, 두번째는 B에 접근, 세번째는 C에 접근\u0026hellip;. 을 의미  무작위 페이지 교체 알고리즘  스왑 영역으로 쫓아낼 페이지를 무작위로 선정 지역성을 전혀 고려하지 않음  성능 좋지않다    FIFO 페이지 교체 알고리즘  image \n 시간상으로 메모리에 가장 먼저 올라온 페이지를 대상 페이지로 선정 메모리가 꽉 차면 맨 위 페이지가 스왑 영역으로 가고, 나머지 페이지들이 위쪽으로 이동하고 새 페이지가 아래쪽으로 들어옴  다만 실제로 페이지 테이블을 이렇게 재배치하는 것이 아님, 그냥 논리적으로 볼 때 그렇다는 것   무조건 오래된 페이지를 대상 페이지로 선정하므로 성능이 좋지않음 페이지 성공 횟수: 3  최적 페이지 교체 알고리즘  image \n 앞으로 사용하지 않을 페이지를 스왑 영역으로 옮김  앞으로 사용할 페이지를 미리 살펴봄 사용되는 시점이 제일 멀리 있는 페이지를 대상 페이지로 선정   페이지 성공 횟수 : 5 이상적인 방법이지만 실제로 구현할 수 없음  최적 근접 알고리즘의 접근 방식  image \n 최적에 근접한 성능 추구  실제 구현이 가능하면서도 최전 근접 알고리즘에 근접한 성능을 추구함   LRU 페이지 교체 알고리즘  Least Recently Used 페이지가 접근한 시간을 기준으로 대상 페이지 선정   LFU 페이지 교체 알고리즘  Least Frequently Used 페이지가 사용된 횟수를 기준으로 대상 페이지 선정    LRU 페이지 교체 알고리즘  최근 최소 사용 페이지 교체 알고리즘 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑 영역으로 보냄 시간을 기준으로 구현하거나 카운터나 참조 비트를 이용하기도 함  페이지 접근 시간에 기반한 구현  image \n 페이지에 접근한 지 가장 오래된 페이지를 교체 페이지 성공 횟수 : 4  카운터에 기반한 구현  구체적 설명 안해주심 그냥 카운터에 기반해서..  참조 비트 시프트 방식  image \n 각 페이지에 일정 크기의 참조 비트를 만들어 사용하는 것 참조 비트의 초깃값은 0이며 페이지에 접근할 때마다 1로 바뀜 참조 비트는 주기적으로 오른쪽으로 한 칸씩 이동 참조 비트를 갱신 하다가 대상 페이지를 선정할 필요가 있으면 참조 비트 중 가장 작은 값을 대상 페이지로 선정  되게 창의적이다    LFU 페이지 교체 알고리즘  image \n 페이지가 몇 번 사용 되었는지를 기준으로 대상 페이지를 선정 현재 프레임에 있는 페이지마다 그 동안 사용된 횟수를 세어 횟수가 가장 적은 페이지를 스왑 영역으로 옮김 실제로는 많이 사용되지 않음  과거에는 많이 사용되었는데, 예를 들어 변수를 초기화 한 후에 사용될 일이 없는데도 누적된 사용횟수 때문에 계속 남아잇는 경우가 있음    NUR 페이지 교체 알고리즘  LRU, LFU 페이지 교체 알고리즘은 추가적인 오버헤드가 큼 이를 개선한 NUR는 두 개의 비트만으로 구현 가능 ‘최근 미사용 페이지 교체 알고리즘’이라고도 불림  None Used Recently   페이지마다 참조 비트와 변경 비트를 가짐  참조 비트 : 페이지에 접근(/posts/페이지-교체-알고리즘/execute)하면 1이 됨 변경 비트 : 페이지가 변경(/posts/페이지-교체-알고리즘/append)되면 1이 됨   모든 페이지의 초기 상태는 (.,0), 모든 값이 (.,1)이면 초기화 함!   image \n 오버헤드가 작지만 성능은 LRU, LFU 알고리즘과 비슷  NUR 페이지 교체 알고리즘  image \n 대상 페이지를 찾을 때 참조 비트가 0인 페이지를 먼저 찾고, 없으면 변경 비트가 0인 페이지를 찾음 같은 비트의 페이지가 여러 개라면 무작위로 대상 페이지를 선정 페이지 성공 횟수 : 5  FIFO 변형 알고리즘 - 2차 기회 페이지 교체 알고리즘  image \n FIFO 페이지 교체 알고리즘과 마찬가지로 큐를 사용 특정 페이지에 접근하여 페이지 부재 없이 성공할 경우 해당 페이지를 큐의 맨 뒤로 이동하여 대상 페이지에서 제외 성공한 페이지를 큐의 맨 뒤로 옮김으로써 기회를 한 번 더 줌 페이지 성공 횟수 : 4  FIFO 변형 알고리즘 - 시계 알고리즘  image \n 2차 기회 페이지 교체 알고리즘은 큐를 사용하지만 시계 알고리즘은 원형 큐를 사용 스왑 영역으로 옮길 대상 페이지를 가리키는 포인터를 사용 포인터가 큐의 맨 바닥으로 내려가면 다음번에는 다시 큐의 처음을 가리키게 됨   image \n 2차 기회 페이지 교체 알고리즘에 비해 각 페이지에 참조 비트가 하나씩 추가 참조 비트의 초깃값은 0, 메모리에 있는 페이지를 성공적으로 참조하면 0에서 1로 변경 대상 포인터는 메모리가 꽉 찰 경우 스왑 영역으로 쫓겨날 페이지를 가리킴 가리키는 페이지가 스왑 영역으로 쫓겨 나면 대상 포인터를 밑으로 이동하는데 이때 참조 비트가 1인 페이지는 0으로 만든 후 건너 뜀 (.차기회를 줌) 페이지 성공 횟수 : 4 ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","title":"운영체제 - 페이지 교체 알고리즘"},{"content":"프로세스\n프로세스 1. 프로세스 프로그램  저장장치에 저장되어 있는 정적인 상태  프로세스  실행을 위해 메모리에 올라온 동적인 상태  2. 작업 방식 일괄 작업 방식  image \n 레스토랑에 테이블이 하나만 있는 것 큐를 사용 해 주문서를 받은 순서대로 요리 한 손님의 식사가 끝나야 다음 손님을 받을 수 있음  효율이 떨어짐    시분할 방식  image \n 요리사 한명이 시간을 적절히 배분해 여러 요리를 동시에 함 주문 목록에 있는 주문서 중 하나를 가져다가 요리 모든 요리가 제공되면 주문 목록에서 삭제  시분할 방식에서의 상황 처리  image \n3. 프로세스 제어 블록 (.) 개념  운영체제가 해당 프로세스를 위해 관리하는 자료 구조   image \n포함 내용  프로세스 구분자: 각 프로세스를 구분하는 구분자 메모리 관련 정보: 프로세스의 메모리 위치 정보 각종 중간값: 프로세스가 사용했던 중간값  4. 프로세스와 프로그램의 관계  프로그램이 프로세스가 된다는 것  운영체제로부터 프로세스 제어 블록을 얻는다는 것   프로세스가 종료된다는 것  해당 프로세스 제어 블록이 폐기된다는 것    5. 프로세스의 네 가지 상태  image \n  생성 상태\n 프로세스가 메모리에 올라와 실행 준비를 완료 프로세스 제어 블록을 할당받음    준비 상태\n 생성된 프로세스가 CPU를 얻을 때 까지 기다리는 상태    실행 상태\n 준비 상태에 있던 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행 중    완료 상태\n 실행 상태의 프로세스가 주어진 시간 동안 작업을 마침 프로세스 제어 블록 폐기    디스패치\n 준비 상태의 프로세스 중 하나를 골라 실행 상태로 바꾸는 CPU 스케줄러의 작업    타임아웃\n 프로세스가 자신에게 주어진 하나의 타임 슬라이스 동안 작업을 끝내지 못하면 다시 준비 상태로 돌아감    6. 프로세스의 다섯 가지 상태  image \n  생성 상태\n  준비 상태\n 프로세서 제어 블록은 준비 큐에서 기다리며 CPU 스케줄러에 의해 관리 CPU 스케줄러는 준비 상태에서 큐를 몇개 운영할지, 어떤 프로세스의 프로세서 제어 블록을 디스패치 할지 결정    실행 상태\n 실제 CPU를 얻어 실행중 주어진 시간, 즉 타임 슬라이스 동안만 작업 가능 타임 슬라이스를 다 사용하면 타임아웃 실행 상태 동안 작업이 완료되면 exit(.)가 실행되어 프로세스 종료 실행 상태 중 I/O가 요청되면 CPU는 입출력 관리자에게 입출력을 요청하고 block(.) 실행 해당 프로세스가 대기 상태로 옮긴 후 CPU 스케줄러는 새로운 프로세스를 디스패치    대기 상태\n 대기 상태의 프로세스는 입출력장치별로 마련된 큐에서 기다림 입출력이 완료되면 인터럽트 발생, 해당 인터럽트로 깨어날 프로세스를 찾는 wakeup(.) 발생    완료 상태\n 프로세스가 종료되는 상태 코드와 사용했던 데이터를 메모리에서 삭제 프로세스 제어 블록 폐기 오류 등 비정상적인 종료가 일어나면 디버깅을 위해 코어 덤프 실행    디스패치\n  타임아웃\n  블럭\n 입출력이 완료될 때 까지 작업을 진행할 수 없기에 해당 프로세스를 대기상태로 옮기는 작업    웨이크업\n 입출력이 완료되어 인터럽트가 발생하면, 해당 인터럽트로 깨어날 프로세스를 찾아 그 프로세스의 제어 블록을 준비 상태로 이동    코어 덤프\n 종료 직전의 메모리 상태를 저장장치로 옮기는 것    요약  image \n7. 기타 상태들 휴식 상태  유닉스 계열에서 프로그램을 실행하는 동안 Ctrl+Z를 누르면 볼 수 있음 프로세스가 작업을 일시적으로 쉬고 있는 상태 종료 상태가 아니기 때문에 원할 때 다시 시작할 수 있음  보류 상태  프로세스가 메모리에서 잠시 쫓겨난 상태  메모리가 꽉 차서 프로그램에 오류가 있어서 실행을 미루어야 할 때 바이러스와 같이 악의적인 프로세스라고 판단 매우 긴 주기로 반복되는 프로세스라서 입출력이 너무 지연될 때     image \n 보류-준비 상태  준비상태에서 보류되었으면 이쪽으로   보류-대기 상태  대기상태에서 보류되었거나 보류-대기 상태에서 입출력이 완료되어 인터럽트가 일어났다면 이쪽으로   ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/","title":"운영체제 - 프로세스"},{"content":"프로세스 제어\n프로세스 제어 1. 프로세스 제어 블록 (상세) 개념  프로세스를 실행하는데 필요한 중요한 정보를 저장하는 자료 구조 프로세스는 고유의 PCB를 가짐 프로세스 생성 시 만들어져 프로세스가 실행을 완료하면 폐기  프로세스 제어 블록의 구성  image \n 포인터  준비 상태나 대기 상태의 큐를 구현할 때 사용   프로세스 상태  어떤 상태에 있는지 나타냄 (준비, 대기, 실행\u0026hellip;)   프로세스 구분자  여러 프로세스를 구분하기 위함   프로그램 카운터  다음에 실행될 명령어의 위치를 가리킴 (.값)   프로세스 우선순위  프로세스의 실행 순서를 결정하는 우선순위   각종 레지스터 정보  프로세스가 실행되는 중에 사용하던 레지스터의 값   메모리 관리 정보  프로세스가 메모리의 어디에 있는지를 나타내는 메모리 위치 정보 메모리 보호를 위한 경계 레지스터, 한계 레지스터 값 등   할당된 자원 정보  프로세스를 위한 입출력 자원이나 오픈 파일 등에 대한 정보   계정 정보  계정 번호, CPU 할당 시간, CPU 사용 시간 등   부모 프로세스 구분자와 자식 프로세스 구분자  부모 프로세스를 가리키는 PPID와 자식 프로세스를 가리키는 CPID 정보    포인터  image \n 대기 상태에서는 같은 입출력을 요구한 프로세스끼리 연결할 때 포인터 사용 대기 큐는 링크드 리스트를 이용해 구현함  2. 문맥 교환 개요  image \n CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 과정 실행 상태에서 나가는 PCB에는 지금까지의 작업 내용을 저장 반대로, 실행 상태로 들어오는 PCB는 해당 내용을 읽어 그것을 기반으로 CPU를 다시 세팅  3. 프로세스의 구조  image \n image \n 코드 영역  프로그램의 본체가 있는 곳 프로그램의 코드가 기술 읽기 전용   데이터 영역  프로그램이 사용하려고 정의한 변수와 데이터가 있는 곳 코드가 실행되면서 사용하는 변수나 파일 등의 데이터를 모아놓음 읽기 쓰기 모두 가능   스택 영역, 힙 영역  운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳 프로세스 내에서 함수를 호출하면 함수를 수행하고 원래 프로그램으로 되돌아올 위치를 이 영역에 저장 파라미터, 로컬 변수도 이 곳에 저장됨 운영체제가 사용자의 프로세를 작동하기 위해 유지하는 영역  사용자에게는 보이지 않음   프로세스가 실행되는 동안 만들어지는 영역 동적 할당 영역  크기가 늘어나기도, 줄어들기도 함      스택 영역  스레드가 작동되는 동안 추가되거나 삭제되는 동적 할당 영역 스레드가 진행됨에 따라 커지기도, 작아지기도 함   image \n add(., b)를 호출했다  다음에 실행할 코드의 주소 ①과 add() 함수의 인자인 c, d를 스택 영역에 저장했다   add() 함수를 실행하며 mul(., d)를 호출했다  역시 다음에 실행할 코드의 주소인 ②와 mul() 함수의 인자인 e,f를 스택에 저장했다.   해당 함수가 종료되면 스택을 보고 (.) 어디로 돌아가야 할지 확인함  힙 영역  프로그램이 실행되는 동안 할당되는 변수 영역 포인터, malloc(), calloc()를 쓸때 해당 영역을 써서 메모리를 할당해줌  4. 프로세스의 생성 fork() 시스템 호출  실행 중인 프로세스로부터 새로운 프로세스를 복사 실행 중인 프로세스와 똑같은 프로세스가 하나 더 만들어짐 실행하던 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식 프로세스가 됨  fork() 시스템 호출의 동작 과정  image \n fork() 를 하면  부모 프로세스 영역의 대부분이 자식 프로세스에 복사  PCB 코드 영역 데이터 영역 스택 영역     단 PCB의 일부가 변경됨  프로세스 구분자 메모리 관련 정보 부모 프로세스 구분자와 자식 프로세스 구분자    fork() 시스템 호출의 장점  프로세스 생성 속도가 빠름 추가 작업 없이 자원 상속 시스템 관리를 효율적으로  fork() 시스템 호출의 예  image \n 부모 프로세스의 코드가 실행되어 fork() 문을 만나면 똑같은 내용의 자식 프로세스를 생성 이 때 fork() 문은  부모 프로세스에 0보다 큰 값을 반환 자식 프로세스에 0을 반환   만약 0보다 작은 값을 반환하면 자식 프로세스가 생성되지 않은 것으로 여겨 Error 출력  5. exec() 시스템 호출  image \nfork()  새로운 프로세스를 복사하는 시스템 호출  exec()  프로세스는 그대로 두고 프로세스의 내용만 바꾸는 시스템 호출 이미 만들어진 프로세스의 구조를 재활용하는 것  6. exec()의 동작 과정  image \n 코드 영역에 있는 기존의 내용을 지우고 새로운 코드로 바꿈 데이터 영역이 새로운 변수로 채워짐 스택 영역이 리셋됨 PCB의 내용 중 프로세스 구분자, 부모 프로세스 구분자, 자식 프로세스 구분자, 메모리 관련 사항은 변하지 않음 그러나 프로세스 카운터 레지스터 값을 비록한 각종 레지스터와 사용된 파일 정보들은 리셋됨  7. exec() 시스템 호출의 예  image \n exec()를 해도 PCB의 각종 프로세스 구분자 (., PPID, CPID)가 변경되지 않음  때문에 프로세스가 종료된 후 부모 프로세스로 돌아올 수 있다.   wait()  자식 프로세스가 종료할 때 까지 대기    8. 프로세스의 계층 구조  image \n 유닉스의 모든 프로세스는 init 프로세스의 자식임 트리 구조를 이룬다 쉘에서 어떤 프로그램을 실행할 때도 fork() 후 exec()를 하는 방식이다  프로세스 계층 구조의 장점  여러 작업을 동시에 처리할 수 있다 프로세스의 재사용이 용이하다 자원 회수가 쉽다  프로세스 간의 책임 관계가 분명해져서 시스템을 관리하기 수월    좀비 프로세스  프로세스가 종료된 후에도 커널에 프로세스 정보가 비정상적으로 남아있는 프로세스 자식 프로세스가 종료되었지만 부모 프로세스가 wait()를 하지 않음  따라서 부모 프로세스가 커널이 정리작업을 하도록 하지 않음    미아 프로세스  자식 프로세스 종료 전 부모 프로세스가 종료한 경우 발생 이럴 경우 init 프로세스가 내부적으로 wait()를 해줌  미아 프로세스가 좀비 프로세스가 되는 것을 방지하기 위함    9. exit()와 wait() exit() 시스템 호출  작업의 종료를 알려줌 자식 프로세스가 exit()를 호출함으로써, 부모 프로세스는 자식 프로세스가 사용하던 자원을 빨리 거둬갈 수 있음 exit() 함수가 전달하는 인자로 자식 프로세스가 어떤 상태로 종료되었는지 알려줄 수 있음  exit(.) = 정상종료 exit(-1) = 비정상정료    wait() 시스템 호출  자식 프로세스가 끝나기를 기다렸다가 자식 프로세스가 종료되면 다음 문장을 실행 자식이 미아 프로세스가 되는 것을 막아줌  부모 프로세스가 자식 프로세스보다 빨리 끝나지 않도록 해줌    쉘에서 프로그램을 실행시킬 때  image \n foreground에서 실행시킬 경우  wait() 함수를 사용함 그래서 다음 명령어를 입력할 수 없는 것   background에서 실행시킬 경우  wait() 함수를 사용하지 않음 그래서 다음 명령어를 입력할 수 있음   ","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4/","title":"운영체제 - 프로세스 제어"},{"content":"하드디스크와 CD, 파티션\n하드디스크와 CD, 파티션 하드디스크의 구조  %E1%84%92%E1%85%A1%E1%84%83%E1%85%B3%E1%84%83%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%AA%20CD,%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20d995162ccefc4e05b292aea1857c4d9a/Untitled.png \n플래터  표면에 자성체가 발려 있어 자기를 이용하여 0과 1의 데이터를 저장할 수 있음 플래터의 표면이 N극을 띠면 0으로, S극을 띠면 1로 인식 보통 2장 이상으로 구성되며 항상 일정한 속도로 회전  섹터와 블록  섹터  하드디스크의 가장 작은 저장 단위 하나의 섹터에는 한 덩어리의 데이터가 저장   블록  하드디스크와 컴퓨터 사이에 데이터를 전송하는 논리적인 저장 단위 중 가장 작은 단위 블록은 여러 개의 섹터로 구성되며, 윈도우 운영 체제에서는 블록 대신 클러스터라고 표현   하드디스크 입장에서는 섹터가 가장 작은 저장 단위 운영체제 입장에서는 하드디스크에 데이터를 보내거나 받을 때 블록이 가장 작은 저장 단위  트랙과 실린더  %E1%84%92%E1%85%A1%E1%84%83%E1%85%B3%E1%84%83%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%AA%20CD,%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20d995162ccefc4e05b292aea1857c4d9a/Untitled%201.png \n 트랙 : 플래터에서 회전축을 중심으로 데이터가 기록되는 동심원, 즉 동일한 동심원상에 있는 섹터의 집합 실린더 : 개념적으로 여러 개의 플래터에 있는 같은 트랙의 집합  헤드와 플래터  %E1%84%92%E1%85%A1%E1%84%83%E1%85%B3%E1%84%83%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%AA%20CD,%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20d995162ccefc4e05b292aea1857c4d9a/Untitled%202.png \n 하드디스크에서 데이터를 읽거나 쓸 때는 읽기/쓰기 헤드를 사용 플래터가 회전을 시작하면 표면에 약한 바람이 일어나는데, 헤드는 이 바람에 의해 표면에서 약간 떠 있는 형태로 작동 플래터의 표면에 생긴 상처는 데이터를 저장할 수 없는 배드 섹터가 됨  CD  휴대할 수 있는 소형 원반에 데이터를 저장 하드디스크와 마찬가지로 트랙과 섹터로 구성되며, 수평으로 움직이는 헤드가 트랙 사이를 움직이면서 데이터를 읽음 표면에 미세한 홈이 파여 있어 헤드에서 발사된 레이저가 홈에 들어가 반사가 되지 않으면 0으로, 반사되어 돌아오면 1로 인식  하드디스크와 CD의 디스크 회전  %E1%84%92%E1%85%A1%E1%84%83%E1%85%B3%E1%84%83%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%AA%20CD,%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20d995162ccefc4e05b292aea1857c4d9a/Untitled%203.png \n 각속도 일정 방식 (하드디스크)  하드디스크의 플래터는 항상 일정한 속도로 회전하여 바깥쪽 트랙의 속도가 안쪽 트랙의 속도보다 훨씬 빠르므로 가장 바깥쪽에 있는 섹터가 가장 안쪽에 있는 섹터보다 더 큰데, 일정한 시간 동안 이동한 각도가 같다는 의미에서 이러한 방식을 각속도 일정이라고 함   선속도 일정 방식 (.)  CD에서 사용하는 선속도 일정 방식은 어느 트랙에서나 단위 시간당 디스크의 이동 거리가 같은데, 이를 구현하려면 헤드가 안쪽 트랙에 있을 때는 디스크의 회전 속도를 빠르게 하고, 헤드가 바깥쪽 트랙으로 이동했을 때는 디스크의 회전 속도를 느리게 해야 함    하드디스크와 CD의 섹터 각속도 일정 방식의 섹터  각속도 일정 방식의 하드디스크는 트랙마다 속도가 다르기 때문에 섹터의 크기도 다름 장점 : 디스크가 일정한 속도로 회전하기 때문에 구동 장치가 단순하고 조용하게 작동 단점 : 모든 트랙의 섹터 수가 같고 바깥쪽 섹터의 크기가 안쪽 섹터보다 커서 안쪽 트랙에 비해 바깥쪽 트랙으로 갈수록 낭비되는 공간이 생김  선속도 일정 방식의 섹터  선속도 일정 방식의 CD는 모든 트랙의 움직이는 속도가 같고 섹터의 크기도 같아서 안쪽 트랙보다 바깥쪽 트랙에 더 많은 섹터가 존재(모든 트랙의 섹터 수가 다름) 장점 : CD는 한정된 공간에 많은 데이터를 담을 수 있고 하드디스크처럼 바깥쪽 트랙의 섹터 공간이 낭비되는 문제가 없음 단점 : 모터 제어가 복잡하고 소음이 발생  하드디스크에서 데이터를 전송하는 과정  %E1%84%92%E1%85%A1%E1%84%83%E1%85%B3%E1%84%83%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%AA%20CD,%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20d995162ccefc4e05b292aea1857c4d9a/Untitled%204.png \n디스크 장치 관리 파티션  디스크를 논리적으로 분할하는 작업 파티션 하나에 하나의 파일 시스템이 탑재 하드디스크가 2개라면 첫 번째 하드디스크와 두 번째 하드디스크가 별도의 파티션으로 보임 대용량 하드디스크의 경우 하나로 사용하기보다 여러 개로 나누어 사용하면 관리하기가 편함 여러 개의 하드디스크를 하나의 파티션으로 통합하여 사용하기도 함  마운트  유닉스 운영체제에서 여러 개의 파티션을 하나로 통합하는 기능  파티션 구성 예제  %E1%84%92%E1%85%A1%E1%84%83%E1%85%B3%E1%84%83%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%AA%20CD,%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20d995162ccefc4e05b292aea1857c4d9a/Untitled%205.png \n포매팅  디스크에 파일 시스템을 탑재하고 디스크 표면을 초기화하여 사용할 수 있는 형태로 만드는 작업 빈 저장장치에 파일 테이블을 탑재   %E1%84%92%E1%85%A1%E1%84%83%E1%85%B3%E1%84%83%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%AA%20CD,%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20d995162ccefc4e05b292aea1857c4d9a/Untitled%206.png \n빠른 포매팅과 느린 포매팅  하드디스크를 처음 사용할 때는 느린 포매팅을 하고, 하드디스크를 사용하다가 다시 포매팅을 해야 할 때는 빠른 포매팅을 하면 됨  빠른 포매팅 : 데이터는 그대로 둔 채 파일 테이블을 초기화하는 방식 느린 포매팅 : 디스크에 파일 시스템을 탑재하고 디스크 표면을 초기화하는 방식    조각모음  하드디스크에 조각이 많이 생기면 큰 파일이 여러 조각으로 나뉘어 저장되고 이를 읽기 위해 하드디스크의 여러 곳을 돌아다녀야 하기 때문에 성능 저하로 이어짐 하드 디스크는 주기적으로 조각 모음을 해주어야 함   %E1%84%92%E1%85%A1%E1%84%83%E1%85%B3%E1%84%83%E1%85%B5%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%AA%20CD,%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B5%E1%84%89%E1%85%A7%E1%86%AB%20d995162ccefc4e05b292aea1857c4d9a/Untitled%207.png \n","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%95%98%EB%93%9C%EB%94%94%EC%8A%A4%ED%81%AC%EC%99%80-cd-%ED%8C%8C%ED%8B%B0%EC%85%98/","title":"운영체제 - 하드디스크와 CD, 파티션"},{"content":"하드웨어의 구성\n하드웨어의 구성 1. 하드웨어의 구성 CPU  명령어를 처리  RAM  작업에 필요한 프로그램과 데이터를 저장하는 장소 바이트 단위로 분할되어 있으며 분할 공간마다 주소로 구분  입출력장치 저장장치 메인보드  다양한 장치들을 bus로 연결한다  2. 폰 노이만 구조  CPU, 메모리, 입출력장치, 저장장치가 버스로 연결되어 있는 구조 프로그램은 하드디스크 등의 저장장치에 저장 하드디스크에서 프로그램을 직접 실행할 수 없고 메모리로 가져와야 실행 가능 그러므로 메인 메모리의 관리가 중요한 포인트 메모리가 작을수록 동시에 실행할 수 있는 프로그램이 적어지므로 컴퓨터가 느려진다  3. 하드웨어 사양 관련 용어 클럭  일정 간격으로 tick을 만들어 CPU 구성요소들이 이에 맞춰 작업 클록틱, 펄스라고도 함  헤르츠  클록틱이 발생하는 속도를 나타내는 단위 1초에 1000번이면 1000Hz (1kHz)  시스템 버스  메모리와 주변 장치를 연결하는 버스, FSB Front Side Bus 라고 함  CPU 내부 버스  CPU 내부에 있는 장치들을 연결하는 버스. BSB Back Side Bus 라고 함  CPU와 메모리의 속도  CPU는 CPU 내부 버스의 속도로 작동하고 메모리는 시스템 버스의 속도로 작동 일반적으로 CPU 내부 버스의 속도가 더 빠르다 두 버스의 속도 차이로 인해 작업이 지연되며, 이 문제를 Cache로 해결  4. CPU의 구성과 동작 산술논리 연산장치 (ALU)  AND, OR과 같은 논리연산과 덧셈, 뺄셈같은 산술 연산을 수행  제어장치  CPU에서 작업을 지시  레지스터  CPU 내에 데이터를 임시로 보관  5. CPU의 명령어 처리 과정  고급 언어로 스크립트를 짜서 컴파일하면 저수준 언어인 어셈블리어로 변환 CPU는 어셈블리어를 해석해 명령어 수행   image \n image \n프로그램 상태 레지스터의 역할  연산 결과가 음수인지 아닌지, 0이 아닌지, 자리 올림이 있는지 등의 프로그램의 상태를 저장   image \n D2-D3의 결과를 임시로 저장하고 있다가 해당 상태를 제어장치에 알려주어 다음에 몇번 행으로 이동할지를 결정  6. 버스의 종류 💥  버스의 종류와 특징, 양방향인지 단방향인지 외워둘 것\n  image \n image \n버스의 대역폭  한번에 전달 가능한 데이터의 최대 크기 CPU가 한 번에 처리할 수 있는 데이터의 크기와 같다 CPU가 한 번에 처리할 수 있는 최대 데이터의 크기를 word라고 부름 32bit CPU는 메모리에서 데이터를 읽거나 쓸 때 한번에 최대 32bit를 처리할 수 있음. 이 경우 레지스터의 크기도 32bit, 버스의 대역폭도 32bit. 버스의 대역폭, 레지스터의 크기, 메모리에 한 번에 저장할 수 있는 데이터의 크기는 동일  7. 메모리의 종류  image \n휘발성 메모리  DRAM  저장된 0과 1의 데이터가 시간이 지나면 사라지므로 일정 시간마다 다시 재생시켜야 한다   SRAM  전력이 공급되는 동안에는 데이터를 보관할 수 있어 재생할 필요 없음   SDRAM  클록틱이 발생할 때 데이터를 저장하는 동기 DRAM    비휘발성 메모리  플래시 메모리 SSD  롬의 종류  마스크 롬  데이터를 지우거나 쓸 수 없음   PROM  전용 기게를 이용해 데이터를 한 번만 저장할 수 있음   EPROM  데이터를 여러 번 쓰고 지울 수 있음    8. 메모리 보호의 필요성  현대 운영체제는 시분할 기법을 사용해 여러 프로그램을 동시에 실행 메모리를 보호하지 않으면 어떤 작업이 다른 작업의 영역을 침범해 크래시를 일으킬 수 있음   image \n즉, 프로그램 작업영역을 한정해두고 이를 벗어나는 행동이 일어나면 운영체제가 프로그램을 강제 중단한다는 것.\n9. 부팅  컴퓨터를 켰을 때 운영체제를 메모리에 올리는 과정 Bootstraping의 약자   image \n 마스터 부트 레코드에 있는 부트스크랩 코드를 올려서 실행  부트스트랩 코드는 하드디스크에 있는 운영체제 프로그램을 실행    10. 버퍼 버퍼  속도에 차이가 있는 두 장치에서 그 차이를 완화하는 역할을 함 두 장치 사이에서 일정량의 데이터를 모아서 옮겨 속도의 차이를 완화 예를들어 A장치가 빠르고 B장치가 느리다면, A장치는 B장치가 다른 작업을 하는 동안 버퍼에 데이터를 넘기고 자신도 다른 작업을 할 수 있다.  스풀  CPU와 입출력장치가 독립적으로 동작하도록 고안된 소프트웨어적인 버퍼 예시) 프린터 스풀  스풀이 없다면 예를들어 워드에서 프린팅을 할 경우 프린팅이 완료될 때 까지 워드 프로그램은 프리징 상태가 되어버릴 것이다.    캐시  메모리와 CPU간의 속도 차이 (BSB, FSB 사이의) 를 완화하기 위해 메모리의 데이터를 미리 가져와 저장 CPU가 앞으로 사용할 것으로 예상되는 데이터를 미리 가져다놓음 CPU는 메모리에 접근해야 할 때 캐시를 먼저 방문해 원하는 데이터가 있는지 찾아봄  캐시의 구조   캐시 히트\n 캐시에서 원하는 데이터를 찾는 것    캐시 미스\n 원하는 데이터가 캐시에 없으면 메모리로 가서 데이터를 찾음    캐시 적중률\n 캐시 히트가 되는 비율 일반적인 캐시 적중률은 약 90%   image \n  캐시 적용 예  L1 캐시만 사용 가정 캐시 접근 시간 = 10 메모리 접근 시간 = 100 캐시 적중률 = 80%  즉 캐시를 80% 사용하고 나머지 20% 경우에만 메모리에서 가져온다는 뜻   메모리만 사용하는 경우 평균 접근시간 = 100 캐시 사용시 평균 접근시간 = 30  $$(0.8\\times10)+(0.2\\times100) = 28$$\n캐시의 쓰기 방식 즉시 쓰기  캐시에 있는 데이터가 변경되면 이를 메모리에 즉시 반영하는 방식 메모리와의 빈번한 전송으로 성능이 느려짐 메모리의 최신 값이 항상 유지. 갑작스러운 정전에도 데이터를 잃어버리지 않음  지연 쓰기  실시간으로 변경하지 않고, 캐시에서 변경된 내용을 주기적으로 확인해 메모리에 반영 카피백 이라고도 함 메모리와 데이터 전송 횟수가 줄어들어 시스템의 성능 향상 메모리와 캐시된 데이터 사이의 불일치가 발생할 수 있음  L1 캐시와 L2 캐시  image \n일반 캐시  명령어와 데이터의 구분 없이 모든 자료를 가져옴 메모리와 연결되기 때문에 L2 (Level 2) 캐시라고 부름  특수 캐시  명령어와 데이터를 구분하여 가져옴 CPU 레지스터에 직접 연결되기 때문에 L1 (Level 1) 캐시라고 부름  11. 저장장치의 계층 구조 개념  속도가 빠르고 값이 비싼 저장장치를 CPU 가까운 쪽에 싸고 용량이 큰 저장장치를 반대쪽에 배치하여 빠른 속도와 큰 용량을 적절한 가격으로 얻는 것  장점  CPU와 가까운 쪽에 레지스터나 캐시를 배치해 작업이 빨리 이루어지도록 함 메모리에서 작업한 내용을 하드디스크같이 저렴하고 용량이 큰 저장장치에 영구적으로 저장   image \n","date":"2020-09-18T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%9D%98-%EA%B5%AC%EC%84%B1/","title":"운영체제 - 하드웨어의 구성"},{"content":"컴퓨터 네트워크 - 이메일과 DNS\nComputer-Netowork-Email-and-DNS E-mail 세 주요 컴포넌트  User Agents 메일 서버 SMTP (Simple Mail Transfer Protocol)  User Agent  메일 리더 메일을 쓰고, 편집하고, 읽음 Outlook, Thunderbird 등 들어오고 나가는 메세지들은 서버에 저장됨  메일 서버  Mailbox  유저에게 온 메세지들을 담음   Message Queue  보내질 메세지들을 일시적으로 담는 큐   SMTP 프로토콜  메일 서버간에 이메일 메세지들을 보낼 때 사용됨 클라이언트: 메세지를 전송하는 메일 서버 서버: 메세지를 받는 메일서버    SMTP  TCP  신뢰성 있는 전송을 위해 25번 포트   Direct Transfer  직접 TCP 연결을 통해 메일 서버들이 통신하며 메세지를 주고받음   단계  Handshaking 메세지 전송 통신 종료   Command/Response Interaction  HTTP와 유사 commands: ASCII response: 상태 코드 등   메세지는 반드시 7bit ASCII로 되어 있어야 함 Persistent connection을 사용 메세지의 끝은 .로 구분  EOL=CRLF=New Line    메일이 보내지는 과정  Alice가 UA를 통해 메세지 작성 Alice의 UA는 메일 서버에게 메세지를 보냄 해당 메세지는 메일 서버의 Message Queue에 들어감 Alice의 메일 서버가 SMTP를통해 TCP 연결 요청 → Bob의 메일 서버로 SMTP 클라이언트 (Alice의 메일 서버)는 TCP 연결을 통해 Bob의 메일 서버에 메세지 전송 Bob의 메일 서버는 Bob의 메일박스에 메세지 저장 Bob은 UA를 사용해 메세지 확인  SMTP와 HTTP 비교  HTTP: 데이터를 Pull SMTP: 데이터를 Push 양쪽 모두 ASCII 기반 command/response interaction과 status code를 사용 HTTP는 각각의 오브젝트가 하나의 Response 메세지에 포함되어 전송 SMTP는 각각의 오브젝트가 여러개의 메세지에 담겨 전송될 수 있음  Mail Message Format  image \nMail Access Protocols  메일 서버에서 UA를 통해 메세지를 가지고 올 때 사용\n  POP IMAP  POP보다 더 많은 기능   HTTP  Google, Hotmail 등    POP3  image \n Download and Delete Mode  메세지를 읽으면 서버에서는 삭제된다   Download and Keep Mode  메세지를 읽어도 메세지의 사본이 서버에 유지된다   POP3 = Stateless  지난 연결에 대한 상태 정보를 가지고 있지 않다    IMAP  모든 메세지가 한곳 (서버) 에 저장된다 유저가 메세지들을 폴더를 통해 관리할 수 있다 상태 정보를 유지  폴더 이름 메세지 ID와 폴더 이름의 매핑 등    3. DNS (Domain Name System)  IP 주소와 도메인 네임을 어떻게 연결하는가?\n  분산된 데이터베이스  네임 서버로 이루어진 계층화된 시스템   애플리케이션 프로토콜  호스트와 네임서버가 통신 코어 인터넷 펑션이지만 애플리케이션 단에서 구현  코어 단에서 구현하면 너무 복잡해지기 때문      DNS Services  Hostname을 IP 주소로 변환 Host aliasing  Canonical (실제) Hostname과 더불어 별도의 alias names을 관리 예) w2.east-asia.ibmserver.com → www.ibm.com   트래픽 분산  한 HostName을 여러개의 IP 주소에다 배정할 수 있다.  DNS가 로드 밸런싱도 해주네     왜 중앙집중화 되어있지 않나  어떤 재해로 인해 모든 지구상 호스트가 해당 DNS 서버에 접속불가라면?  끔찍하지..   해당 주변의 네트워크 트래픽 관리를 위해 DNS서버가 먼 해외에 있다면?  인터넷 접속에 지연이 심해질 것   유지보수를 위해  단 하나의 DNS 서버만 존재한다면 서버를 끄기가 조심스러워 지겠지   즉 확장성이 없다!    DNS 계층 구조  image \nRoot name servers  DNS query를 받은 로컬 DNS 서버가 hostname을 알지 못할 때 질의받음 얘도 모를 경우 Authoritative name server에 질의함  TLD (Top-Level Domain) servers  최상위 도메인 (TLD) 관련하여 책임짐  Authoritative DNS server  기관이나 인터넷 서비스 운영자가 운영, 관리 자기들이 이름붙인 호스트들과 그 IP들을 매핑하는 정보를 관리  Local DNS name server  계층에 그렇게 단단히 구성되어 있지는 않다 각각의 ISP는 하나 이상의 DNS를 가지고 있다 호스트에서 DNS query를 받으면  먼저 캐시를 살펴봐서 정보가 있다면 그걸로 응답 (권위 없는 응답) 만약 캐시에 없다면 프록시로 동작, 다른 DNS 서버에 query를 포워딩 캐시 된 정보는 out of date 된 정보일 수도 있다    4. DNS Name Resolution 과정 Iterated Query  image \n \u0026ldquo;나는 잘 모르겠으니 이 서버에다가 물어봐\u0026rdquo;\n  호스트가 로컬 DNS 서버에 질의  \u0026ldquo;나 mail.naver.com에 접속하고 싶은데 IP 뭐야\u0026rdquo;   로컬 DNS 서버에 해당 정보 캐시가 없으면 Root에 질의 Root에도 없으면 Root가 말함  \u0026ldquo;나는 잘 모르겠으니 TLD DNS server (com) 에다 물어봐\u0026rdquo; 하고 해당 정보를 알려줌   로컬 DNS 서버는 그 정보를 가지고 TLD DNS server에 질의 TLD DNS server에도 없으면 TLD 서버가 말함  \u0026ldquo;나는 잘 모르겠으니 Authoritative DNS server (naver.com) 에다 물어봐\u0026rdquo; 하고 해당 정보를 알려줌   Authoritative DNS server는 실제 해당 매핑을 관리하는 주체이기 때문에 무조건 알고있음 (권위 있는 응답) 로컬 DNS 서버는 최종 응답을 받았고 그 정보를 호스트에다가 전달해줌  Recursive Query  image \n \u0026ldquo;로컬 DNS 서버도 다음 DNS 서버에 하청을 준다\u0026rdquo;\n  호스트가 로컬 DNS 서버에 질의 로컬 DNS에 해당 정보 캐시가 없으면 Root에 질의 Root에도 없으면 Root가 TLD DNS server에 질의 TLD DNS server에도 없으면 TLD DNS server가 Authoritative DNS server에 질의 이렇게 Recursive하게 응답을 받고 받고 받아서 로컬 DNS 서버가 호스트에게 최종응답 전달  DNS 캐싱  네임 서버가 HostName-IP 매핑을 알게 되면 캐시함  단 TTL이 있다   이 캐시 정보가 오래된 정보일 수 있음  도메인 할당할때 많이 겪어봤지?   당장 업데이트 해달라고 요쳥할 수도 있음  RFC2136    DNS 레코드  RR = 네임 서버가 관리하는 DNS 데이터 엔트리\n  RR Format = (name, value, type, TTL)\n Type A  name : hostname value: IP address ex) (www.naver.com, 152.142.67.41, A, 100)  Type NS  name: domain value: 해당 도메인을 관리하고 있는 네임 서버를 지정  웹호스팅이나 Cloudflare할 때 네임서버 지정했던거   ex) (naver.com, ns1.cloudflare.com, NS, 100)  Type CNAME  name: 별명 정보 value: 실제 (canonical) 도메인 ex) (www.ibm.com, w3.east.asia.ibm.com, CNAME, 100)  Type MX  value: name에 연결될 메일 서버의 주소 ex) (ibm.com, mail.ibm.com, MX, 100)  DNS 프로토콜 메세지 구조  Query와 Reply 메세지가 있으며, 둘은 같은 메세지 포맷을 공유한다.\n  image \n메세지 헤더  Identification  DNS query와 해당 query를 위한 reply는 같은 값의 Identification을 가진다.   Flags  query 메세지다 reply 메세지다 Recursion 방식으로 해주세요 Recursion 방식이 가능하다 Reply가 Authoriative이다 (캐시된 정보가 아니다)   Questions  Query 내용   Answers  RR 형태로 답이 옴    DNS 레코드 넣기  사설 네임서버를 쓸 만큼 큰 회사라고 가정했을 때\n  DNS 등록자에게 내 도메인과 네임서버 정보 등록  도메인, Authoritative name server, IP address 제출 (mydomain.com, ns1.mydomain.com, NS, 1600) (ns1.mydomain.com, 222.111.212.111, A, 1600)   사설 네임서버 안에서 www.mydomain.com에 연결할 IP라던가 MX로 메일서버를 연결한다던가 하면 됨 ","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-email-and-dns/","title":"Computer Networking - Email and DNS"},{"content":"Computer Networking - Final Quick Note\nComputer-Network-Final-Quick-Note Reliable Data Transfer (RDT)  image \n udt_send()와 deliver_dat()는 RDT에서 직접 호출  ACTION 이라고 지칭   rdt_send()는 application layer에서, rdt_rcv()는 underline channel에서 호출  EVENT 라고 지칭    RDT 1.0 : Reliable tranfer on reliable channel  image \n 하위 채널도 완벽한 Reliable  비트 에러 없음 패킷 로스 없음   그러나 실제로는 하위 채널은 Reliable 하지 않음  RDT 2.0 : Channel with bit errors  image \n 하위 채널이 Reliable 하지 못함  비트 에러가 있을 수 있음   비트 에러 복구 방법  Acks NAKs  Receiver가 Sender에게 명시적으로 패킷에 에러가 있음을 알려줌   Sender는 NAKs를 받으면 패킷 재전송   RDT 2.0에서의 새 매커니즘  에러 디텍트 피드백 (ACK, NAK)    RDT 2.0 문제 : 만약 ACK, NAK가 Corrupted?  Sender는 Receiver에게 무슨 일이 일어났는지 알 수 없음 무작정 재전송하긴 힘듬  ACK을 받아야 위쪽에서 오는 데이터를 대기할 수 있음 ACK가 와서 인식되지 않으면 같은 패킷만 계속 재전송   Duplicate 막기  Sender는 각 패킷에 Seq Number 기입해둠 Receiver는 그 Seq Number를 보고 이미 받은 패킷이면 Discard 시킴    Stop and Wait Protocol  Sender는 한 패킷을 보내고 Receiver의 리스폰스를 기다림 아래 RDT들은 모두 Stop and Wait Protocol 사용 (ACK를 기다림)  RDT 2.1 : Seq Number로 중복 방지  image \n sndpkt = make_pkt(0, data, ckecksum), sndpkt = make_pkt(1, data, ckecksum)으로 sequence number까지 보내주는 모습 corrupt(rcvpkt)||isNAK(rcvpkt) 으로 ACK 혹은 NAK corrupt 체크  corrupt 되었다면 일반 NAK같이 치부함   Twice as many states (만약 seq가 2개라면 4개의 상태가 필요하다는 뜻)  State must remember whether expected packet should have seq number of 0 or 1     image \n Receiver는 받은 패킷이 중복된 패킷인지 체크해야 한다  0번의 패킷을 기다리는데 1번이 오거나, 1번의 패킷을 기다리는데 0번이 오면 extract 하지 않고 바로 ACK 패킷을 만들어 보내는 모습.  즉 Discard 해버린다     Receiver는 Sender가 ACK|NAK을 잘 전달받았는지 알지 못함  RDT 2.2 : NAK-FREE Protocol  image \n ACK만 사용 기다리고 있는 것과 다른 Seq Number를 가진 ACK가 오면 NAK를 받은 것 처럼 처리  RDT 3.0 : ERROR, LOSS 모두 처리  밑의 채널이 불안정해 패킷 에러, 로스 둘 다 가능 구현  Sender는 ACK를 충분한 시간만큼 기다림 시간 안에 ACK가 오지 않으면 패킷 재전송 만약 패킷이 그냥 Delay 된 것이였다?  재전송된 패킷은 중복 패킷이 되겠지만, Seq Number 덕분에 그냥 Discard됨     카운트 다운 타이머 필요     image \n start_timer로 \u0026ldquo;resonable\u0026rdquo; 한 시간동안 기다림  timeout 되면 패킷을 재전송하고 타이머 재시작   corrupt 되거나 잘못된 seq number의 ACK이 오면 그냥 무시 제대로된 ACK가 오면 타이머 멈추고 다음으로 넘어감  RDT 3.0 동작  image \n image \n 지금까지 혼동하고 있었는데 이걸보면 Sequence는 일련의 한정된 패킷에 넘버링 하는게 아니라, 버퍼 개념인 듯 하다. 즉 여기서는 버퍼가 두칸짜리고 이걸 계속 상위 레이어에서 데이터를 받아서 채우고 Receiver에 전달하는 것. (d)의 경우에는 ACK 전달이 Delay됨.  RDT 3.0의 문제  image  r  image \n 제대로 작동은 하지만 작동이 엄청 느리다 사실상 못쓴다 RTT  패킷을 보내고 답을 받는데까지 시간 2 X PropDelay   그러니까 실제 패킷을 전송하는데 할애한 시간인 L/R 에 전체 시간인 RTT + L/R을 나누면 Utilization (효율) 을 알 수 있다.. 이말이다.  위의 예에서는 1Gbps 링크, 15 prop delay, 8000bit 짜리 패킷을 보내는 것을 가정  RTT = 2 * prop delay 이므로 (대충 그림상) (8000/10^9) / (30 + 8000/10^9) → 0.00027     위에서 봤듯이 사실 RDT 전부 ACK를 기다리는 모습들. 즉 Stop and Wait 프로토콜을 사용하기에 느림  그래서 파이프 라이닝이 나옴    Pipelining Protocols  Sender는 ACK를 받지 않더라도 계속 여러개의 패킷을 보낼 수 있음 TCP 프로토콜에 사용됨  Utilization (이용률) 상승  image \n 위의 예에서는 3개의 패킷을 동시에 보내 3배만큼 효율 증가 Receive 측에서 ACK를 보내긴 함  Go-Back-N  최대 N개까지는 ACK를 받지 않고 패킷을 보낼 수 있다 Receiver는 Cumulative ACK만을 보냄  누적 패킷 Gap이 있다면 Ack 패킷을 보내지 않음  즉 만약 패킷1을 받았는데.. 패킷2가 전달이 되지 않은 경우? 패킷3이 전달되어 Ack를 보낼 때 Ack1을 보낸다.     한개의 타이머만 유지  타임아웃이 발생하면, Ack로 정상 전송 여부가 판별되지 않은 모든 패킷을 다시 보낸다    2. Go-Back-N (GBN)  Sliding Window Protocol 이라고도 부름\n Sender  image \n window : 최대 N개의 패킷을 보낼 수 있는 범위 send_base : 현재 Window에서 처음 보내는 패킷 nextseqnum : (상위 레이어에서 패킷이 아직 안와서) 다음에 보낼 패킷 설명하자면..  초록색은 Ack를 받고 정상 전송이 컨펌된 패킷들 노란색은 보내긴 했으나 Ack가 도달 안된 패킷들 파란색은 현재 Window 내에서 전송 가능한 가용 패킷 용량 하얀색은 아직 Window 범위 내에 있지 않아 사용 불가능한 칸이다.   만약 상위 레이어에서 데이터가 내려오면  Window 칸 모두 파란색이다  해당 패킷들을 만들어 보내고 그 수만큼 파란색 칸은 노란색이 되고 nextseqnum도 해당 수만큼 오른쪽으로 이동 보내놓은 패킷이 없어서 타이머가 종료된 상태였는데, 처음 패킷을 보냈으므로 타이머 시작   Window 내에 노란색도 있고 파란색도 있다  해당 패킷들을 만들어 보내고 그 수만큼 파란색 칸은 노란색이 되고 nextseqnum도 해당 수만큼 오른쪽으로 이동   Window 칸 모두 노란색이다  nextseqnum이 현재 window를 이탈한 상태라는 것 즉 가용한 패킷 용량을 다 사용했으므로 데이터 전송을 거부     만약 Ack가 도착하면  해당 Ack가 컨펌한 패킷들만큼 노란색 칸이 초록색 칸으로 채워지고 또 그만큼 send_base가 오른쪽으로 이동 window는 바뀐 send_base에 맞춰 그만큼 재설정됨   그랬는데 만약 모든 칸이 초록색이라면  모든 보낸 패킷이 Ack에 의해 컨펌되었으므로 타이머 종료   아직 컨펌되지 않은 패킷이 있다면  타이머 재시작     타임아웃이 발생하면  타이머 재시작하고 노란색 패킷들을 다시 보냄      Sender FSM  image \n 위에서 얘기한 내용을 FSM으로 표현한 것  Receiver FSM  image \n expectedseqnum : 받아야 할 패킷의 시퀀스 넘버 패킷이 순서대로 왔을 경우  제대로 수신된 제일 마지막 패킷을 기준으로 ACK 하나를 보냄 expectedsuqnum 하나만 기억하면 됨   패킷의 순서가 엉망인 경우  그냥 버려버리고 순서대로 제대로 온 패킷의 마지막 시퀀스 넘버 ACK를 보낸다    모식도  image \n Sender는 패킷 0,1,2,3 을 보낸다 Receiver는 패킷2가 Loss 됬으므로 마지막으로 제대로 수신된 패킷1의 ACK를 계속 보낸다. Sender는 ACK1를 받아 0,1은 컨펌됨을 알고 send_base를 2로 이동 그리고 그 과정에서 Window에 포함되는 4,5가 비는데, 데이터가 오면 전송시킨다 Receiver는 해당 패킷을 기대하는게 아니므로 계속해서 패킷1의 ACK를 보냄 그러다보면 타임아웃이 일어남 Sender는 타이머를 재시작하고 Ack로 컨펌되지 않은 2,3,4,5 패킷을 보냄 Receiver는 기대하고 있는 패킷이 왔으므로 수신 작업을 함  Selective Repeat (SR) GBN과의 차이점  Receiver  개별적으로 패킷들에 ACK 해줌 순서대로 오지 않은 패킷도 버퍼함  즉 패킷 9를 받지못하고 패킷 10을 받아도 버퍼에 패킷 10을 저장해뒀다가 패킷 9가 오면 한꺼번에 올려줌     Sender  각각의 패킷에 대해 타이머를 유지 관리 타임아웃이 오면 해당 패킷만 재전송    Sender / Receiver  image \n모식도  image \n Sender가 패킷 0,1,2,3 보냄 패킷2에 로스가 일어남 Receiver는 패킷 0,1,3 받고 각각 Ack 보냄. 패킷3은 버퍼에 들어감 Sender는 0,1이 컨펌된것을 인지하고 Sender_base를 2로 옮김 (단 Ack3의 경우에는 Ack2가 아직 도달 안했으므로, 패킷3이 전송 잘 되었다는것만 기억.) 그 과정에서 포함되는 4,5 자리. 데이터가 오면 패킷 4,5로 전송 Receiver는 패킷을 받고 버퍼에 저장. Ack 4, Ack 5도 전송함 패킷 4,5도 잘 전달되었다는 것을 기억. Sender는 패킷2 타이머가 타임아웃됨을 인지 따라서 패킷2를 재전송 Receiver는 패킷2를 받고 버퍼에 있던 패킷들과 함께 상위 레이어로 전송, Ack2를 Sender에 전해줌  문제점  image \n 위같이 시퀀스 넘버를 짤 경우, Receiver 입장에서는 Sender의 사정을 알 수 없으므로 처음 패킷0,1,2에 대한 Ack들이 통째로 로스될 경우..  Sender는 재차 기존 패킷0,1,2를 재전송하고 Receiver는 그 재전송된 패킷이 새로운 칸의 0,1의 패킷으로 생각하고 버퍼에 넣어버린다.   그래서 시퀀스 넘버 Range는 Window 사이즈보다 두 배 이상 커야 한다.  TCP 특성  메세지 크기 제한이 없음 플로우 컨트롤 : Receiver가 핸들 가능한 속도로 맞춰줌 Pipelined  혼잡 제어, 플로우 컨트롤로 인해 윈도우 사이즈 계속 변함    TCP segment 구조  Computer-Network-TCP%2051c0253249f64f00b375108f77902f12/Untitled.png \n FLAG들  U : Urgent. 빨리 보내야 하는 세그먼트. 잘 안씀 A : Ack P : Push now. 잘 안씀 R : Reset. 비정상 종료 S : SYN. 연결을 처음 맺을 때 사용 F : FIN. 정상적 종료   Receive WIndow : Receiver가 받고자 하는 바이트 수. Flow control 때 사용 Checksum : 말 그대로 체크섬  TCP Timeout  RTT 보다 큰 시간 기다려야 SampleRTT  세그먼트를 실제로 보내보고 Ack가 올 때 까지 시간 측정 평균값 추정   계산 예제 : Est0 = 100, Sam1 = 100, Sam2 = 50, Sam3 = 200, Alpha=0.1 일 때 Est1, Est2, Est3를 구하라  Est1 = 0.9Est0 + 0.1Sam1 Est2 = 0.9Est1 + 0.1Sam2 Est3 = 0.9Est2 + 0.1Sam3   Timeout_Interval = EstimatedRTT + 4*DevRTT  DevRTT = (1-b)DevRTT + b|SampleRTT - EstimatedRTT| SampleRTT와 EstimatedRTT 차이가 많이 나면 마진을 많이 두는 식 최소 1초 이상은 나오게 되어 있는데, 컴퓨터 입장에서는 1초가 긴 시간이므로 다른 방법 사용 가능    TCP RDT (Reliable Data Transfer) TCP Sender Events  TCP 소켓이 앱에서 데이터를 받을 때  세그먼트 넘버와 함께 세그먼트 생성 타이머가 작동중이지 않으면 시작시킴  가장 오래 Unacked 상태인 세그먼트라고 가정     타임아웃이 일어날 때  타임아웃이 일어난 세그먼트 재전송 타이머 재시작   Ack를 받을 때  새로운 Ack일 경우  Ack 된 (컨펌된) 세그먼트 체크 (SendBase 우측으로 이동) 아직 Unacked인 세그먼트가 있다면 타이머 시작      TCP Ack 생성 절차  적합한 Seq Num 세그먼트가 도착  다음 세그먼트를 50ms 가량 기다리고 도착하지 않으면 Ack 전송   다음 세그먼트 기다리는 와중 적합한 Seq Num 도착  하나의 단일 누적 Ack를 보냄   적합한 Seq Num보다 큰 세그먼트 도착. Gap Detected.  Duplicated ACK를 보내 적합한 Seq Num 알려줌   Gap을 완전히, 혹은 일부 메꿔줄 수 있는 세그먼트 도착  더 낮은 Seq Num이 필요하다는 것을 Ack 통해 알려줌    TCP Fast Retransmit  Duplicate ACKs가 발생하면 패킷 로스로 판단, 즉각 재전송  TCP Flow Control  Receiver 측에서 Sender를 컨트롤하여 너무 빠른 속도로 데이터를 보내지 않게 조절 Receiver가 헤더의 Receive Window (rwnd)를 사용해 Sender에게 가용한 버퍼의 크기 알려줌 Sender는 Unacked 패킷의 양을 rwnd 값을 넘지 않게 조절해 오버플로우 방지  HandShake  서로 양쪽의 시퀀스 넘버와 버퍼값을 알려주고 합의  2-way handshake  딜레이가 가변적 패킷 로스 등 재전송이 필요한 경우가 있을 수 있음 지금은 Handshake 중이기 때문에 Order가 보장되지 않음 Can\u0026rsquo;t \u0026ldquo;See\u0026rdquo; other side each other yet  3-way handshake  Computer-Netowork-TCP-Flow-Control-and-Handshake%20a8a72799ddb84c4d877d90dc0b22024d/Untitled%204.png \nTCP: Closing a connection  Computer-Netowork-TCP-Flow-Control-and-Handshake%20a8a72799ddb84c4d877d90dc0b22024d/Untitled%206.png \n 클라는 위에서 왜 TIMED_WAIT → CLOSED 까지 기다리고 있을까?  만약 서버의 FIN에 대한 자신의 Ack Response가 유실되었을 경우, 서버가 FINbit=1을 재전송할 경우 다시 Ack를 보내줘야 하기에 충분한 시간동안 기다려 주는 것    TCP Congestion Control   증가시킬때는 천천히, 감소시킬때는 빠르게\n  Additive Increase, Multiplicative decrease\n congestion window (cwnd)를 패킷 로스가 감지될 때 까지 1MSS만큼 매 RTT마다 늘림 패킷 로스가 감지되면 cwnd를 반으로 줄임    TCP Sending Rate\n Computer-Network-TCP-Congestion-Control%20a97541deec9549d5b912476d44813883/Untitled%2010.png \n  TCP Slow Start  Computer-Network-TCP-Congestion-Control%20a97541deec9549d5b912476d44813883/Untitled%2011.png \n 처음에는 cwnd = 1 MMS로 시작 이를 지수적으로 증가시킴  각각의 RTT마다 cwnd를 두배씩 증가시킴 ACK를 받을 때 마다 +1을 해줌으로서 구현    TCP의 손실 감지, 반응  타임아웃이 발생하면  cwnd = 1 MMS로 초기화 ssthresh를 타임아웃이 발생했을 때 크기의 반으로 설정 다음 cwnd를 지수적으로 (1..2..4..8) 증가시킴 ssthresh에 도달하면 선형적으로 (1..2..3..4) 증가시킴   3개의 중복 ACK가 발생 (패킷로스 이벤트 발생)   TCP Tahoe\n Computer-Network-Final-Quick-Note%20a0c2deefe78b40d890713797e3bc04a6/Untitled.png \n 타임아웃 발생시와 동일하게 처리    TCP RENO\n Computer-Network-Final-Quick-Note%20a0c2deefe78b40d890713797e3bc04a6/Untitled%201.png \n cwnd를 반으로 줄이고 선형적으로 증가시킴 위 예제에서는 반으로 줄이고 + 3을 해줬는데 아무튼 구현법에 따라 다른듯      TCP 쓰루풋  Computer-Network-TCP-Congestion-Control%20a97541deec9549d5b912476d44813883/Untitled%2014.png \nTCP 공평성  연결 1,2가 같은 네트워크를 사용한다고 했을 때 처음에는 쓰루풋이 달라도 패킷로스 등을 거치며 Slow Start, CA 등으로 쓰루풋이 동일하게 수렴 Parallel TCP (꼼수?)  병렬적으로 연결을 맺어 속도 향상시킴 웹 브라우저에서 자주 사용   단점  멀티미디어 앱들은 속도에 지정 받을 수 있음 따라서 UDP 많이 사용    ECN (Explict Congestion Notification)  네트워크 라우터들이 혼잡 상황을 판단하고 Source, Dest에 알려줌 IP헤더의 ToS 필드 이용 예  Source에서는 헤더에 ECN=00 으로 세팅되어 전송됨 만약 네트워크에 혼잡이 있다면 중간에 라우터에서 이를 ECN=11으로 바꿈 Destination에서는 패킷을 받아보고 ECN이 설정되어 있다면 ECE=1 (ECN echo) 설정해 ACK를 보내줘 Source에게도 네트워크에 혼잡이 있다는 것을 알려줌    Multimedia: Audio  아날로그 오디오 신호는 주기적인 속도로 샘플링 진행 각각의 샘플들은 Quantized 됨 Quantized된 값들은 Bits로 표현됨 계산법  8000 samples/sec 이고 256 (2^8) quantized values  8000 X 8 = 64000bps     원본 손실이 일어남  Multimedia: Video  비디오 : 일련의 이미지  24 images/sec 등   인코딩 : 이미지간의 중복 이용해 비트를 줄임  Spatial  중복된 색깔을 이용   Temporal  전의 이미지와 다음 이미지간의 차이점만 보냄     CBR : 고정된 비디오 인코딩 레이트 VBR : 가변적인 인코딩 레이트  인코딩이 변화하는 것에 따라 가변적    Multimedia Networking  Streaming: Stored audio, video  다운로드와 동시에 실행 가능 서버에 저장된 미디어 유튜브   Conversational Voice/Video over IP  Interactive Delay Tolerance (딜레이 허용) 제한 Skype   Streaming live audio, video  Live Sport Events    Streaming stored video  Computer-Network-Multimedia%20587155c1a38047a6a00f9d40875e3299/Untitled%201.png \nStreaming stored video : Challenge  Keeping continuous  플레이에 지연 걸리지 않게 But network status changing Client-side buffer needed   Video packet can be lost Client interact  Stop, Play, Rewind    Streaming stored video : Client side buffering  Computer-Network-Multimedia%20587155c1a38047a6a00f9d40875e3299/Untitled%202.png \n 버퍼 내용의 양은 가변적 initial playout delay tradeoff  초기 버퍼값을 높게 설정하면  버퍼링이 많이 걸리지 않을 수 있다 그러나 처음 영상을 재생할 때 까지의 시간이 많이 소요      Streaming multimedia : UDP  보통 send rate = encoding rate = constant rate 전송 속도는 혼잡도에 상관없음 TCP보다 Playout delay 상대적으로 적음 에러 복구가 필요하다면 에플리케이션 레벨에서 처리 UDP는 방화벽에 자주 막히는 문제가 있음  Streaming multimedia : HTTP (TCP)  혼잡 제어 때문에 전송속도 가변적 Playout delay가 좀 더 큼 방화벽에 잘 안막히는 장점  VOIP  통신 가능한 만큼의 딜레이 관리가 필요 Session initialization  전화하는 사람이 IP, 포트, 인코딩 알고리즘 전달 방법    VOIP 특징  번갈아가면서 말함 64kbps during talking  오직 말할때만 패킷 생성 20ms chunks at 8Kbytes/sec (64kbps) → 160 bytes of data  Talk Spurt에서 각 20ms마다 160바이트의 데이터가 생성 여기에 UDP나 TCP 등의 헤더가 붙음 앱은 매 20ms마다 소켓을 통해 세그먼트를 보냄      VOIP Playout delay : Fixed  q라는 고정된 딜레이 값을 사용 q 이상으로 딜레이가 발생한다면 해당 패킷은 필요없으므로 버림 너무 큰 값을 사용하면 딜레이 커짐, 적은 패킷 유실 작은 값을 사용하면 소통은 잘 되나 패킷 유실이 많이 일어날 수 있음  VOIP Playout delay : Adaptive   목표\n Low playout delay low late loss rate    네트워크 딜레이를 계속 추정 + 마진을 넣어 딜레이를 가변적으로 적용\n 각 Talk spurt 첫부분에 딜레이를 적용 Slience 구간이 지난 이후 다음 Talk spurt이 시작 될 때 딜레이를 재계산하여 적용    패킷 딜레이 계산 방법\n Computer-Network-VOIP%2085c316c48ae749acb2e3ed75389646f6/Untitled%202.png \n  평균 편차 계산\n   Computer-Network-Final-Quick-Note%20a0c2deefe78b40d890713797e3bc04a6/Untitled%202.png \n  Playout time\n Computer-Network-Final-Quick-Note%20a0c2deefe78b40d890713797e3bc04a6/Untitled%203.png \n  Receiver가 Talkspurt 시작점 판별하는 방법  패킷 유실이 없다면 타임 스탬프 확인  Talkspurt 내의 패킷들은 20ms 간격 그 이상의 딜레이가 있었다는 것은 그 사이에 침묵 구간이 있었다는 것  Seq1 → (40ms) → Seq2     패킷 유실이 있었던 것 같다면  타임스탬프 뿐만 아니라 시퀀스 넘버도 확인 Seq1 → (40ms) → Seq3    VOIP : 패킷 로스 복구  VOIP에서는 ACK/NAK 방식 사용 안함  딜레이 때문   FEC (Foward Error Correction) 방식 이용  충분한 비트 미리 보내서 해당 데이터를 바탕으로 복구    Simple FEC  Computer-Network-VOIP%2085c316c48ae749acb2e3ed75389646f6/Untitled%203.png \n XOR 사용해 복구 비트 만듬 한개까지만 복구 가능  PiggyBacking FEC  Computer-Network-VOIP%2085c316c48ae749acb2e3ed75389646f6/Untitled%204.png \n 숟가락 얹는 방식 내 다음 청크에 낮은 음질의 백업 음성 탑재  Interleaving 방식  20ms 단위로 송신하던 것을 5ms 단위로 쪼개어 뒤섞어 재구성 받을 때 다시 원래 순서로 맞추어 재생  Skype  클라이언트끼리 서로 직접 연결해 통화 수퍼노드  특별한 기능을 가진 스카이프 피어 자신에게 접속해 있는 클라이언트 리스트 유지   오버레이 네트워크  수퍼노드들의 네트워크 유저 리스트 등 보관 및 공유    Skype 동작  수퍼노드 접속 (TCP) 로그인 서버를 통해 로그인 수퍼노드를 통해 전화할 유저 IP 가져옴 얻은 IP 주소를 통해 전화  Skype 문제  NAT 문제  NAT 바깥에서 피어에게 연결 불가능 수퍼 노트들 통해 중개하는 방법 사용    RTP (Real Time Protocol)  실시간 데이터 전송을 위해 사용하는 프로토콜 UDP 사용  RTP 예시  64 Kbps (8 KBytes per second)의 PCM encoded voice를 RTP로 전송  20ms 마다 160Bytes 오디오 청크 여기에다가 RTP 헤더 + UDP 헤더 추가됨 RTP 패킷은 UDP 안에 캡슐레이션 되므로    RTP 헤더  Computer-Network-VOIP%2085c316c48ae749acb2e3ed75389646f6/Untitled%207.png \n Payload Type: 어떤 타입의 미디어인가 (보이스.. 미디어\u0026hellip;)  Payload type 0: PCM mu-law, 64 kbps Payload type 3: GSM, 13 kbps Payload type 7: LPC, 2.4 kbps Payload type 26: Motion JPEG Payload type 31: H.261 Payload type 33: MPEG2 video   Sequence number  RTP 패킷 별로 하나씩 증가 패킷 로스가 감지되면 FEC를 통해 에러 복구 등 실행   Timestamp  실제 시간 아님 RTP 패킷에 있는 첫번째 바이트의 Sampling instant Source가 Active할 때 App이 160개의 encoded samples를 생성한다면, 각 RTP 패킷의 timestamp는 160씩 늘어남 inactive 상태일 때는 Constant Rate로 늘어남   SSRC field  Source의 유니크 ID    RTCP  RTP와 옵션적으로 사용 RTCP 패킷은 Sender, Receiver의 Statistics를 포함  얼마의 패킷을 보냈고, 얼마의 패킷이 로스됬고..   Sender가 동작 제어하는데 도움  RTCP : 패킷 타입  Receiver report packets  패킷 로스, 마지막으로 받은 시퀀스 넘버 등   Sender report packets  현재 시간, 보낸 패킷들, 보낸 바이트 등   Source description packets  Sender의 메일, 이름 등..    RTCP : 동기화  Voice, Video 동기화 가능  RTCP : Bandwidth scaling  RTCP는 전체 대역폭의 5%만 차지하자  너무 많이 리포트 보내면 대역폭 잡아먹으니까   예 : Sender가 2Mbps로 데이터를 보낸다면  100Kbps만 RTCP가 쓴다는 것 여기서도 75%는 Receiver가, 25%는 Sender가 나눠가짐  Receivers가 많다면 해당 75%를 균등하게 나눠 사용      SIP : Session Init Protocol  모든 전화, 비디오 콜이 인터넷을 통해 이루어지도록 번호보다는 이름, 이메일로 신원 확인 Collee가 어디서든, 어떤 장치를 쓰던 접근 가능하게  SIP 서비스들  Coller가 Collee에게 전화하고 싶다는 사실을 Collee에게 전달 미디어 타입, 인코딩 방식 협의 전화 종료 mnemonic (의미있는) 식별자들을 IP로 변경  이름, 이메일 등..   통화 관리  새로운 미디어 스트림 추가 인코딩 방식 변경 전화 홀드, 전달, 추가 등    SIP 예제  Computer-Network-VOIP-SIP%20e61661aea74044b7aed1c3c8a95ca9e1/Untitled.png \n 인코딩 협상  만약 상대방이 요청한 인코딩을 자신의 시스템이 지원하지 않는다면 606 Not Acceptable  상대방은 다른 인코딩 방식을 설정해 새 INVITE 메세지를 보낼 수 있음     RTP(UDP) 뿐만 아니라 TCP도 사용 가능  SIP Register  Computer-Network-VOIP-SIP%20e61661aea74044b7aed1c3c8a95ca9e1/Untitled%201.png \n 사용자가 SIP Client를 실행시키면 클라이언트는 SIP REGISTER에 메세지를 보내 등록  SIP Proxy  Computer-Network-VOIP-SIP%20e61661aea74044b7aed1c3c8a95ca9e1/Untitled%202.png \n Local DNS Server와 유사한 역할 Alice가 프록시 서버로 invite 메세지를 보내면  해당 메세지는 상대방 Bob의 주소(이름)을 포함 프록시 서버는 다른 프록시 서버 등을 통해 라우팅하여 Bob에게 메세지 전달 Response를 받으면 다시 그것을 Alice에게 전달  Response에는 Bob의 IP가 포함      Multimedia support of network  Computer-Network-VOIP-SIP%20e61661aea74044b7aed1c3c8a95ca9e1/Untitled%203.png \n Best effort  서비스 없음   Differentiated Service (서비스 차등화)  Soft Guarantee available Packet marking Scheduling policing 복잡성 중간, 가끔 사용   Per-Connection QoS  Hard Guarantee available Packet marking, Scheduling policing Call admission  보장해 줄 수 있다면 허용, 아니라면 통신 비허가   복잡성 높아 실제로는 사용안함    Best effort networks  좋은 라우터, 링크로 땜빵 비용 많이 듬 얼마만큼의 bandwidth가 충분한지 트래픽 추정 필요  Class of Service  예를 들어 VOIP의 경우 실시간성 데이터이므로 HTTP보다 우선순위 높여줌  여기서 Packet marking이 사용됨   그런데 VOIP의 우선순위를 높게 줘서 대역폭을 다먹어서 HTTP로 통신이 불가능해졌다면?  QoS policing을 주어 연결속도 제한   근데 QoS 걸어버리면 VOIP 패킷이 없을때도 HTTP는 제한된 속도로 통신할 수 밖에 없음  효과적인 QoS policing 정책 없을까?    Policing mechanims  평균 패킷 제한  (장기적으로) Unit time 당 얼마나 많은 패킷을 보낼 수 있는지 결정   Peak Rate  분당, 초당 얼마의 패킷을 보낼 수있는지 결정   Burst size  한번에 (연속적으로) 패킷을 보낼 때 얼마나 많이 보낼 수 있는지 결정    Policing mechanisms: Token bucket  Token bucket : 제일 많이 사용 방법론  가상의 통이 있는데 여기에는 티켓이 1초당 10개 생성됨 패킷이 지나갈 때 마다 티켓을 한장 소모하고 가야함 만약 가상의 통이 비어있다면 (티켓이 없다면) 패킷은 티켓이 생길 때 까지 대기했다가 지나가야함   티켓(토큰)이 생성되는 시간을 통해 속도 조절  초당 A개의 토큰을 생성한다면 패킷도 초당 10개 지나갈 수 있음   통의 크기를 조절해 Burst Size 조절  통의 크기가 B라면, Burst Size도 B  기다리는 시간 없이 연속적으로 보낼 수 있는 양     따라서 주어진 T 시간에 대해 보낼 수 있는 패킷의 양은  A * T + B    Policing and QoS Guarantees  Computer-Network-VOIP-SIP%20e61661aea74044b7aed1c3c8a95ca9e1/Untitled%209.png \n Token bucket과 WFQ (Weighted fair queueing) 를 같이 쓰면 큐 Delay의 Guaranteed upper bound를 구할 수 있음  Dmax = b / WFQ WFQ = ((W1) / (W1+..+Wn)) * R    Differentiated Services  차등화된 서비스 제공 간단한 펑션은 네트워크 코어에 유지하고, 복잡한 펑션은 엣지 라우터나 호스트에 유지 직접 클래스를 구현하진 않고, 클래스를 만들 수 있는 기능들을 정의  Diffserv Architecture  엣지 라우터와 코어 라우터로 나뉨 Edge Router  Flow 별 트래픽 관리 패킷 마킹  in-profile  Flow가 선언한 만큼의 속도 안에서 쓰고있는 패킷들에 마킹됨   out-profile  Flow가 선언한 만큼의 속도 이상을 사용하고 있는 패킷들에 마킹됨       Core Router  Class 별 트래픽 관리 엣지 라우터에서 마킹한 것에 기반하여 버퍼링, 스케줄링 in-profile 패킷들에 우선순위를 먼저 줌    Edge-router packet marking  Profile = \u0026lt;협의된 전송 속도 R, 버킷 사이즈 B\u0026gt; Flow 마다 Profile을 베이스로 패킷을 마킹함 마킹 사용법  Class-Based Marking  클래스 별로 마킹   Intra-Class Marking  클래스 내에서도 in-profile인지 out-profile인지에 따라 마킹 가능      Diffserv packet marking: Detail  ToS를 이용해 마킹 6비트짜리 Differentiated Service Code Point (DSCP) 필드 이용  Per-Connection QoS Guarantees  Computer-Network-VOIP-SIP%20e61661aea74044b7aed1c3c8a95ca9e1/Untitled%2010.png \n 아예 연결별로 QoS를 지정 예를 들어 1.5Mbps링크에 2개의 1Mbps 연결이 시도되고 있다면  한개만 허용하고 다른 한개는 막아버림 Call Admission   ","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-final-quick-note/","title":"Computer Networking - Final Quick Note"},{"content":"Computer Networking - Flow Control and Handshake\nComputer-Netowork-TCP-Flow-Control-and-Handshake 1. TCP Flow Control  Reciver 측에서 버퍼에다가 데이터를 저장하는데 Sender가 너무 빠르게 보내면 데이터가 유실될 수 있음 (Overflow) 그러므로 Receiver 측에서 Sender를 컨트롤하여 너무 빠른 속도로 데이터를 보내지 않도록 조절  절차  image \n Receiver는 가용한 버퍼의 크기를 TCP header의 rwnd 값을 통해 Sender에게 알려줌 (광고)  RcvBuffer의 크기는 기본적으로 4096 Bytes 이지만 OS에서 보통 자동으로 할당해줌   Sender는 Unacked 패킷의 양을 rwnd 값을 넘지 않도록 조절해 오버플로우 방지  2. Connection Management  image \n TCP는 Sender/Receiver가 Handshake하는 절차를 거침 도중에 서로 Connection Parameters (Variables)에 대해 동의함  양쪽의 시퀀스 넘버와 버퍼값을 서로 알려주고 동의    2-way handshake  image \n2-way handshake 문제점  딜레이가 가변적 패킷 로스 등 재전송이 필요한 경우가 있을 수 있음 지금은 Handshake 중이기 때문에 Order가 보장되지 않음 Can\u0026rsquo;t \u0026ldquo;See\u0026rdquo; other side each other yet   image \n 왼쪽의 경우  Delay 때문에 클라이언트가 다시 req_conn(x)를 보냈다 그러나 재전송된 패킷이 서버에 도달하기 전에 TCP 연결이 맺어져버렸고 데이터 송수신도 끝나 TCP 연결은 종료되었다 이 재전송된 패킷은 그 이후에 서버에 도착했다 서버는 이를 받아들여 TCP 연결을 또 열어버린다 그러나 이는 클라이언트가 없는 반쪽짜리 연결이다 (쓸모없는)   오른쪽의 경우  TCP 전송이 끝난 후 재전송된 req_conn(x) 뿐만 아니라 재전송된 데이터까지 다 받아버렸다 결국 서버 혼자 새 TCP 연결을 열고 데이터까지 받아버린 꼴이다    TCP 3-way handshake  image \n 예를 들어 클라이언트는 ACK(y)를 보낼 때 HTTP Request를 같이 보낼 수 있다   image \nTCP: Closing a connection  image \n 클라이언트, 서버 둘 다 연결 끊을 수 있음  FIN 플래그에 1을 주면 됨   Respond to received FIN with ACK  on receiving FIN, ACK can be combined with own FIN 즉 위에서 서버가 클라의 FINbit=1 에 대한 Ack를 보낼 때 자신의 FINbit=1을 같이 보낼수도 있었다.   simultaneous FIN exchanges can be handled 클라는 위에서 왜 TIMED_WAIT → CLOSED 까지 기다리고 있을까?  만약 서버의 FIN에 대한 자신의 Ack Response가 유실되었을 경우, 서버가 FINbit=1을 재전송할 경우 다시 Ack를 보내줘야 하기에 충분한 시간동안 기다려 주는 것   ","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-flow-control-and-handshake/","title":"Computer Networking - Flow Control and Handshake"},{"content":"컴퓨터 네트워크 - HTTP\nComputer-Netowork-HTTP 1. Web and HTTP  웹 페이지는 오브젝트로 이루어져 있다 오브젝트  HTML 파일 JPEG Audio 파일 플래시 등   더 정확히 말하면 웹 페이지는 베이스 HTML 파일로 구성되며  그리고 그 HTML 파일은 몇개의 참조된 오브젝트들을 포함한다.   각각의 오브젝트들은 URL을 통해 특정 가능하다  예시) www.somewebsite.com/somedirectory/someobject.gif URL은 호스트 네임과 패스 네임으로 이루어져 있다.    2. HTTP 개요  HTTP: hypertext transfer protocol 웹의 애플리케이션 프로토콜 기본적으로 Client/Server 모델  Client  브라우저로 HTTP 프로토콜을 통해 reqeust하고 오브젝트들을 받아서 디스플레이 해줌   Server  웹 서버는 HTTP 프로토콜을 통해 오브젝트를 response로 전송     TCP를 사용 (현재로서는)  클라이언트는 서버로 TCP 연결을 시작 서버는 TCP 연결을 수락 클라이언트는 HTTP request 메세지 서버는 HTTP response 메세지를 보냄 TCP 연결 종료   HTTP는 Stateless 하다  서버는 과거의 클라이언트 request에 대한 정보를 저장하지 않는다 다만 쿠키, 세션 등으로 따로 구현할 수는 있다 왜?  구현이 어렵다. 예를 들어서 클라이언트/서버가 크래시가 날 경우 복구 등에 대한 문제.      3. HTTP 연결 💥  시험에 나올 가능성이 높은 중요한 부분\n Non-Persistent HTTP  image \n 한 TCP 연결에서 한 개의 오브젝트만 보낼 수 있다 한 개의 오브젝트를 보내면 TCP 연결은 종료 여러 개의 오브젝트를 받고싶다면 여러 개의 TCP 연결이 필요   image \n RTT (Round Trip Time)  작은 패킷이 클라이언트에서 서버로 갔다가 돌아오는 시간 즉 Request 한 후 Response가 도착할 때 까지 걸리는 시간 파일 (오브젝트) 전송 시간은 포함하지 않는다. 즉 response 패킷의 처음 몇 바이트의 도달 시간 까지만 RTT로 침   Non-Persistent HTTP Response time = 2RTT + 파일 전송 시간  Non-Persistent HTTP 문제점  오브젝트 당 2 RTT를 소모 TCP 연결마다 OS에 부하가 걸린다 브라우저는 TCP 연결을 병렬적으로 동시에 열어 시간을 줄이기도 한다  예를 들어, 1HTML + 10JPG 예의 경우  HTML 파일을 전송받는데 2 RTT를 소모 HTML 파싱한 후 참조된 오브젝트들을 전송할 때 병렬적으로 TCP 연결을 해 한꺼번에 2 RTT를 소모 총 4 RTT로 전송할 수 있다는 것      Persistent HTTP  서버가 Response를 전송 후에도 TCP 연결을 유지 여러 개의 오브젝트를 한 번의 TCP 연결로 전송 가능 모든 참조 오브젝트에 대해 하나의 RTT로도 충분하다  예를 들어 1HTML + 10JPG의 예의 경우  HTML 파일을 전송받는데 2 RTT를 소모 HTML 파싱한 후 참조된 오브젝트를 전송할 때 이미 연결된 TCP가 유지되고 있으므로 HTTP 전송에 해당하는 1 RTT 만 소모 총 3 RTT로 전송 가능      4. HTTP request message 개요  Request와 Response 두 개의 메세지 타입 HTTP Request messsage  ASCII 로 구성 사람이 읽을 수 있음     image \n image \nUploading Form Input  POST 메소드  폼 인풋에서 종종 쓰임 인풋은 Entity body에 기입되어 전달   Get 메소드  URL 메소드 라고도 함 인풋은 URL 필드에 포함되어 전달된다    Method Types  HTTP/1.0  GET POST HEAD  실제 데이터는 안보내고 HEAD만 보낼 때 사용     HTTP/1.1  GET POST HEAD PUT  URL 필드에 명시된 경로로 파일을 업로드 하고 싶을 때   DELETE  URL 필드에 명시된 경로의 파일을 지우고 싶을 때      5. HTTP response message  image \nRespose Status Codes  200 OK  Request 성공. Response 메세지 뒤에 요청한 오브젝트가 있다.   301 Moved Permanently  요청한 오브젝트가 이동되었다. 새 위치를 메세지에 담아 보내주겠다.   400 Bad Request  (서버가) 요청한 메세지를 이해할 수 없다.   404 Not found  요청한 문서를 서버에서 찾을 수 없다.   505 HTTP Version Not Supported  5. User-Server State: Cookies 개요 상태 정보를 유지하기 위해 사용\n과자 부스러기와 같이 작은 정보들을 담는다고 하여 Cookie라고 함\n4개의 컴포넌트 쿠키를 사용하기 위해서는 다음의 네 가지 컴포넌트가 필요하다.\n HTTP response message 에서의 쿠키 헤더 라인 HTTP request message 에서의 쿠키 헤더 라인 쿠키 파일은 유저의 호스트에서 유지되고, 유저의 브라우저에 의해 관리된다 웹 사이트의 백 엔드 데이터베이스   image \n쿠키는 어디에서 사용될 수 있나?  인증 쇼핑 카트 사용자 맞춤 추천 정보 유저 활동 정보   쿠키는 프라이버시를 침해할 여지가 있다\n 2. 웹 캐시 (프록시 서버) 목적 클라이언트의 요청을 실제 오리진 서버의 관여 없이 만족시키는 것\n image \n 클라이언트는 프록시 서버에 HTTP Request를 보내 원하는 오브젝트를 요청 Proxy Server는 요청을 받은 오브젝트가 자신의 서버에 있는지 확인  오브젝트가 없다면  Origin 서버에 HTTP request 보내 해당 오브젝트 요청 Origin 서버에서 받은 오브젝트를 Client에 Response로 다시 전달   오브젝트가 있다면  Client에 전달      특징  프록시 서버는 클라이언트/서버 두개의 역할을 모두 하는 셈 클라이언트의 응답 시간을 줄여줄 수 있다 기관의 엑세스 링크에 대한 트래픽을 줄여줄 수 있다 ISP에서 캐시 서버를 운영한다면, 영세 사업자는 트래픽 경감효과를 누릴 수 있다.  Conditional GET  image \n 캐시된 최신의 오브젝트를 이미 가지고 있다면 서버에서 오브젝트를 보내지 말라는 것\n  오브젝트 전송 딜레이를 발생하지 않게 하여 링크 사용도를 낮출 수 있다  클라이언트  클라이언트 측에서 캐시된 버전의 오브젝트의 Date를 HTTP request에 명시   image \n서버  만약 해당 캐시된 오브젝트의 Date가 최신의 것이라면 Response에 해당 오브젝트를 포함하지 않음   image \n","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-http/","title":"Computer Networking - HTTP"},{"content":"Computer Networking - Network Multimedia\nComputer-Network-Multimedia Multimedia: Audio   아날로그 오디오 신호는 주기적인 속도로 샘플링 진행\n Telephone: 8000 samples/sec CD music: 44100 samples/sec    각각의 샘플들은 Quantized 된다\n image \n 즉 아날로그 → 디지털화 각각 Quantized 된 값들은 Bits 로 표현됨 계산법  8000 samples/sec 이고 256 (2^8) quantized values  8000 X 8 = 64000bps     원본 손실이 일어날 수 밖에 없음    Multimedia: Video  비디오: 일련의 이미지  24 images/sec 등   디지털 이미지: 픽셀들의 집합 인코딩: 이미지간의 중복을 이용해 비트 (용량)을 줄임  spatial  예를들어 N개의 같은 보라색 픽셀을 보내는 대신, (보라, N) 이렇게 색깔과 갯수만 보내는 형식   temporal  전의 이미지와 다음 이미지간의 차이점만 보내는 방식     CBR : 고정된 비디오 인코딩 레이트 VBR  가변적인 인코딩 레이트. spatial, temporal이 변화하는 것에 따라 가변적.    Multimedia Networking: 3 application types  Streaming: Stored audio, video  다운로드와 동시에 실행 가능 서버에 저장된 미디어 유튜브   Conversational voice/video over IP  Interactive Delay tolerance (딜레이 허용)이 제한됨 스카이프   Streaming live audio, video  라이브 스포츠 이벤트    Streaming stored video  image \nStreaming stored video: 도전점  한번 시작하면 버퍼링이 걸리지 않게 continuous 하게 해줘야 함  그러나 네트워크 환경은 계속해서 변하기 마련임 그래서 클라이언트 사이드에서 버퍼로 좀 쌓아뒀다가 플레이하는게 좋음   비디오 패킷이 유실될 수 있음 정지, 탐색, 리와인드 등 client interact  Streaming stored video: Client side buffering  image \n 어느 정도 버퍼가 차면 플레이 버퍼의 찬 정도는 가변적임 버퍼를 채우는 속도에 따라서 x(t)  x \u0026lt; r : 버퍼를 채우는 속도가 play하는 속도보다 느림  버퍼링이 걸림   x \u0026gt; r : 버퍼를 채우는 속도가 play하는 속도보다 빠름  버퍼가 비지 않을 것이기 때문에 버퍼링 일어나지 않음     initial playout delay tradeoff  초기 버퍼값을 높게 설정하면 버퍼링이 많이 걸리지 않을 수 있겠다 그러나 처음 영상을 재생할 때 까지의 시간이 많이 소요될 수 있다    Streaming multimedia: UDP  보통 send rate = encoding rate = constant rate 전송 속도는 혼잡도에 상관없다 TCP보다 상대적으로 적은 Playout delay 에러 복구가 필요하다면 애플리케이션 레벨에서 처리 UDP는 방화벽에 자주 막히는 문제가 있다  Streaming multimedia: HTTP (TCP)  image \n 혼잡 제어 때문에 전송속도가 가변적  좀 더 큰 Playout delay   방화벽에 잘 안막히는 장점 ","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-network-multimedia/","title":"Computer Networking - Network Multimedia"},{"content":"Computer Networking - Network TCP\nComputer-Network-TCP 1. TCP Overview  Point 2 Point  하나의 Sender, 하나의 Receiver   Reliable, In-Order byte Stream  메세지 크기 제한이 없음   Pipelined  TCP의 Congrestion Control과 Flow control에 의해 윈도우 사이즈 계속 변함   Full duplex data  양방향 통신 MSS: Maximum Segment Size   Connection-Oriented  Hand-Shaking을 먼저 해야함   Flow Controlled  Receiver가 핸들 가능한 정도로의 속도로 맞춰줌    TCP segment 구조  image \n Option은 거의 사용하지 않아 TCP의 헤더 사이즈는 보통 20Bytes  32bits = 4bytes    TCP 시퀀스 넘버, ACKs  GO back N 등에서는 패킷 단위로 번호를 매겼지만 여기서는 바이트 단위로 번호를 매김\n 시퀀스 넘버  image \n 해당 시퀀스의 첫번째 바이트의 Number  ACK 넘버  상대방으로부터 기대하는 다음 시퀀스 넘버 즉 Seq1 다음에는 Seq5를 기대할 것이므로 Ack5 Cumulative (누적되는) ACK  즉 Ack8을 받았다면 1~7바이트 까지는 정상적으로 받았다라는 것   Q. 만약 순서에 맞지않게 (Out of Order) 세그먼트들을 받았다면?  TCP 표준에는 정의되어 있지 않아 따로 개발자가 구현 필요    간단한 예시  image \n **\u0026lsquo;C\u0026rsquo;**라는 1Byte짜리 데이터를 주고받는 모습  TCP Timeout  Timer의 시간이 만료되면 패킷이 유실됬다고 판단, 재전송 Q. 얼마나 기다릴 것인가?  RTT (패킷이 갔다가 돌아오는 시간) 보다 커야함 그런데 RTT는 네트워크 상황에 따라 가변적임 너무 짧으면  타임아웃이 너무 빨리 걸림. 의미없는 재전송을 하게 됨   너무 길면  세그먼트 로스에 대해 늦게 대처하게 됨     Q. RTT를 예상할 순 없나?  SampleRTT  세그먼트를 실제로 한번 보내보고 Ack가 올때까지의 시간을 측정해 평균값 추정      TCP RTT  image \n image \n Exponential weighted moving average EstimatedRTT  SampleRTT들의 평균값   대략 이전의 평균 RTT에다 새로운 SampleRTT를 평균하되 가중치를 두어 평균하는 방법 이전의 값들은 시간이 지날수록 점점 더 영향력이 줄어듬 위 그래프에서 실제 SampleRTT보다 EstimatedRTT가 더 부드러운 곡선을 그리는 것을 알 수 있다 계산 예제  Est0 = 100, Sam1 = 100, Sam2 = 50, Sam3 = 200, Alpha=0.1 일 때 Est1, Est2, Est3를 구하라 Est1 = 0.9Est0 + 0.1Sam1 Est2 = 0.9Est1 + 0.1Sam2 Est3 = 0.9Est2 + 0.1Sam3    TCP Timeout  image \n image \n 실제 Timeout Interval = EstimateRTT + \u0026ldquo;추가 값 (Safety Margin)\u0026rdquo; |현재 측정값 - 평균 측정값의 절대값|  즉 현재 측정값과 평균 측정값의 차이가 많이 나면 마진을 많이 두고 아니라면 적게 두겠다는 뜻   최소 1초 이상은 나오게 되어있음  컴퓨터 입장에서는 1초가 긴 시간이기 때문에 다른 패킷 로스 디텍트 방식이 있음    TCP Reliable Data Transfer  IP (인터넷 프로토콜)은 RDT를 제공하지 않음 따라서 TCP는 해당 Unreliable한 서비스 위에서 RDT 서비스를 제공하고 있음  파이프라인 세그먼트 Cumulative Acks Single Retransmission timer  타이머를 하나만 씀     Retransmission Triggered by  타임아웃 발생 Duplicate Acks    TCP sender events  image \n TCP 소켓이 앱에서 데이터를 받을 때  세그먼트 넘버와 함께 세그먼트 생성 타이머가 작동중이지 않으면 시작시킴  가장 오래 Unacked 상태인 세그먼트라고 가정     타임아웃이 일어날 때  타임아웃이 일어난 세그먼트 재전송 타이머 재시작   Ack를 받을 때  새로운 Ack일 경우  Ack 된 (컨펌된) 세그먼트 체크 (SendBase 우측으로 이동) 아직 Unacked인 세그먼트가 있다면 타이머 시작      TCP 재전송 시나리오  image \n Premature timeout 설명  Sender: 타임아웃되어 Seq 92를 다시 재전송 Receiver: 사실 정상적으로 받아 Ack120을 돌려줌 Sender: Sendbase 120으로 맞춤 Receiver: 이미 받은 세그먼트를 다시 받았으므로, 마지막으로 성공한 Ack120을 다시 전송해줌  받을것으로 기대하는 넘버를 보낸다는 의미도 있음       image \n Cumulative ACK이기 때문에 ACK를 동시에 받았을 때 윗쪽 하나가 유실되더라도 Ack120 하나만으로 0~119까지 받았다는걸 알기에 정상작동  TCP ACK 생성  image \nTCP Fast retransmit  image \n 타임아웃은 1초 이상으로 꽤 김  패킷 로스에 대응해 재전송하기까지 딜레이가 길 수 있음   따라서 Duplicate ACKs가 발생하면 패킷 로스로 판단, 즉각 재전송 하겠다는 것 위의 예에서 Host B는 기대중이던 Seq number가 도착하지 않아 ACK100을 계속 재전송해줌 Host A는 그것으로 보아 패킷 로스가 일어났다고 가정하고 Host B가 지정해주는 (또한 가장 오래된 Unacked Seq인) 100번 세그먼트를 빠르게 재전송 ","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-network-tcp/","title":"Computer Networking - Network TCP"},{"content":"Computer Networking - Networking App\nComputer-Netowork-네트워크-앱 1. 네트워크 앱 작성 네트워크 앱은 각각의 엔드 시스템에서 동작  네트워크를 통해 통신 예) 웹 서버 소프트웨어가 브라우저 소프트웨어와 통신  네트워크 코어 디바이스들은 신경쓸 필요가 없다  네트워크 코어 디바이스들은 유저 애플리케이션을 실행하지 않음 오직 엔드 시스템들만 애플리케이션 레이어를 가지고 있으며, 이는 빠른 개발과 빠른 확산을 유도한다.  2. 클라이언트 - 서버 구조  image \n서버  언제나 가동 중 (이여아 함) 영구 IP 주소 주로 데이터센터를 사용  클라이언트  서버와 통신 항상 네트워크에 연결되어 있진 않음 동적 IP를 사용하고 있을 수 있음 클라이언트 끼리 직접적으로 통신하지 않음 (클라이언트 - 서버 구조에서)  3. P2P 구조  image \n 언제나 가동중인 서버가 없음 대등한 엔드시스템끼리 직접적으로 통신 다른 피어들에게 데이터를 요청하거나 제공할 수 있음 Self-Scalability  새 피어가 들어오면 그 피어는 서비스를 요구할 수 있을 뿐만 아니라 새 서비스를 제공할 수도 있음   피어끼리는 간헐적으로 연결되며 IP주소도 매번 바뀔 수 있다  유지 관리에 어려움이 있다    4. 프로세스 커뮤니테이션 프로세스  호스트에서 동작하고 있는 프로그램 같은 호스트에서, 프로세스들은 IPC (inter-process communication) 로 통신함 프로세스들이 서로 다른 호스트들에 있다면 메세지 (네트워크 기반) 를 통해 통신  클라이언트 프로세스  커뮤니테이션을 먼저 시작한 프로세스  서버 프로세스  클라이언트 프로세스가 연락한 것을 기다리는 프로세스  P2P에서는..  클라이언트 프로세스와 서버 프로세스 둘 다 가지고 있다  5. 소켓  image \n 프로세스는 소켓으로 메세지를 보내고 전달받는다 소켓은 마치 문과 같다  Sending Process는 메세지를 문 밖에다 던져놓는다 이 메세지는 Transport Infrastructure를 통해 Receiving Process에 전달된다    6. 주소 Processing  Receive 프로세스가 메세지를 받으려면 뭔가 Identifier가 필요하다 호스트 디바이스들은 각각 Unique한 IP 주소를 가지고 있다 Q. 그런데 IP주소만으로 프로세스에게 메세지를 전달하기 충분해?  아니오. 호스트에서는 여러개의 프로세스가 동작하고 있다.  그렇기에 포트가 필요한 것.      7. App-layer Protocol defines  통신할 메세지의 타입  수신이냐, 발신이냐   어떤 필드가 있는지, 어떻게 필드들이 정의될 것인지 (몇 비트, 어떤 타입) 각 필드가 어떤 의미를 갖는가 메세지를 언제 어떻게 받고 전달할 것인가  8. 오픈 프로토콜  HTTP, SMTP 등 RFCs에 정의되어 있음  9. 사적 프로토콜  Skype 등  10. App에게는 어떤 transport service가 필요한가  image \n데이터 무결성  어떤 앱들은 데이터가 어떠한 에러도 없이 신뢰성있게 전달해야 한다.  파일 전송 등   어떤 앱들은 약간의 loss를 허용할 수도 있다  오디오 등    타이밍  어떤 앱들은 데이터가 신속하게 전달되어야 한다  전화, 실시간 게임 등   어떤 앱들은 신속한 전달이 필요없다  이메일 등    Throughput (한번에 전달하는 데이터 크기)  어떤 앱들은 예를들어 10Mbps 이상의 속도를 보장해야 한다  유튜브 등등의 멀티미디어, 호스팅 서비스 등   어떤 앱들은 속도 보장이 그다지 필요없다 (elastic)  이메일 등    보안  메세지는 수많은 컴퓨터들을 통해 이동한다 암호화가 중요한 transport 서비스가 될 수 있다 ","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-networking-app/","title":"Computer Networking - Networking App"},{"content":"Computer Networking - P2P and Dash\nComputer-Network-P2P-and-Dash 1. Pure P2P 아키텍쳐  Always-On 서버 없음 임의의 엔드 시스템들이 서로 통신 (Peer) 피어들은 간헐적으로 연결되며 IP가 변경될 수 있음 예  Bittorrent VoIP    클라이언트-서버 VS P2P  Q. 사이즈가 F인 파일을 N개의 피어에게 전송할 때 얼마나 걸리나?\n 클라이언트-서버의 경우  image \n  서버의 입장에서\n  파일은 순차적을 보낸다.\n  한 개 보낼 때\n$$F/u_s$$\n  여러 카피 보낼 때\n$$N×F/u_s$$\n    클라이언트 입장에서\n dmin = 최소 클라이언트 다운 속도  $$F/d_{min}$$\n  결과\n$$D_{cs} ≥ max(NF/u_s,F/d_{min})$$\n  P2P의 경우   서버 역할 피어\n 일단 최소한 한 개의 파일은 업로드해야함  $$F/u_s$$\n  클라이언트 역할 피어\n$$F/d_{min}$$\n  최상의 경우\n 서버 역할 피어와 다른 모든 i개의 피어가 업로드 하고있을 경우  $$NF/(u_s+ \\sum u_i)$$\n  결과\n$$D_{P2P} ≥ max{F/u_s,F/d_{min},NF/(u_s + \\sum u_i)} $$\n  차이  image \n 클라이언트-서버 구조에서는 N이 커지면 전송시간 또한 선형적으로 커진다\n  그러나 P2P 구조에서는 N이 커져도 클아이언트-서버 구조처럼 드라마틱하게 전송시간이 늘어나지 않는다\n 2. 비트토렌트  image \n 파일은 256KB의 청크로 나뉘어짐 토렌트: 파일을 공유하는 피어들의 그룹 트래커: 토렌트 내부의 피어들의 참여도 등을 추적 토렌트에 처음 참여한 유저는 청크가 없다.  다른 피어들에게서 청크를 받으며 점점 채워나간다 트래커에게서 피어 리스트를 받은 후 일부 피어들과 통신함 (neighbor)   다운로드와 동시에 받은 청크를 업로드 가능 통신중인 피어들은 나가거나 새로 들어올 수 있다 파일을 다 받은 후에는 토렌트에 남거나 떠날 수 있다  비트토렌트 청크  요청  피어들은 각각 다른 파일들의 조각 (청크)을 가지고 있을 수 있다. 그러므로 피어들은 주기적으로 다른 피어들이 가지고 있는 청크의 리스트를 요청해 받는다 청크들을 요청할때는 최대한 레어한 청크부터 받는다.   전송  Tit-For-Tat  눈에는 눈 이에는 이 나에게 파일을 보내야 나도 너에게 보낸다   자신에게 가장 높은 속도로 청크를 보내고 있는 4명의 피어에게 청크를 전송한다  나머지에게는 전송하지 않는다 (Chocked)   해당 4명의 피어 리스트는 10초마다 한번씩 갱신된다 Optimistically Unchoke  30초마다 추가로 랜덤하게 피어를 골라 청크를 전송한다 해당 피어가 지금 4명의 피어 리스트에 있는 피어들보다 빠르다면  그 피어가 새로운 Top 4가 될 것        3. 비디오 스트리밍과 CDN 비디오 스트리밍  비디오 트래픽이 인터넷 Bandwidth를 가장 많이 잡아먹음 서비스 업체들의 고민  어떻게 수억명이 넘는 유저들을 다 수용하는가?  하나의 서버로는 절대 수용 못한다 (네임서버 기억)   유저마다 다른 환경  PC, 모바일 각기 다른 인터넷 속도 등     솔루션  분산된, 애플리케이션 레벨의 인프라 서비스 (DASH)    멀티미디어: 비디오  비디오란  고정된 속도로 디스플레이되는 연속된 이미지 예) 24프레임   이미지  픽셀의 집합 각 픽셀은 비트로 표현됨   코딩  이미지 간의 중복성을 이용해 이미지 비트를 줄임  Spatial  한 이미지 내에서 중복되는 픽셀을 이용   Temporal  프레임 간에 차이점을 이용     CBR VBR    DASH (Dynamic Adaptive Streaming over HTTP)  유튜브에서 인터넷 속도에 따라 저화질, 중화질, 고화질 변경하는 것을 생각\n SERVER  파일을 여러개의 청크로 쪼갬 각각 청크들은 각기 다른 속도로 인코딩 됨 Manifest file  각각의 청크들의 URL을 제공    CLIENT  주기적으로 서버-클라이언트 간 Bandwidth를 측정 그 속도를 기반으로 Manifest 파일을 보고 적절한 청크를 요청  지금 Bandwidth 내에서 수용가능한 최대 레이트를 고름 시간에 따라서 인터넷 속도가 달라질 수 있음  그때그때 청크의 레이트 변경하며 요청할 수 있다     클라이언트가 주도 (Intelligence)  언제 청크를 요청할 것인가  너무 빠르게 요청해 받으면 버퍼 오버플로우 발생 너무 늦게 요청해 받으면 버퍼가 비어 버퍼링 발생   어떤 레이트로  Bandwidth가 충분하다면 더 나은 화질 요청   어디에 청크를 요청할 것인가  클라이언트에서 물리적으로 더 가깝거나 더 빠른 회선의 서버에 요청 가능      수많은 요청 처리  CDN을 이용, 영상의 COPY들을 나눠 분산 처리\n  Enter Deep  엑세스 네트워크에 많은 CDN 서버를 둠 유저들에 더 가깝게   Bring Home  상대적으로 더 큰 몇개의 서버들을 엑세스 네트워크들 근처(POP)에 둠   네트워크 상황 등에 따라 각기 다른 CDN 노드를 선택해 사용 가능 고민  어떤 CDN 노드로부터 컨텐츠를 받을 것인가? 혼잡이 발생했을 때 Viewer는 어떻게 대처할 것인가? 이를 Over The Top (OTT) 라고 함 어떤 컨텐츠가 어떤 CDN에 위치할 것인가?    DNS를 통한 CDN 컨텐츠 엑세스  image \n 유저가 컨텐츠에 접속  http://video.netcinema.com/7FV50GAD   유저는 로컬 DNS 서버에 해당 주소의 IP를 찾기 위해 DNS 질의 질의 끝에 Netcinema의 Authoratative DNS 서버에서 CDN의 주소인 http://a1133.kingcdn.com 알려줌 로컬 DNS는 KingCDN의 DNS 서버에 다시 질의하고, CDN의 DNS 서버는 실제 CDN 서버의 IP를 알려줌 유저는 컨텐츠를 HTTP를 통해 스트리밍하며 받아봄  넷플릭스의 대략적 구조  image \n","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-p2p-and-dash/","title":"Computer Networking - P2P and Dash"},{"content":"Computer Networking - RDT and Pipelined Protocols\nComputer-Network-RDT-and-Pipelined-Protocols Reliable Data Transfer (RDT) What is RDT  image \n Transport layer provides reliable channel to application layer 그러나 Transport layer도 하위의 layer 기반이며, 이는 Unreliable channel이다.  그럼 Transfer layer는 어떻게 Reliable channel을 구현하는가?      udt_send()와 deliver_dat()는 RDT에서 직접 호출  ACTION 이라고 지칭   rdt_send()는 application layer에서, rdt_rcv()는 underline channel에서 호출  EVENT 라고 지칭    Let\u0026rsquo;s try to develop RDT  Assume we only need One-Way transfer  But control info will flow on both directions   Use Finite State Machines (FSM) to specify sender, receiver   FSM\n 상태를 중심으로 구현 교재에서는 이렇게 표시   image \n    RDT 1.0 : reliable tansfer 위의 reliable channel   하위 채널도 완벽하게 Reliable\n 비트 에러 없음 패킷 로스 없음    FSM을 이용해 Sender, Receiver를 표현\n image \n Sender는 하위 채널에 데이터를 전송 Receiver는 하위 채널로부터 데이터를 수신    그러나 실제로는 하위 채널은 Reliable하지 못함\n  RDT 2.0 : Channel with bit errors  하위 채널이 Reliable 하지 못함  비트 에러가 있을 수 있음   그렇다면 어떻게 에러를 복구하는가  ACks (acknowledgements)  Receiver가 명시적으로 Sender에게 패킷을 잘 받았음을 알려줌   NAKs (negative acknowledgements)  Receiver가 Sender에게 명시적으로 패킷에 에러가 있음을 알려줌   Sender는 NAKs를 받으면 패킷을 재전송해줌   RDT 2.0에서의 새 메커니즘  Error detection Feedback (ACK, NAK)     image \nBUT WHAT IF ACK|NAK corrupted?  Sender doesn\u0026rsquo;t know what happened at receiver  ACK인지 NAK인지 판별 불가능   Can\u0026rsquo;t just retransmit: possible duplicate  ACK를 받아야 위쪽에서 새 데이터를 받고 패킷을 만드는데 ACK인지 판별이 불가능하니 계속 같은 패킷만 재전송 할수도 있다   Duplicate 막기  Sender는 각 패킷에 Sequence number를 기입해둠 Receiver는 그 Sequence number를 보고 이미 받은 패킷이면 Discard 시킴    Stop and Wait Protocol  Sender sends one packet and waits for receiver\u0026rsquo;s response  RDT 2.1 : Sequence number로 중복 방지  image \n sndpkt = make_pkt(0, data, ckecksum), sndpkt = make_pkt(1, data, ckecksum)으로 sequence number까지 보내주는 모습 corrupt(rcvpkt)||isNAK(rcvpkt) 으로 ACK 혹은 NAK corrupt 체크  corrupt 되었다면 일반 NAK같이 치부함   Twice as many states (만약 seq가 2개라면 4개의 상태가 필요하다는 뜻)  State must remember whether expected packet should have seq number of 0 or 1     image \n Receiver는 받은 패킷이 중복된 패킷인지 체크해야 한다  0번의 패킷을 기다리는데 1번이 오거나, 1번의 패킷을 기다리는데 0번이 오면 extract 하지 않고 바로 ACK 패킷을 만들어 보내는 모습.  즉 Discard 해버린다     Receiver는 Sender가 ACK|NAK을 잘 전달받았는지 알지 못함  RDT 2.2 : NAK-FREE Protocol  image \n ACK만 사용함 기다리고 있는것과 다른 Seq number의 정보를 가진 ACK가 오면 NAK를 받은것처럼 처리  Sender 측에서는 현재 패킷 udt_send(sndpkt) 즉 전 절차에서 만들어진 make_pkt(0, data, checksum) 을 다시 보냄 Receiver 측에서도 현재 패킷 udt_send(sndpkt) 즉 전 절차에서 만들어진 make_pkt(ACK1, shksum)을 그대로 보냄으로서 NAK 역할을 하게 함    RDT 3.0 : ERROR, LOSS 모두 처리  Underlying channel can also lose packets  Data, ACKs 둘 다 LOSS 가능   Approatch  Sender waits \u0026ldquo;resonable\u0026rdquo; amount of time for ACK 시간안에 안오면 패킷 재전송 만약 패킷이 그냥 Delay 된거였다면 (not lost)  재전송된 패킷은 중복 패킷이 되겠지만, Sequence number 덕분에 그냥 Discard 해줄 것 Receiver must specify seq number of packet being ACKed     카운트 다운 타이머가 필요할 것      image \n start_timer로 \u0026ldquo;resonable\u0026rdquo; 한 시간동안 기다림  timeout 되면 패킷을 재전송하고 타이머 재시작   corrupt 되거나 잘못된 seq number의 ACK이 오면 그냥 무시 제대로된 ACK가 오면 타이머 멈추고 다음으로 넘어감  RDT 3.0 동작  image \n image \n 지금까지 혼동하고 있었는데 이걸보면 Sequence는 일련의 한정된 패킷에 넘버링 하는게 아니라, 버퍼 개념인 듯 하다. 즉 여기서는 버퍼가 두칸짜리고 이걸 계속 상위 레이어에서 데이터를 받아서 채우고 Receiver에 전달하는 것. (d)의 경우에는 ACK 전달이 Delay되었는데도 중간에 Seq num이 다른 패킷과 ACK는 무시함으로써 정상 작동하는 모습을 보여준다.  RDT 3.0 문제 : 퍼포먼스  image \n image \n 제대로 작동은 하지만 작동이 엄청 느리다 사실상 못쓴다 RTT  패킷을 보내고 답을 받는데까지 시간 2 X PropDelay   그러니까 실제 패킷을 전송하는데 할애한 시간인 L/R 에 전체 시간인 RTT + L/R을 나누면 효율을 알 수 있다.. 이말이다.  구해보니 효율이 처참하다.    Pinelined Protocols  Sender는 Ack를 받지 않더라도 계속 여러개의 패킷을 보낼 수 있음 TCP 프로토콜에 사용됨  Increased Utilization  image \n 3개의 패킷을 동시에 보내므로 효율성이 증가하였다 Receiver 측에서는 Ack를 보내긴 한다 다만 Sender 측에서는 패킷을 보낼 때 3개를 동시에 보내며, Ack를 받고 다음 패킷을 보낼때도 마찬가지다  Go-Back-N  최대 N개까지 Ack를 받지않고 패킷을 보낼 수 있다 Receiver는 Cumulative Ack만을 보낸다  예를 들어 Ack10이라는 Ack를 보냈다면 0~10까지의 패킷을 정상적으로 수신했다는 것 Gap 이 있으면 Ack 패킷을 보내지 않음  즉 만약 패킷1을 받았는데.. 패킷2가 전달이 되지 않은 경우? 패킷3이 전달되어 Ack를 보낼 때 Ack1을 보낸다.     한개의 타이머만 유지  타임아웃 발생하면, Ack로 정상 전송 여부가 판별되지 않은 모든 패킷을 다시 보낸다    Selective Repeat (SR)  최대 N개까지 Ack를 받지않고 패킷을 보낼 수 있다 Receiver는 각각의 패킷에 대해서 개별적인 Ack를 보낸다  예를 들어 Ack10이라는 Ack를 보냈다면 10번째 패킷을 정상적으로 수신했다는 것 그 이전의 패킷은 정상 수신여부 모름   각각의 패킷에 대해 타이머를 관리  타임 아웃이 발생하면 해당 Ack를 받지 않은 패킷만 다시 전송 오버헤드가 더 크다    Go-Back-N (GBN)\n Sliding Window Protocol 이라고도 부름\n Sender  image \n window : 최대 N개의 패킷을 보낼 수 있는 범위 send_base : 현재 Window에서 처음 보내는 패킷 nextseqnum : (상위 레이어에서 패킷이 아직 안와서) 다음에 보낼 패킷 설명하자면..  초록색은 Ack를 받고 정상 전송이 컨펌된 패킷들 노란색은 보내긴 했으나 Ack가 도달 안된 패킷들 파란색은 현재 Window 내에서 전송 가능한 가용 패킷 용량 하얀색은 아직 Window 범위 내에 있지 않아 사용 불가능한 칸이다.   만약 상위 레이어에서 데이터가 내려오면  Window 칸 모두 파란색이다  해당 패킷들을 만들어 보내고 그 수만큼 파란색 칸은 노란색이 되고 nextseqnum도 해당 수만큼 오른쪽으로 이동 보내놓은 패킷이 없어서 타이머가 종료된 상태였는데, 처음 패킷을 보냈으므로 타이머 시작   Window 내에 노란색도 있고 파란색도 있다  해당 패킷들을 만들어 보내고 그 수만큼 파란색 칸은 노란색이 되고 nextseqnum도 해당 수만큼 오른쪽으로 이동   Window 칸 모두 노란색이다  nextseqnum이 현재 window를 이탈한 상태라는 것 즉 가용한 패킷 용량을 다 사용했으므로 데이터 전송을 거부     만약 Ack가 도착하면  해당 Ack가 컨펌한 패킷들만큼 노란색 칸이 초록색 칸으로 채워지고 또 그만큼 send_base가 오른쪽으로 이동 window는 바뀐 send_base에 맞춰 그만큼 재설정됨   그랬는데 만약 모든 칸이 초록색이라면  모든 보낸 패킷이 Ack에 의해 컨펌되었으므로 타이머 종료   아직 컨펌되지 않은 패킷이 있다면  타이머 재시작     타임아웃이 발생하면  타이머 재시작하고 노란색 패킷들을 다시 보냄      Sender FSM  image \n 위에서 얘기한 내용을 FSM으로 표현한 것  Receiver FSM  image \n expectedseqnum : 받아야 할 패킷의 시퀀스 넘버 패킷이 순서대로 왔을 경우  제대로 수신된 제일 마지막 패킷을 기준으로 ACK 하나를 보냄 expectedsuqnum 하나만 기억하면 됨   패킷의 순서가 엉망인 경우  그냥 버려버리고 순서대로 제대로 온 패킷의 마지막 시퀀스 넘버 ACK를 보낸다    모식도  image \n Sender는 패킷 0,1,2,3 을 보낸다 Receiver는 패킷2가 Loss 됬으므로 마지막으로 제대로 수신된 패킷1의 ACK를 계속 보낸다. Sender는 ACK1를 받아 0,1은 컨펌됨을 알고 send_base를 2로 이동 그리고 그 과정에서 Window에 포함되는 4,5가 비는데, 데이터가 오면 전송시킨다 Receiver는 해당 패킷을 기대하는게 아니므로 계속해서 패킷1의 ACK를 보냄 그러다보면 타임아웃이 일어남 Sender는 타이머를 재시작하고 Ack로 컨펌되지 않은 2,3,4,5 패킷을 보냄 Receiver는 기대하고 있는 패킷이 왔으므로 수신 작업을 함  Selective Repeat (SR) Go-Back-N 과의 차이점  Receiver  개별적으로 패킷을 ACK 처리 순서대로 오지 않은 패킷도 버퍼함  즉 패킷9를 받지 못하고 패킷10을 받았을 때에도 버퍼에 패킷10을 저장해두었다가 패킷 9가 오면 한꺼번에 올려줌     Sender  각각의 패킷에 대해 타이머를 유지 관리 타임아웃이 오면 해당 패킷만 재전송    Sender / Receiver  image \n모식도  image \n Sender가 패킷 0,1,2,3 보냄 패킷2에 로스가 일어남 Receiver는 패킷 0,1,3 받고 각각 Ack 보냄. 패킷3은 버퍼에 들어감 Sender는 0,1이 컨펌된것을 인지하고 Sender_base를 2로 옮김 (단 Ack3의 경우에는 Ack2가 아직 도달 안했으므로, 패킷3이 전송 잘 되었다는것만 기억.) 그 과정에서 포함되는 4,5 자리. 데이터가 오면 패킷 4,5로 전송 Receiver는 패킷을 받고 버퍼에 저장. Ack 4, Ack 5도 전송함 패킷 4,5도 잘 전달되었다는 것을 기억. Sender는 패킷2 타이머가 타임아웃됨을 인지 따라서 패킷2를 재전송 Receiver는 패킷2를 받고 버퍼에 있던 패킷들과 함께 상위 레이어로 전송, Ack2를 Sender에 전해줌  문제점  시퀀스 넘버를 잘 써야한다.\n  image \n 위같이 시퀀스 넘버를 짤 경우, Receiver 입장에서는 Sender의 사정을 알 수 없으므로 처음 패킷0,1,2에 대한 Ack들이 통째로 로스될 경우..  Sender는 재차 기존 패킷0,1,2를 재전송하고 Receiver는 그 재전송된 패킷이 새로운 칸의 0,1의 패킷으로 생각하고 버퍼에 넣어버린다.   그래서 시퀀스 넘버 Range는 Window 사이즈보다 두 배 이상 커야 한다. ","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-rdt-and-pipelined-protocols/","title":"Computer Networking - RDT and Pipelined Protocols"},{"content":"Computer Networking - Socket Networking and Transport Layer\nComputer-Netowork-Socket-Networking-and-Transport-Layer 1. Socket Programming Socket Door between applicationp process and end to end transport protocol\nSocket delivery flow Make a messsage → Send it to sender socket → will be delivered automatically to the socket of the receiver → Receiver will get message thru its own socket\nSo, you don\u0026rsquo;t need to worry about much things You only need to specify source address, destination address, and message which will be attached on socket.\nRest of parts will be done by transport infra.\nTwo socket types  UDP  Unreliable Datagram   TCP  Reliable Byte stream-oriented  Imagine there is some pipe between sender and receiver Sender ←→ Receiver And datagrams flow thru the pipeline, being oriented      UDP: \u0026ldquo;No connection\u0026rdquo; between client ↔ server  No Handshaking before sending data Sender (Can be both Server or Client) attaches IP destination address and port number to each packet Receiver extracts sender IP and port number from received packet Packet can be lost or received un-ordered status. (not guaranteed)  How UDP interacting  image \nActual Python Code (UDP) # UDP CLIENT from socket import * serverName = \u0026#39;hostname\u0026#39; serverPort = 12000 clientSocket = socket(AF_INET, SOCK_DGRAM) message = raw_input(\u0026#39;Input lowercase sentence:\u0026#39;) clientSocket.sendto(message.encode(), (serverName, serverPort)) modifiedMessage, serverAddress = clientSocket.recvfrom(2048) # receive from. will be blocked until it receives some datagram print modifiedMessage.decode() clientSocket.close() # UDP SERVER from socket import * serverPort = 12000 serverSocket = socket(AF_INET, SOCK_DGRAM) serverSocket.bind((\u0026#39;\u0026#39;, serverPort)) print (\u0026#39;The server is ready to receive\u0026#39;) while True: message, clientAddress = serverSocket.recvfrom(2048) modifiedMessage = message.decode().upper() serverSocket.sendto(modifiedMessage.encode(), clientAddress) TCP: \u0026ldquo;Creating TCP connection between client↔server\u0026rdquo;  Client must contact server first  So, server process should be run first, with its socket to welcome client\u0026rsquo;s contact Client contacts server by creating TCP socket, specifying IP address, port number of server process (with connect function in python)   Server creates saparated TCP socket for each clients  allows server to talk with multiple clients source port numbers used to determine clients   TCP provices reliable, in-order byte stream transfer (\u0026ldquo;pipe\u0026rdquo;) between client ↔ server  How TCP interacting  image \n 서버 소켓은 Close되지 않고 클라이언트 소켓을 위해 언제나 열려있을 것임  Actual Python Code (TCP) # Client from socket import * serverName = \u0026#39;servername\u0026#39; serverPort = 12000 clientSocket = socket(AF_INET, SOCK_STREAM) clientSocket.connect((serverName,serverPort)) sentence = raw_input(\u0026#39;Input lowercase sentence:\u0026#39;) clientSocket.send(sentence.encode()) modifiedSentence = clientSocket.recv(1024) print (‘From Server:’, modifiedSentence.decode()) clientSocket.close() # Server from socket import * serverPort = 12000 serverSocket = socket(AF_INET,SOCK_STREAM) serverSocket.bind((\u0026#39;\u0026#39;,serverPort)) serverSocket.listen(1) # begins to listen for incoming TCP requests print \u0026#39;The server is ready to receive\u0026#39; while True: connectionSocket, addr = serverSocket.accept() # blocked waiting imcoming requests sentence = connectionSocket.recv(1024).decode() capitalizedSentence = sentence.upper() connectionSocket.send(capitalizedSentence.encode()) connectionSocket.close() 2. Transport Layer Tranport services and protocols  Manage logical commucation between app process running on different hosts  Those Two hosts may not physically connected   Transport protocols run in end systems  Not in routers Send side: breaks app messages into segments, and passes to network layer Receiver side: Reassembles segments into messages, passes to app layer   More than one transport layer can be available: UDP and TCP  Transport vs Network Layer ★ Network Layer  Logical communication between hosts  Transport Layer  Logical communication between processes (programs) Relies on network layer servcies  Internet Transport-Layer Protocols  딜레이, 전송 속도는 TCP, UDP 둘 다 보장 안됨\n TCP  Congesion control  네트워크가 혼잡할 때 Sender의 속도를 줄여 혼잡을 완화   Flow control  Sender가 너무 빠르게 Stream을 보내지 않도록 속도를 조절 Receiver가 받는 속도가 느리면 패킷로스가 일어날 수 있기 때문   Connection setup  UDP  No extensions  3. Multiplexing and Demultiplexing  여러개의 소켓에서 전송되고 받는 데이터를 Handle하기 위함\n  image \nMultiplexing  Handle data from multiple sockets, add transport header  Demultiplexing  Use transport header info to deliver received segments to correct socket  How Demultiplexing works  Each datagram has source IP address and destination IP address Also datagram carries one transport-layer segment  which has source, destination port number   So, host uses IP address \u0026amp; Port numbers to direct segment to appropriate socket  Connectionless demultiplexing: \u0026ldquo;Used in UDP\u0026rdquo; !Recall  클라이언트 소켓이 만들어질때는 OS가 클라이언트 소켓에 포트 넘버를 자동 할당 서버 소켓을 만들 때는 Bind 함수로 포트번호 할당 가능  OS에서 포트 넘버 할당 Bind() 함수로 포트 넘버 할당   Sendto() 함수를 사용하기 위해서는  IP 주소와 포트 넘버를 명시해줘야 한다    SO.. When host receives UDP segment  image \n Checks destination port number in segment  만약 각기 다른 Source IP, Port에서 온 데이터그램들이 같은 Destination Port를 가지고 있다면, 그냥 해당 Destination의 소켓으로 모두 전달한다. 즉 UDP에서는 간단하게 말하면 포트 넘버만 보고 Demux를 한다고 볼 수 있다.   And directs UDP segment to socket with that port number  Connection-Oriented Demultiplexing: \u0026ldquo;Used in TCP\u0026rdquo; TCP socket identified by 4-tuple  image \n Receiver uses all four values to direct segment to proper socket\n  Source IP Source Port # Destination IP Destination Port #  Server host  May support many simultaneous TCP sockets May have different sockets for each connecting client  Non-persistent HTTP will have different socket for each request   ","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-socket-networking-and-transport-layer/","title":"Computer Networking - Socket Networking and Transport Layer"},{"content":"Computer Networking - TCP Congestion Control\nComputer-Network-TCP-Congestion-Control Principles of congestion control 정의  너무 많은 Source들이 너무 많은 데이터를 너무 빨리 보내 네트워크가 감당이 안되는 상황 Flow control과는 다르다 패킷 유실, 긴 딜레이가 발생할 수 있다  시나리오 1  image \n시나리오 2  image \n image \n image \n image \n혼잡이 발생하면  \u0026ldquo;Goodput\u0026quot;을 위해 재전송이 자주 필요할 수 있다 필요하지 않은 재전송도 일어날 수 있다  \u0026ldquo;Goodput\u0026quot;의 효율을 떨어뜨린다    시나리오 3  image \n image \n혼잡이 발생하면  만약 패킷이 드롭되면, 해당 모든 상위의 Transmission capacity들의 효율이 떨어지게 된다.TCP Congestion Control   Additive Increase, Multiplicative Decrease\n  증가시킬때는 천천히, 감소시킬때는 빠르게\n   Sender는 전송 속도 (윈도우 사이즈)를 계속 늘려 Bandwidth를 증가시키고, 패킷 로스가 일어나면 윈도우 사이즈를 줄인다\n Additive increase  cwnd (congestion window)를 패킷 로스가 감지될 때 까지 1MSS 만큼 매 RTT마다 늘린다   Multiplicative decrease  패킷 로스가 감지되면 cwnd를 반으로 줄인다     image \n 최대한 Max bandwidth를 쓰겠다는 노력..    1. TCP Congestion Control: detail  image \n 기억하자!  TCP의 경우 Cumulative (누적) Ack를 쓰기 때문에 초록 노랑 섞이지 않음   Sender 전송 속도 제한   image \n  cwnd (congestion window) 는 네트워크 혼잡도에 따라 가변적\n  TCP Sending Rate\n 대충 RTT 당 cwnd 만큼 보냄   image \n cwnd를 늘리거나 줄임으로서 혼잡도 회피    2. TCP Slow Start   처음에는 cwnd = 1 MSS (1460bytes 정도)로 시작 (작은 크기)\n  이를 지수적으로 증가시킴\n 각각의 RTT마다 cwnd를 두배씩 증가시킴 이는 ACK를 받을 때 마다 +1를 해줌으로서 가능   image \n  3. TCP: 패킷 로스 검출, 반응  타임아웃 발생  cwnd를 1 MSS로 줄임 다음 다시 지수적으로 증가시킴 (threshold=8 까지) (1..2..4..8..) threshold에 도달하면 선형적으로 증가시킴 (9..10..11..12) → congestion avoidence   3개의 중복 ACK가 발생  TCP Tahoe  타임아웃 발생시와 같이 처리   TCP RENO  cwnd를 반으로 줄이고 선형적으로 증가시킴      4. Slow start → CA (congestion avoidence)  image \n 위를 보면 패킷로스 이벤트가 발생하자  ssthresh가 패킷로스가 일어난 값의 1/2로 재설정되었다 TCP Tahoe의 경우  cwnd가 1로 초기화 되고 지수적으로 증가 ssthresh에 도달하자 선형적으로 증가   TCP Reno의 경우  cwnd가 1/2로 재설정되어 바로 선형적으로 증가      TCP 혼잡 컨트롤 요약  image \nTCP 쓰루풋  image \n Slow start 없다고 가정, 보낼 데이터가 항상 있다고 가정 W (window size) 이상이면 패킷 로스가 일어난다고 가정 평균 쓰루풋 = 3/4 * W per RTT  TCP Features: TCP over \u0026ldquo;Long, Fat Pipes\u0026rdquo;   예를들어 1500 byte segments, 100ms RTT에 10 Gbps 쓰루풋을 원할 때\n  윈도우 사이즈가 83,333이 되어야 가능\n  세그먼트가 로스된다면?\n image \n  2의 10승 당 하나의 로스만 발생해야 한다고 함\n  이는 비현실적임\n  TCP 공평성  TCP는 공평성을 가지고 있다   image \n 연결 1,2가 같은 네트워크를 사용한다고 했을 때  처음에는 쓰루풋이 달라도 패킷로스 등을 거치며 slow start, CA 등으로 쓰루풋이 equal bandwidth로 수렴된다    공평성의 장단점  멀티미디어 앱들의 경우 혼잡도 컨트롤 때문에 속도에 지장받는걸 원하지 않음  따라서 UDP를 많이 사용   Parallel TCP  어플리케이션은 병렬적으로 연결을 맺어 속도를 향상시킬 수 있음 (꼼수같다..?) 예를 들어 이미 9개의 TCP 커넥션이 있는데, 새 앱이 1개의 TCP만 연결한다면  R/10 만 배당받는 셈   그런데 새 앱이 TCP를 9개 열어버리면  R/2를 할당받는 셈   웹 브라우저에서 자주 사용    Explict Congestion Notification (ECN)  네트워크가 도와주는 혼잡 컨트롤 (일부 구현)\n  라우터들이 혼잡 상황을 판단, Source와 Destination에 알려줌 IP 헤더에 ToS 필드가 있는데 이것을 사용   image \n 위를 보면  Source에서는 ECN=00 으로 세팅되어 전송됨 만약 네트워크에 혼잡이 있다면 중간에 라우터에서 이를 ECN=11으로 바꿈 Destination에서는 패킷을 받아보고 ECN이 설정되어 있다면 ECE=1 (ECN echo) 설정해 ACK를 보내줘 Source에게도 네트워크에 혼잡이 있다는 것을 알려줌   ","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-tcp-congestion-control/","title":"Computer Networking - TCP Congestion Control"},{"content":"Computer Networking - Transport Layer Protocols\nComputer-Netowork-Transport-Layer-Protocols 1. TCP 서비스 신뢰성 있는 전송 Flow control  Sender가 메세지를 너무 빨리 보내지 않게 (Receiver가 데이터 처리가 느릴 경우 데이터 loss 없이 온전히 받을 수 있게) 전달하게 해줌 Sender와 Receiver 1:1 관계  Congestion control  네트워크의 관계 각 Sender가 네트워크의 혼잡을 방지하기 위해 Sending 속도를 줄여줌  타이밍, 최소한의 Throughput, 보안 관련 서비스는 제공해주지 않음 Connection-oriented  TCP는 우선 클라이언트 - 서버 상에 연결을 맺고 메세지를 주고받는다  2. UDP 서비스 신뢰성 있는 전송 보장해주지 않음 아무 서비스도 보장해주지 않는다 왜 쓰냐 그럼?  헤더 사이즈가 작고 빠르게 전송 가능 요즘 네트워크가 좋아져서 대부분 잘 가기 때문   image \n12. TCP 프로토콜 보안 적용하기 TCP \u0026amp; UDP  메세지를 암호화하지 않음  SSL  별도의 라이브러리 암호화된 TCP 연결 제공 데이터 무결성 사용자 인증  SSL은 애플리케이션 레이어  유저 애플리케이션 밑에 SSL, 그 밑에 TCP ","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-transport-layer-protocols/","title":"Computer Networking - Transport Layer Protocols"},{"content":"Computer Networking - UDP\nComputer-Network-UDP 1. UDP  \u0026ldquo;BARE BONES\u0026rdquo; Protocol  No extentions Almost like IP + DATAGRAM   \u0026ldquo;Best effort\u0026rdquo; service  UDP segments can be lost Delivered as out-of-order   No hand-shaking between UDP sender and receiver each UDP segment handled independently  UDP usages  Streaming multimedia app  Timing is important, so fast deliver is required Some loss of packets is okay   DNS SNMP  간이 망 관리 프로토콜 네트워크 관리 및 정보 수집을 위한 표준 프로토콜    Reliable transfer over UDP  implement yourself at application layer  UDP segment header  image \n Header size : 8bytes  Why is there a UDP?  No connection establishment  No delay for hand-shake   Simple: No connection state at sender, receiver Small header size  Header size of TCP is 20bytes   No congestion control  Can be delivered as fast as desired    UDP Shecksum  세그먼트들을 16비트 정수로 간주해서 모두 더해 체크섬을 만듬 Sender와 Receiver가 각각 체크섬을 계산, 비교해 에러가 있는지 확인 체크섬은 헤더의 체크섬 Bit에 탑재되어 전송됨  Goal  To detect Errors  Sender  헤더 필드를 포함한 모든 세그먼트 내용을 16비트 정수로 간주함 체크섬: 모든 세그먼트 내용들을 더한 결과  1의 보수를 이용   Sender는 Checksum 결과를 UDP Checksum Field에 넣음  Receiver  전달된 세그먼트들의 체크섬을 다시 직접 계산 직접 계산한 체크섬이 전달받은 체크섬 값과 동일한지 확인  NO - error detected YES - no error detected\u0026hellip; maybe    Example  image \n 두 세그먼트를 더한다  남는 오버플로우된 비트가 있다면 결과값의 제일 하위 비트에 더한다.   모든 비트를 Flip한다 그럼 체크섬이 된다 ","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-udp/","title":"Computer Networking - UDP"},{"content":"Computer Networking - VOIP\nComputer-Network-VOIP VOIP  \u0026lsquo;통신 가능한\u0026rsquo; 만큼의 딜레이 관리가 필요  D \u0026lt; 150ms : Good D \u0026gt; 400ms : bad   Session initialization  어떻게 전화하는 사람이 IP, 포트, 인코딩 알고리즘을 전달하는가?   Value-Added Services  Call forwarding, screening, recording\u0026hellip; Emergency call    VOIP 특징  Speaker\u0026rsquo;s audio  번갈아가면서 말함 한 사람이 말하면 한 사람은 침묵하면서 들음 64 kbps during talking  Multimedia: Audio 참고 오직 말할때만 패킷 생성 20ms chunks at 8Kbytes/sec (64kbps) → 160 bytes of data  Talk spurt에서각 20ms 마다 160바이트의 데이터가 생성 거기에 UDP나 TCP 등의 헤더가 붙음 앱은 매 20ms마다 소켓에 세그먼트를 보내게 됨        VOIP: Packet loss, delay  네트워크 혼잡 때문에 데이터그램 유실 소리가 듣는 사람한테 너무 늦게 도착  보통 400ms 내에 도착해야함   어떤 인코딩을 쓰느냐, 어떤 Loss 보간법을 쓰느냐에 따라 1~10퍼센트 까지 유실 허용  VOIP Buffer  image \n VOIP 역시 버퍼를 사용해 끊김을 방지한다 그렇다면 Playout delay의 양은 어느 정도가 좋을까?  VOIP: Fixed playout delay  image \n q라는 고정된 딜레이 값을 사용 q 이상으로 딜레이가 발생한다면 해당 패킷은 필요없으므로 버림 너무 큰 값을 사용하면 딜레이 커짐, 적은 패킷 유실 작은 값을 사용하면 소통은 잘 되나 패킷 유실이 많이 일어날 수 있음  VOIP: Adaptive playout delay   목표\n Low playout delay low late loss rate    네트워크 딜레이를 계속 추정 + 마진을 넣어 딜레이를 가변적으로 적용\n 각 Talk spurt 첫부분에 딜레이를 적용 Slience 구간이 지난 이후 다음 Talk spurt이 시작 될 때 딜레이를 재계산하여 적용    패킷 딜레이 계산 방법\n image \n TCP RTT 추정할 때 그 방식 그대로 씀    Receiver가 Talkspurt 시작점 판별하는 방법  패킷 유실이 없다면, 타임스탬프 확인  Talkspurt 내의 패킷들은 20ms 간격임 그 이상 딜레이가 있었다는 것은 그 사이에 Silence 구간이 있었다는 것  Seq1 →(40ms)→ Seq2     패킷 유실이 있었던 것 같다면  타임스탬프 뿐만 아니라 시퀀스 넘버도 확인 Seq1 →(40ms)→ Seq3    VOIP: 패킷 로스 복구  VOIP는 딜레이가 많이 없어야함  기존의 ACK/NAK 방식은 딜레이가 많이 걸릴 수 밖에 없음 그럼 어떻게 복구해야 할까?  Foward Error Correction (FEC)  재전송을 하지 않고 충분한 비트를 미리 보내서 보낸 데이터를 바탕으로 복구        Simple FEC  N개의 청크 그룹마다 하나의 추가적인 청크를 만듬  원본 청크들를 XOR하여 만듬 결과적으로 N+1 개의 청크가 되어 Bandwith도 1/N 늘어나는 셈   예시) 1010이라는 청크가 있다고 하면 → 10100 으로 됨   각각의 자리를 XOR하여 비트를 만듬\n image \n  만약 10X00 으로 하나의 청크가 로스되었다면?\n 정상적으로 수신한 청크들을 다시 각각의 자리로 XOR하면 로스된 패킷을 알 수 있음     조건 : N+1에서 최대한 1개까지 패킷 로스됬을 때 복구 가능 또 N이 커질수록 패킷 유실 확률이 커지므로 적절한 값 정해야 함  PiggyBacking FEC  숟가락 얻는 방식   image \n 보낼 때 다음 청크에 Original Stream에서 더 낮은 음질의 백업 음성을 추가로 송신 만약 한 청크가 유실되면 다음 청크의 예비 음성을 이용해 복구 한개의 예비 음성 뿐만 아니라 구현에 따라 두개 세개도 가능  Interleaving 방식  뒤섞이는 방식   image \n 예를들어 20ms 단위 청크로 송신하던 것을 다시 5ms 단위로 쪼개어 뒤섞어 재구성 그 다음 받을 때 다시 원래 순서로 맞추어 재생하는 방법 이렇게 송신하면 만약 한 청크가 유실되더라도 뒤섞여있었기 때문에 중간중간 구멍이 작아 사람의 입장에서는 통신에는 아무 지장이 없다는 것 단점은 Playback 딜레이가 커진다는 것  충분한 청크들을 모두 받아야 재구성 가능하기 때문    Skype  사설 프로토콜   image \n P2P 컴포넌트들  클라이언트  서로간에 직접 연결하여 통화   수퍼노드  특별한 기능을 가진 스카이프 Peer 자신에게 접속해있는 클라이언트 리스트 유지   오버레이 네트워크  수퍼노드들은 서로간에 네트워크를 형성 서로 유저 리스트 등 보관 및 공유   스카이프 로그인 서비스   동작 방법  수퍼노드에 접속 (TCP) 로그인 서버를 통해 로그인 수퍼노드를 통해 전화할 유저의 IP 주소 가져옴 얻은 IP 주소를 통해 전화   문제  전화할 두 사람이 NAT 뒤에 있다면?  Peer in NAT → Peer out of NAT : 연결 가능 Peer out of NAT → Peer in NAT : 연결 불가능   그래서 수퍼 노드를 이용해 중개하는 방식을 씀  A Peer in NAT → 수퍼노드 A B Peer in NAT → 수퍼노드 B 수퍼노드 A ↔ 수퍼노드 B      RTP Real Time Protocol  실시간 데이터를 전송하기 위해 사용하는 프로토콜 Audio, Video 전송하는 패킷 구조를 정의 RTP 패킷  Payload Type 정의  Video Audio..     RTP는 엔드 시스템에서 동작 UDP가 사용됨 두 VOIP 어플리케이션이 RTP를 사용한다면 호환 가능할지도  RTP example  Sending 64 kbps PCM-encoded voice over RTP  Application collects encoded data in chunks  Every 20 msec = 160 bytes in a chunk   Audio chunk + RTP header from RTP packet in UDP segment   RTP header indicates type of audio encoding in each packet  Sender can change encoding during conference   RTP header contains seq_num, timestamps  RTP and QoS  RTP는 QoS 보장 되지 않음 중간의 라우터들은 RTP 인식하지 않음  Best-Effort 만 할거임    RTP 헤더  image \n Payload Type: 어떤 타입의 미디어인가 (보이스.. 미디어\u0026hellip;)  Payload type 0: PCM mu-law, 64 kbps Payload type 3: GSM, 13 kbps Payload type 7: LPC, 2.4 kbps Payload type 26: Motion JPEG Payload type 31: H.261 Payload type 33: MPEG2 video   Sequence number  RTP 패킷 별로 하나씩 증가 패킷 로스가 감지되면 FEC를 통해 에러 복구 등 실행   Timestamp  실제 시간이 아님 (Sampling instant)  RTP 패킷에 있는 첫번째 바이트의 Sampling instant Audio의 경우, 타임 스탬프는 각 Sampling period마다 하나 씩 증가  예) Each 125 usecs for 8 KHz sampling clock   if app generates chunks of 160 encoded samples, timestamp increases by 160 for each RTP packet when source is active Timescamp clock continues to increase at constant rate when source is inactive     SSRC field  Source의 Unique ID    RTCP  RTP와 옵션적으로 사용 RTCP 패킷은 Sender, Receiver의 Statistics를 포함  얼마의 패킷을 보냈고, 얼마의 패킷이 로스됬고 등등..   Sender가 동작 제어 하는데 도움이 된다  RTCP: 패킷 타입  Receiver report packets  패킷 로스, 마지막으로 받은 시퀀스 넘버 등   Sender report packets  현재 시간, 보낸 패킷들, 보낸 바이트 등   Source description packets  Sender의 메일, 이름 등등..    RTCP: 동기화  Voice, Video 동기화 가능 (싱크)  RTCP: Bandwidth scaling  RTCP는 전체 대역폭의 5%만 차지하자 너무 많이 리포트 보내면 메인 미디어 대역폭을 너무 잡아먹으니 Example: Sender가 2Mbps로 데이터를 보낸다면  100Kbps만 RTCP가 쓰자  여기서도 75%는 Receiver가, 25%만 Sender가 쓰자  여기서도 Receiver가 많을 수 있기에 이 75Kbps를 균등하게 나눠 사용       ","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-voip/","title":"Computer Networking - VOIP"},{"content":"Computer Networking - VOIP-SIP\nComputer-Network-VOIP-SIP SIP : Session Init Protocol  모든 전화, 비디오 콜이 인터넷 통해서 이루어지도록 번호보다는 이름이나 이메일로 신원 확인 전화 받는 사람(Collee)가 어디서든, 어떤 장치를 쓰던 Reachable 하게  SIP 서비스들  Call 셋업 시 SIP가 제공하는 메커니즘들  Coller가 Collee에게 전화하고 싶다는 사실을 Collee에게 알려줌 이로서 미디어 타입, 인코딩 방식 등 협의 전화 종료   mnemonic (의미있는) 식별자들을 IP 주소로 변경  이메일, 이름 등   통화 관리  새로운 미디어 스트림 추가 (음성 → 비디오 전화 등) 인코딩 방식 변경 다른 통화상태 추가 전화 홀드, 전달 등    Example  image \n 인코딩 협상  만약 상대방이 요청한 인코딩을 자신의 시스템이 지원하지 않는다면 606 Not Acceptable  상대방은 다른 인코딩 방식을 설정해 새 INVITE 메세지를 보낼 수 있음     RTP(UDP) 뿐만 아니라 TCP도 사용 가능  이름 변환, User Location  Collee의 IP 주소를 알아내야 하는데 IP는 계속 바뀜  USER는 돌아다니고 DHCP 프로토콜 기기마다 다른 IP    SIP registrar  image \n 사용자가 SIP Client를 실행시키면 클라이언트는 SIP REGISTER에 메세지를 보내 등록  SIP Proxy  Local DNS Server와 유사한 역할 Alice가 프록시 서버로 invite 메세지를 보내면  해당 메세지는 상대방 Bob의 주소(이름)을 포함 프록시 서버는 다른 프록시 서버 등을 통해 라우팅하여 Bob에게 메세지 전달 Response를 받으면 다시 그것을 Alice에게 전달  Response에는 Bob의 IP가 포함      SIP example  image \nNetwork and Multimedia Multimedia support of network  image \n Best Effort  None services available   Differentiated service (서비스 차등화)  Soft Guarantee available Packet Marking  패킷에 중요도 마킹   Scheduling policing 복잡성 중간. 조금 사용   Per-connection QoS  Hard Guarantee available Packet Marking Scheduling policing Call admission  보장해줄 수 있다면 허용, 아니라면 통신 비허가   복잡성이 높아 실제로는 사용 거의 안함    Best effort networks  충분한 용량을 줘서 딜레이나 로스 없이 하겠다 좋은 라우터, 링크로 하겠다 비용이 많이 듬 Challenges  그럼 얼마만큼의 bandwith가 충분한 양인가? 트래픽 추정도 필요함    Class of Service  서비스에 클래스를 두어 차등화하겠다 클래스 별로 다른 서비스를 제공  Class of Service : Sinario 1  image \n VOIP의 경우 실시간성 데이터이므로 우선순위가 높아지면 좋음 VOIP인지 HTTP 클래스인지 식별하기 위해 Packet Marking 사용  Class of Service : QoS garantees  image \n 그런데 VOIP에 우선순위를 높게 줬더니 링크 캐퍼시티를 전부 사용해버린다면?  HTTP 연결은 아예 못하게 되어버림 그러므로 QoS policing를 주어 연결속도 제한    Class of Service : QoS Problem  image \n 그런데 예를들어 VOIP에 1Mbps, HTTP에 0.5Mbps 식으로 고정적으로 할당해버리면  만약 VOIP가 Idle 상태일때도 HTTP는 0.5Mbps만 사용 가능 그러므로 링크 낭비 따라서 최대한 효과적으로 사용할 수 있는 방법 궁리해야함    Packet Scheduling  image \n image \n 큐에 쌓인 패킷들 중에 어떤 패킷을 보낼 지 정하는 것 (지난학기때 배움) 방법들  FCFS (선입선출) Simple Multi-Class Proirity Round robin Weighted fair queueing (WFQ)    Policing mechanisms  QoS 정책 평균 패킷 제한  (장기적으로) Unit time 당 얼마나 많은 패킷을 보낼 수 있는지 결정   Peak Rate  분당, 초당 얼마의 패킷을 보낼 수있는지 결정   Burst size  한번에 (연속적으로) 패킷을 보낼 때 얼마나 많이 보낼 수 있는지 결정    Policing mechanisms: Token bucket  Token bucket : 제일 많이 사용 방법론  가상의 통이 있는데 여기에는 티켓이 1초당 10개 생성됨 패킷이 지나갈 때 마다 티켓을 한장 소모하고 가야함 만약 가상의 통이 비어있다면 (티켓이 없다면) 패킷은 티켓이 생길 때 까지 대기했다가 지나가야함   티켓(토큰)이 생성되는 시간을 통해 속도 조절  초당 A개의 토큰을 생성한다면 패킷도 초당 10개 지나갈 수 있음   통의 크기를 조절해 Burst Size 조절  통의 크기가 B라면, Burst Size도 B  기다리는 시간 없이 연속적으로 보낼 수 있는 양     따라서 주어진 T 시간에 대해 보낼 수 있는 패킷의 양은  A * T + B    Policing and QoS Guarantees  Tocken bucket과 WFQ를 같이 쓰면 라우터 큐 딜레이의 Guaranteed upper bound를 구할 있다   image \n 즉 Dmax of Red = b / ((W1)/W1+..+Wn) * R)  Differentiated Services  차등화된 서비스 제공 간단한 펑션은 네트워크 코어에 유지하고, 복잡한 펑션은 엣지 라우터나 호스트에 유지 직접 클래스를 구현하진 않고, 클래스를 만들 수 있는 기능들을 정의  Diffserv Architecture  Edge Router  Flow 별 트래픽 관리 패킷 마킹  in-profile  Flow가 선언한 만큼의 속도 안에서 쓰고있는 패킷들에 마킹됨   out-profile  Flow가 선언한 만큼의 속도 이상을 사용하고 있는 패킷들에 마킹됨       Core Router  Class 별 트래픽 관리 엣지 라우터에서 마킹한 것에 기반하여 버퍼링, 스케줄링 in-profile 패킷들에 우선순위를 먼저 줌    Edge-router packet marking  Profile = 협의된 전송 속도 R, 버킷 사이즈 B Flow 마다 Profile을 베이스로 패킷을 마킹함 마킹 사용법  Class-Based Marking  클래스 별로 마킹   Intra-Class Marking  클래스 내에서도 in-profile인지 out-profile인지에 따라 마킹 가능      Diffserv packet marking: Detail  ToS를 이용해 마킹 6비트짜리 Differentiated Service Code Point (DSCP) 필드 이용  Per-Connection QoS Guarantees  image \n 아예 연결별로 QoS를 지정 예를 들어 1.5Mbps링크에 2개의 1Mbps 연결이 시도되고 있다면  한개만 허용하고 다른 한개는 막아버림 Call Admission   ","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-voip-sip/","title":"Computer Networking - VOIP-SIP"},{"content":"Computer Networking - 개요\nComputer-Network-개요 1. Data communication vs Computer network  전자는 두개의 디바이스, 후자는 많은 디바이스 간의 네트워크 형성\n두 개는 필수불가결하게 연결되어 있다.\n2. What\u0026rsquo;s the internet  1. Internet Network of Networks\nISP들에 의해 연결됨\n2. Protocols 메세지를 보내고 받는 것을 제어\n3. Internet 표준 RFC, IETF 등이 있음\n3. Network Edge  Hosts 클라이언트와 서버\n네트워크 엣지라고도 불림\n서버들은 보통 데이터센터에 입주해 있음\nAccess Networks, Physical Media 네트워크 엣지들이 네트워크 코어에 접근하기 위해 사용하는 네트워크\n무선 네트워크 (WIFI), 유선 네트워크 (LAN) 등\nNetwork Core 라우터들로 구성되어 있음\nNetwork of Networks\n4. InterNetwork  End Points (Hosts) 들이 작은 네트워크들을 이루고 이 네트워크들이 큰 네트워크를 이루며 또 이러한 네트워크들이 더 큰 네트워크를 이룬다.\n이 것이 인터넷의 기본적인 구조이다.\n5. ISP  한 ISP 내부에서는 서로 통신할 수 있지만, 해당 ISP가 다른 ISP에 연결되어 있지 않다면 각각의 ISP의 사용자들은 서로 통신할 수 없다.\nTier-1 ISP 나라 전체를 커버할 수 있는 대형 ISP\nTier-2 ISP 하나 또는 그 이상의 Tier-1 ISP와 연결되어 있으며, 다른 Tier-2 ISP와도 연결될 수 있다\nTier-2 ISP는 Tier-1 ISP 돈을 지불하고 인터넷 연결성을 보장받는다. (즉 서비스를 이용한다)\nTier-3 ISP and Local ISP Last Hop, 즉 사용자와 가장 가까운 ISP\n더 높은 ISP에게 돈을 지불하고 인터넷 연결성을 보장받는다.\n6. Internet Protocol Stack  인터넷 프로토콜 스택은 계층화된 (layered) 구조로 이루어져 있는 프로토콜들의 집합이다.\n굳이 계층을 나누어 놓은 이유는 네트워크는 복잡한 시스템들의 조각들로 이루어져 있기 때문에 이 구조를 모듈화하여 좀 더 식별하고, 관계화 할 수 있도록 해주기 위해서이다.\n모듈화를 한다면, 하나의 모듈이 업데이트가 필요할 때 해당 모듈 부분만 업데이트를 하면 되기에 불필요하게 전체 시스템을 건드리지 않아도 된다.\nApplication, transport, network, link, physical의 다섯가지로 나뉘어 있으며\n Application 계층은 말 그대로 응용 프로그램들이 사용하는 서비스들을 정의하는 계층 Transport 계층은 프로세스에서 프로세스 사이의 데이터 전송을 정의하는 계층 Network 계층은 Source에서 Destination 까지의 데이터그램을 라우팅하는 것을 정의하는 계층 Link 계층은 인접한 노드들끼리의 데이터 전송을 정의하는 계층 Physical 계층은 Bit 신호를 물리 Wire를 통해 전송하는 것을 정의한다  7. Encapsulation Source에서 Destination까지 메세지를 보낼 때 Application 계층에서 Physical 계층까지 내려가며 Header를 붙이게 되고, 이 Header들은 전송되는 과정에서 다시 벗겨지며 Destination의 Application에 도달하게 된다.\n","date":"2020-09-17T00:11:07+09:00","permalink":"https://yansigit.github.io/blog/computer-networking-%EA%B0%9C%EC%9A%94/","title":"Computer Networking - 개요"},{"content":"ORACLE DB Scott 계정에 대해서\nscott 계정 1. 개요 Oracle DB의 대표적인 예제 사용자 계정\n2. 활성화 하기  관리자 계정 SYS 또는 system으로 접속  sqlplus sys/123123 as sysdba   오라클 12C 버전부터는 사용자 계정 생성 및 권한 부여 시 C## 키워드를 붙여야 한다  귀찮으므로 alter session set \u0026quot;_ORACLE_SCRIPT\u0026quot;=true; 명령을 통해 예전 방식을 사용할 수 있게 한다. 이는 일회용이며 sqlplus 를 종료 후 재실행하면 다시 실행시켜야 한다.   scott.sql 파일을 찾는다.  보통 $ORACLE_HOME\\rdbms\\admin\\ 디렉토리에 위치해있다. 오라클 설치 위치인 $ORACE_HOME 디렉토리는 sqlplus 내부에서 ?로 대체할 수 있는 듯  예) @ ?/rdbms/admin/scott.sql   18c 도커 버전에서는 왠지 안보인다. 따라서 구글링해보니 다음 위치에 있는 스크립트가 대체할 수 있는 듯 하다.  $ORACLE_HOME\\rdbms\\admin\\utlsampl.sql     다음 sqlplus 내에서 스크립트 파일을 실행시킨다.  @ ?/rdbms/admin/utlsampl.sql   로그인하여 확인해본다.  sqlplus SCOTT/tiger    3. 같이 생성되는 테이블  DEPT  부서   EMP  사원   SALGRADE  급여등급   BONUS  보너스   ","date":"2020-09-16T00:00:00Z","permalink":"https://yansigit.github.io/blog/oracle-db-scott-%EA%B3%84%EC%A0%95/","title":"ORACLE DB Scott 계정"},{"content":"ORACLE DB SQL*PLUS 명령어 정리\nSQL*PLUS 명령어  SQL 명령어를 간단하게 편집, 저장, 실행, 결과 보기 등 제공\n LIST # L  SQL 버퍼에 있는 쿼리를 출력\n  맨 마지막으로 실행한 SQL 쿼리가 버퍼에 저장됨\n SQL\u0026gt;selectto_number(\u0026#39;1444\u0026#39;)+1fromdual;TO_NUMBER(\u0026#39;1444\u0026#39;)+1------------------- 1445SQL\u0026gt;l1*selectto_number(\u0026#39;1444\u0026#39;)+1fromdualSQL\u0026gt;selectempno,ename,sal2fromemp3wheredeptno=20;EMPNOENAMESAL---------- ---------- ---------- 7369SMITH8007566JONES29757788SCOTT30007876ADAMS11007902FORD3000SQL\u0026gt;l1selectempno,ename,sal2fromemp3*wheredeptno=20SQL\u0026gt;l22*fromempSQL\u0026gt;l232fromemp3*wheredeptno=20RUN # R, /  버퍼에 저장된 쿼리 실행\n SQL\u0026gt;l1selectempno,ename,sal2fromemp3*wheredeptno=20SQL\u0026gt;r1selectempno,ename,sal2fromemp3*wheredeptno=20EMPNOENAMESAL---------- ---------- ---------- 7369SMITH8007566JONES29757788SCOTT30007876ADAMS11007902FORD3000SQL\u0026gt;/EMPNOENAMESAL---------- ---------- ---------- 7369SMITH8007566JONES29757788SCOTT30007876ADAMS11007902FORD3000SAVE  버퍼에 있는 쿼리를 파일로 저장\n SQL\u0026gt;select1+4fromdual;1+4---------- 5SQL\u0026gt;saveexample1fileexample1.sql(이)가생성되었습니다GET  파일의 명령어를 SQL 버퍼로 불러옴\n SQL\u0026gt;getexample11*select1+4fromdualSQL\u0026gt;l1*select1+4fromdualSTART # START, @  파일의 명령어를 실행\n SQL\u0026gt;startexample11+4---------- 5SQL\u0026gt;@example11+4---------- 5EDIT # ED [파일명]  버퍼에 있는 쿼리를 임시파일에 저장하고 편집기로 열어줌\n  뒤에 파일명을 명시하면 빈 내용의 새 파일을 만듬 (편집 종료해도 버퍼로 안불러옴)\n SQL\u0026gt;l1*select6+9fromdualSQL\u0026gt;edfileafiedt.buf(이)가기록되었습니다1*select16+19fromdualSQL\u0026gt;l1*select16+19fromdualHOST  SQL*PLUS 내에서 Shell 열어줌\n  돌아올 때는 exit\n SQL\u0026gt; host sh-4.2# pwd /root sh-4.2# ls -l total 12 -rw-r--r-- 1 root root 25 Apr 17 04:31 afiedt.buf -rw-r--r-- 1 root root 23 Apr 17 04:24 example1.sql -rw-r--r-- 1 root root 35 Apr 17 04:33 example2.sql sh-4.2# exit exit SQL\u0026gt; I  현재 행의 다음 행에 문자열 삽입\n SQL\u0026gt;l1selectempno,ename,job2fromemp3*wheredeptno=10SQL\u0026gt;22*fromempSQL\u0026gt;11*selectempno,ename,jobSQL\u0026gt;l1selectempno,ename,job2fromemp3*wheredeptno=10SQL\u0026gt;iandjob=\u0026#39;CLERK\u0026#39;#현재행의다음행에andjob=\u0026#39;CLERK\u0026#39;삽입SQL\u0026gt;l1selectempno,ename,job2fromemp3wheredeptno=104*andjob=\u0026#39;CLERK\u0026#39;A  현재 행의 끝에 문자열 추가\n SQL\u0026gt;l1selectempno,ename,job2fromemp3wheredeptno=104*andjob=\u0026#39;CLERK\u0026#39;SQL\u0026gt;11*selectempno,ename,jobSQL\u0026gt;a,sal#현재행의끝에,sal추가1*selectempno,ename,job,salSQL\u0026gt;r1selectempno,ename,job,sal2fromemp3wheredeptno=104*andjob=\u0026#39;CLERK\u0026#39;EMPNOENAMEJOBSAL---------- ---------- --------- ---------- 7934MILLERCLERK1300DEL  행 삭제\n del : 현재 행 삭제\ndel n : n번째 행 삭제\ndel n1 n2 : n1부터 n2까지의 행 삭제\nSQL\u0026gt;l1selectempno,ename,job,sal2fromemp3wheredeptno=104*andjob=\u0026#39;CLERK\u0026#39;SQL\u0026gt;del#현재행삭제SQL\u0026gt;l1selectempno,ename,job,sal2fromemp3*wheredeptno=10SQL\u0026gt;iandjob=\u0026#39;CLERK\u0026#39;SQL\u0026gt;l1selectempno,ename,job,sal2fromemp3wheredeptno=104*andjob=\u0026#39;CLERK\u0026#39;SQL\u0026gt;del3#3행삭제SQL\u0026gt;l1selectempno,ename,job,sal2fromemp3*andjob=\u0026#39;CLERK\u0026#39;SQL\u0026gt;del23#2~3행삭제SQL\u0026gt;l1*selectempno,ename,job,salCHANGE # C  현재 행의 문자열을 교체\n SQL\u0026gt;l1selectempno,ename,job,sal2fromemp3*wheredeptno=20SQL\u0026gt;11*selectempno,ename,job,salSQL\u0026gt;c/job/deptno#문자열변경1*selectempno,ename,deptno,salSQL\u0026gt;l1selectempno,ename,deptno,sal2fromemp3*wheredeptno=20{n} {문자열}  n 번째 행을 해당 문자열로 교체\n  n이 0이면 첫번째 행 앞에 문자열 삽입\n SQL\u0026gt;l1selectempno,ename,deptno,sal2fromemp3*wheredeptno=20SQL\u0026gt;3wheresal\u0026gt;=2000#3행내용교체SQL\u0026gt;l1selectempno,ename,deptno,sal2fromemp3*wheresal\u0026gt;=2000SQL\u0026gt;del1SQL\u0026gt;l1fromemp2*wheresal\u0026gt;=2000SQL\u0026gt;0selectename#첫번째줄에내용삽입SQL\u0026gt;l1selectename2fromemp3*wheresal\u0026gt;=2000CLEAR SCREEN # CL SCR  화면 내용 모두 삭제\n CLEAR BUFFER # CL BUFF  버퍼 모두 삭제\n SPOOL {파일명}  지금부터 작업 내용을 모두 파일로 저장\n  중지: spool off\n sh-4.2#catoutput.txtSQL\u0026gt;selectename2fromemp3wheresal\u0026gt;=3000;ENAME---------- KINGFORDSQL\u0026gt;11*selectenameSQL\u0026gt;c/ename/sal1*selectsalSQL\u0026gt;r1selectsal2fromemp3*wheresal\u0026gt;=3000SAL---------- 50003000SQL\u0026gt;spooloff","date":"2020-09-16T00:00:00Z","permalink":"https://yansigit.github.io/blog/oracle-db-sqlplus-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A0%95%EB%A6%AC/","title":"ORACLE DB SQL*PLUS 명령어 정리"},{"content":"ORACLE DB 계정 설명\n계정 1. 관리자 계정  SYS  데이터 베이스 관리자 (DBA) Super User (SYSDBA)  데이터베이스 생성 및 삭제 가능   Data dictionary 소유자   SYSTEM  DBA 관리자에 필요한 테이블 및 뷰 생성 데이터베이스 생성 불가    관리자 계정 접속 sqlplus sys/123 as sysdba\n2. 샘플 사용자 계정  BI (Business Intelligence) HR (Human Resources) OE (Order Entry) PM (Product Media) IX (Information Exchange) SH (Sales) scott  실습 사용자 계정 따로 활성화 시켜줘야 함    비밀번호 변경 alter user scott identified by tiger;\nsqlplus 내부에서 계정 변경 conn {유저명}\nconn {유저명}/{패스워드}\nscott 계정 활성화 scott 계정 문서 참조\n","date":"2020-09-16T00:00:00Z","permalink":"https://yansigit.github.io/blog/oracle-db-%EA%B3%84%EC%A0%95/","title":"ORACLE DB 계정"},{"content":"ORACLE DB 명령어 정리\n명령어 테이블 출력 SELECT*FROMtab;/* 모든 테이블 출력 *//* BIN$ 으로 시작하는 테이블이 있을 수 있으며 *//* 이 테이블들은 삭제된 테이블이 혹시 몰라 남아있는 것 */PURGERECYCLEBIN;/* 삭제된 테이블 퍼지 */TNAME -------------------------------------------------------------------------------- TABTYPE CLUSTERID ------------- ---------- BONUS TABLE DEPT TABLE EMP TABLE TNAME -------------------------------------------------------------------------------- TABTYPE CLUSTERID ------------- ---------- SALGRADE TABLE 테이블 구조 확인 DESCdelpt;/* 테이블 구조 확인 */ Name Null? Type ----------------------------------------- -------- ---------------------------- DEPTNO NOT NULL NUMBER(2) DNAME VARCHAR2(14) LOC VARCHAR2(13) SELECT  테이블에 저장되어 있는 데이터 조회  SELECT*FROMdept; DEPTNO DNAME LOC ---------- -------------- ------------- 10 ACCOUNTING NEW YORK 20 RESEARCH DALLAS 30 SALES CHICAGO 40 OPERATIONS BOSTON 산술연산처리  숫자형 컬럼만 연산 가능  SELECTename,sal*12FROMemp;ENAME SAL*12 ---------- ---------- SMITH 9600 ALLEN 19200 WARD 15000 JONES 35700 MARTIN 15000 BLAKE 34200 CLARK 29400 SCOTT 36000 KING 60000 TURNER 18000 ADAMS 13200 ENAME SAL*12 ---------- ---------- JAMES 11400 FORD 36000 MILLER 15600 NULL 데이터  값이 없는 데이터 NULL 데이터와 연산한 값은 모두 NULL  SQL\u0026gt;SELECTempno,ename,commFROMemp;EMPNOENAMECOMM---------- ---------- ---------- 7369SMITH7499ALLEN3007521WARD5007566JONES7654MARTIN14007698BLAKE7782CLARK7788SCOTT7839KING7844TURNER07876ADAMSEMPNOENAMECOMM---------- ---------- ---------- 7900JAMES7902FORD7934MILLER14rowsselected.SQL\u0026gt;SELECTempno,ename,comm*100FROMemp;EMPNOENAMECOMM*100---------- ---------- ---------- 7369SMITH7499ALLEN300007521WARD500007566JONES7654MARTIN1400007698BLAKE7782CLARK7788SCOTT7839KING7844TURNER07876ADAMSEMPNOENAMECOMM*100---------- ---------- ---------- 7900JAMES7902FORD7934MILLER14rowsselected.별칭 (alias)  컬럼명을 변경해 출력할 수 있음  SQL\u0026gt;SELECTempnoasnum,enameasnameFROMemp;NUMNAME---------- ---------- 7369SMITH7499ALLEN7521WARD7566JONES7654MARTIN7698BLAKE7782CLARK7788SCOTT7839KING7844TURNER7876ADAMSNUMNAME---------- ---------- 7900JAMES7902FORD7934MILLER14rowsselected.SQL\u0026gt;SELECTempnonum,enamenameFROMemp;NUMNAME---------- ---------- 7369SMITH7499ALLEN7521WARD7566JONES7654MARTIN7698BLAKE7782CLARK7788SCOTT7839KING7844TURNER7876ADAMSNUMNAME---------- ---------- 7900JAMES7902FORD7934MILLER14rowsselected.SQL\u0026gt;SELECTempno\u0026#34;\u0026lt;n u m\u0026gt;\u0026#34;,ename\u0026#34;\u0026lt;n a m e\u0026gt;\u0026#34;FROMemp;\u0026lt;num\u0026gt;\u0026lt;name\u0026gt;---------- ---------- 7369SMITH7499ALLEN7521WARD7566JONES7654MARTIN7698BLAKE7782CLARK7788SCOTT7839KING7844TURNER7876ADAMS\u0026lt;num\u0026gt;\u0026lt;name\u0026gt;---------- ---------- 7900JAMES7902FORD7934MILLER14rowsselected.SQL\u0026gt;SELECTempno\u0026#34;\u0026lt;n u m\u0026gt;\u0026#34;,sal*100\u0026#34;$ S A L\u0026#34;FROMemp;\u0026lt;num\u0026gt;$SAL---------- ---------- 7369800007499160000752112500075662975007654125000769828500077822450007788300000783950000078441500007876110000\u0026lt;num\u0026gt;$SAL---------- ---------- 79009500079023000007934130000|| 연결 연산자  주의할 점\n 오라클에서 문자열은 작은 따옴표로 표현된다.\n쌍 따옴표는 오직 별칭을 지칭할 때만 사용한다\nSQL\u0026gt;SELECTename,\u0026#39; is a \u0026#39;,jobFROMemp;ENAME\u0026#39;ISA\u0026#39;JOB---------- ------ --------- SMITHisaCLERKALLENisaSALESMANWARDisaSALESMANJONESisaMANAGERMARTINisaSALESMANBLAKEisaMANAGERCLARKisaMANAGERSCOTTisaANALYSTKINGisaPRESIDENTTURNERisaSALESMANADAMSisaCLERKENAME\u0026#39;ISA\u0026#39;JOB---------- ------ --------- JAMESisaCLERKFORDisaANALYSTMILLERisaCLERK14rowsselected.SQL\u0026gt;SELECTename||\u0026#39; is a \u0026#39;||jobFROMemp;ENAME||\u0026#39;ISA\u0026#39;||JOB------------------------- SMITHisaCLERKALLENisaSALESMANWARDisaSALESMANJONESisaMANAGERMARTINisaSALESMANBLAKEisaMANAGERCLARKisaMANAGERSCOTTisaANALYSTKINGisaPRESIDENTTURNERisaSALESMANADAMSisaCLERKENAME||\u0026#39;ISA\u0026#39;||JOB------------------------- JAMESisaCLERKFORDisaANALYSTMILLERisaCLERK14rowsselected.DISTINCT  중복된 값은 제외하고 한 개 값만 출력 실험 결과 컬럼이 여러개일 경우 distinct 바로 오른쪽에 있는 컬럼에만 적용됨  당연\u0026hellip; 한거같긴 하다    SQL\u0026gt;selectdeptnofromemp;DEPTNO---------- 2030302030301020103020DEPTNO---------- 302010SQL\u0026gt;selectdistinctdeptnofromemp;DEPTNO---------- 301020WHERE 조건절  조건을 특정 필요한 데이터만 검색 사용 가능한 비교 연산자  =     \u0026lt;   =\n  \u0026lt;= \u0026lt;\u0026gt;, != (같지 않다)    SQL\u0026gt;selectempno,ename,salfromempwheresal\u0026gt;2000;EMPNOENAMESAL---------- ---------- ---------- 7566JONES29757698BLAKE28507782CLARK24507788SCOTT30007839KING50007902FORD3000//문자열비교시대소문자구별SQL\u0026gt;selectename,salfromempwhereename=\u0026#39;FORD\u0026#39;;ENAMESAL---------- ---------- FORD3000SQL\u0026gt;selectename,salfromempwhereename=\u0026#39;Ford\u0026#39;;norowsselected//날짜데이터비교LIKE 연산자  해당 문자를 포함하는지 여부\n   이름이 J로 시작하는 사원\nWHERE ename LIKE 'J%';\n  이름에 A를 포함하는 사원\nWHERE ename LIKE '%A%';\n  이름이 N으로 끝나는 사원\nWHERE ename LIKE '%N';\n  이름의 두 번째 문자가 A인 사원\nWHERE ename LIKE '_A%';\n  IN 연산자  여러개의 값 중에서 일치하는 값이 있으면 참\n  두개말고 여러개도 가능\n  논리 연산자 OR 대신 사용 가능\n  날짜와 문자도 비교 가능\n   부서번호가 10, 20인 사원의 사번, 이름, 부서번호 출력\nselectempno,ename,deptnofromempwheredeptnoIN(10,20);EMPNOENAMEDEPTNO---------- ---------- ---------- 7369SMITH207566JONES207782CLARK107788SCOTT207839KING107876ADAMS207902FORD207934MILLER10SQL\u0026gt;selectempno,ename,job2fromemp3wherejobin(\u0026#39;CLERK\u0026#39;,\u0026#39;MANAGER\u0026#39;);EMPNOENAMEJOB---------- ---------- --------- 7369SMITHCLERK7566JONESMANAGER7698BLAKEMANAGER7782CLARKMANAGER7876ADAMSCLERK7900JAMESCLERK7934MILLERCLERK  BETWEEN A AND B 연산자  A에서 B까지의 범위 값을 조회\n  논리연산자 AND 대신 사용 가능\n  급여가 2000에서 4000 사이인 사원의 이름 출력  selectenamefromempwheresalbetween2000and4000;ENAME---------- JONESBLAKECLARKSCOTTFORD논리 연산자   WHERE 절에 조건이 두 개 이상일 경우\n AND : 두 조건을 모두 만족  selectename,job,deptnofromempwherejob=\u0026#39;CLERK\u0026#39;anddeptno=10;selectename,job,salfromempwheresal\u0026gt;=2000andsal\u0026lt;=4000; OR : 두 조건 중에서 한 가지만 만족  selectename,job,deptnofromempwherejob=\u0026#39;CLERK\u0026#39;orjob=\u0026#39;MANAGER\u0026#39;;selectename,job,deptnofromempwheredeptno=10ordeptno=20;  WHERE 절의 조건에 해당하지 않을 경우 검색\n NOT  selectempno,ename,deptnofromempwherenotdeptno=20; NOT IN   부서 번호가 10, 20번이 아닌 사원\n selectempno,ename,deptnofromempwheredeptnonotin(10,20); NOT BETWEEN A AND B   연봉이 2000~4000이 아닌 사원\n selectempno,ename,salfromempwheresalnotbetween2000and4000; NOT LIKE   이름에 A가 들어가지 않는 사원\n selectempno,enamefromempwhereenamenotlike\u0026#39;%A%\u0026#39;;  IS NULL, IS NOT NULL  컬럼값이 NULL인지 아닌지 비교\n  관리자가 없는 사원과 있는 사원 출력\n selectempno,ename,mgrfromempwheremgrisnull;selectempno,ename,mgrfromempwheremgrisnotnull;ORDER BY 절  쿼리 결과 순서 정렬\n  숫자, 문자, 날짜 정렬 가능 (A,B,C | 가나다 순)\n ORDER BY {기준컬럼명} {ASC | DESC}\n  ASC\n 오름차순 생략 가능  selectempno,ename,salfromemporderbysal;selectempno,ename,salfromemporderbyename;selectempno,ename,hiredatefromemporderbyhiredate;  DESC\n 내림차순  selectempno,ename,salfromemporderbysaldesc;selectempno,ename,salfromemporderbyenamedesc;selectempno,ename,hiredatefromemporderbyhiredatedesc;   여러 개를 기준으로 정렬 가능 (첫번째로 정렬 후 다음 기준으로 또 정렬)\n ORDER BY {기준컬럼명} {ASC | DESC}, {기준컬럼명2} {ASC | DESC}, ...\nselectempno,ename,salfromemporderbysaldesc,enameasc;","date":"2020-09-16T00:00:00Z","permalink":"https://yansigit.github.io/blog/oracle-db-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A0%95%EB%A6%AC/","title":"ORACLE DB 명령어 정리"},{"content":"ORACLE DB 서브 쿼리\n서브 쿼리  하나의 쿼리 처리에서 얻어진 결과를 다른 쿼리의 조건식에 전달해 결과 검색\n 언제 쓰이나?  KING 사원과 같은 부서에서 근무하는 사원 출력  먼저 KING 사원의 부서번호를 구함 그 결과인 10으로 where deptno = 10을 통해 쿼리   FORD 사원의 급여보다 많이 받는 사원 출력  역시 먼저 FORD 사원의 급여를 구해야함   JONES 사원과 동일한 매니저인 사원 출력  역시 JONES 사원의 매니저 번호를 구해야함    서브 쿼리 구문 형식 selectenamefromempwheredeptno=(selectdeptnofromempwhereename=\u0026#39;KING\u0026#39;selectenamefromempwheresalary\u0026gt;(selectsalaryfromempwhereename=\u0026#39;FORD\u0026#39;)selectempno,ename,salaryfromempwheresalary=(selectmax(salary)fromempwheredeptno=10) WHERE 조건 연산자 옆에 괄호로 묶어 표현함 order by 절은 사용할 수 없음  서브 쿼리를 이용한 조인 쿼리 표현 selecte.ename,d.dnamefromempe,(selectdeptno,dnamefromdeptwheredeptno=10)dwheree.deptno=d.deptno 해당 (서브쿼리절)을 인라인 뷰 라고도 한다.  다중 행 서브쿼리  서브 쿼리에서 반환되는 결과가 하나의 행 이상\n 다중 연산자 IN 비교조건에서 서브 쿼리의 출력 결과 중 하나라도 일치하면 참\n...wheredeptnoin(selectdeptnofromempwhereename=\u0026#39;BLAKE\u0026#39;)...where(job,dedptno)in(selectjob,deptnofromempwhereename=\u0026#39;ALLEN\u0026#39;)ALL 서브 쿼리의 출력값들에 대한 where 비교조건이 모두 참인 결과만 출력\n-- (그냥 예시임) -- 30번 부서 연봉 selectsalfromempwheredeptno=30;sal---- 160028509501500#30번부서사원들의급여보다더많이받는사원들연봉출력selectsalfromempwheresal\u0026gt;all(selectsalfromempwheredeptno=30)sal---- 295030005000ANY 서브 쿼리 출력값들 각각에 대해 where 비교조건이 참인 결과를 모두 다 출력\nselectsalfromempwheresal\u0026gt;any(selectsalfromempwheredeptno=30)sal---- -- 30번 부서의 최소 연봉 이상인 연봉 모두 출력 ","date":"2020-09-16T00:00:00Z","permalink":"https://yansigit.github.io/blog/oracle-db-%EC%84%9C%EB%B8%8C-%EC%BF%BC%EB%A6%AC-%EC%A0%95%EB%A6%AC/","title":"ORACLE DB 서브 쿼리 정리"},{"content":"ORACLE DB 에러 대응\n에러 대응 로컬에서 sqlplus 에러 뜰 경우 TNS lost contact 에러   먼저 해당 바이너리 퍼미션 확인\nls -l $ORACLE_HOME/bin/oracle\n  퍼미션이 -rwsr-s--x 이 아닐 경우 변경\nchmod 6751 $ORACLE_HOME/bin/oracle\n  다시 sqlplus 접속하여 정상작동 확인\n ","date":"2020-09-16T00:00:00Z","permalink":"https://yansigit.github.io/blog/oracle-db-%EC%97%90%EB%9F%AC-%EB%8C%80%EC%9D%91/","title":"ORACLE DB 에러 대응"},{"content":"ORACLE DB 연습문제 모음\n예제 --1\u0026gt; 부서테이블의 모든 데이터를 출력하라. SELECT*FROMEMP--2\u0026gt; EMP테이블에서 각 사원의 직업, 사원번호, 이름, 입사일을 출력하라. SELECTJOB,EMPNO,ENAME,HIREDATEFROMEMP--3\u0026gt; EMP테이블에서 직업을 출력하되, 각 항목(ROW)가 중복되지 않게 출력하라. SELECTDISTINCTJOBFROMEMP--4\u0026gt; 급여가 2850 이상인 사원의 이름 및 급여를 표시하는 출력하라. SELECTENAME,SALFROMEMPWHERESAL\u0026gt;=2850--5\u0026gt; 사원번호가 7566인 사원의 이름 및 부서번호를 표시하는 출력하라. SELECTENAME,DEPTNOFROMEMPWHEREEMPNO=7566--6\u0026gt; 급여가 1500이상 ~ 2850이하의 범위에 속하지 않는 모든 사원의 이름 및 급여를 출력하라. SELECTENAME,SALFROMEMPWHERESALNOTBETWEEN1500AND2850--7\u0026gt; 1981년 2월 20일 ~ 1981년 5월 1일에 입사한 사원의 이름,직업 및 입사일을 출력하라. 입사일을 기준으로 해서 오름차순으로 정렬하라. SELECTENAME,JOB,HIREDATEFROMEMPWHEREHIREDATEBETWEEN\u0026#39;1981-02-20\u0026#39;AND\u0026#39;1981-05-01\u0026#39;ORDERBYHIREDATE--8\u0026gt; 10번 및 30번 부서에 속하는 모든 사원의 이름과 부서 번호를 출력하되, 이름을 알파벳순으로 정렬하여 출력하라. SELECTENAME,DEPTNOFROMEMPWHEREDEPTNOIN(10,30)ORDERBYENAME--9\u0026gt; 10번 및 30번 부서에 속하는 모든 사원 중 급여가 1500을 넘는 사원의 이름 및 급여를 출력하라. --(단 컬럼명을 각각 employee 및 Monthly Salary로 지정하시오) SELECTENAMEAS\u0026#39;Employee\u0026#39;,SALAS\u0026#39; Monthly Salary\u0026#39;FROMEMPWHEREDEPTNOIN(10,30)ANDSAL\u0026gt;1500--10\u0026gt; 관리자가 없는 모든 사원의 이름 및 직위를 출력하라. SELECTENAME,JOBFROMEMPWHEREMGRISNULL--11\u0026gt; 커미션을 받는 모든 사원의 이름, 급여 및 커미션을 출력하되, 급여를 기준으로 -- 내림차순으로 정렬하여 출력하라. SELECTENAME,SAL,COMMFROMEMPWHERECOMMISNOTNULLORDERBYSALDESC--12\u0026gt; 이름의 세 번째 문자가 A인 모든 사원의 이름을 출력하라. SELECTENAMEFROMEMPWHEREENAMELIKE\u0026#39;__A%\u0026#39;--13\u0026gt; 이름에 L이 두 번 들어가며 부서 30에 속해있는 사원의 이름을 출력하라. SELECTENAMEFROMEMPWHEREENAMELIKE\u0026#39;%L%L%\u0026#39;ANDDEPTNO=30--14\u0026gt; 직업이 Clerk 또는 Analyst 이면서 급여가 1000,3000,5000 이 아닌 -- 모든 사원의 이름, 직업 및 급여를 출력하라. SELECTENAME,JOB,SALFROMEMPWHEREJOBIN(\u0026#39;CLERK\u0026#39;,\u0026#39;ANALYST\u0026#39;)ANDSALnotIN(1000,3000,5000)--15\u0026gt; 사원번호, 이름, 급여 그리고 15%인상된 급여를 정수로 표시하되 컬럼명을 -- New Salary로 지정하여 출력하라. SELECTEMPNO,ENAME,SAL,ROUND(SAL+(SAL*0.15),0)AS\u0026#34;New Salary\u0026#34;FROMEMP--16\u0026gt; 15번 문제와 동일한 데이타에서 급여 인상분(새 급여에서 이전 급여를 뺀 값)을 추가해서 -- 출력하라.(컬럼명은 Increase로 하라). SELECTEMPNO,ENAME,SAL,ROUND(SAL+(SAL*0.15))AS\u0026#34;New Salary\u0026#34;,(ROUND(SAL+(SAL*0.15)))-SALAS\u0026#34;Increase\u0026#34;FROMEMP--18\u0026gt; 모든 사원의 이름(첫 글자는 대문자로, 나머지 글자는 소문자로 표시) 및 이름 길이를 -- 표시하는 쿼리를 작성하고 컬럼 별칭은 적당히 넣어서 출력하라. SELECTUPPER(SUBSTR(ENAME,1,1))||LOWER(SUBSTR(ENAME,2,12))AS\u0026#34;NAME\u0026#34;,LENGTH(ENAME)AS\u0026#34;LENENAME\u0026#34;FROMEMP--19\u0026gt; 사원의 이름과 커미션을 출력하되, 커미션이 책정되지 않은 -- 사원의 커미션은 \u0026#39;no commission\u0026#39;으로 출력하라. SELECTENAME,NVL(TO_CHAR(COMM),\u0026#39;no commission\u0026#39;)FROMEMP--20\u0026gt; 모든 사원의 이름,부서번호,부서이름을 표시하는 질의를 작성하라.(DECODE) SELECTempno,deptno,DECODE(deptno,10,\u0026#39;ACCOUNTING\u0026#39;,20,\u0026#39;RESEARCH\u0026#39;,30,\u0026#39;SALES\u0026#39;,40,\u0026#39;OPERATIONS\u0026#39;)AS\u0026#34;dname\u0026#34;FROMEMP;SELECTE.ENAME,E.DEPTNO,D.DNAMEFROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNO--21\u0026gt; 30번 부서에 속한 사원의 이름과 부서번호 그리고 부서이름을 출력하라. SELECTE.ENAME,E.DEPTNO,D.DNAMEFROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDE.DEPTNO=30--22\u0026gt; 30번 부서에 속한 사원들의 모든 직업과 부서위치를 출력하라. --(단, 직업 목록이 중복되지 않게 하라.) SELECTDISTINCTE.JOB,D.LOCFROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDD.DEPTNO=30--23\u0026gt; 커미션이 책정되어 있는 모든 사원의 이름, 부서이름 및 위치를 출력하라. SELECTE.ENAME,D.DNAME,D.LOCFROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDCOMMISNOTNULL--24\u0026gt; 이름에 A가 들어가는 모든 사원의 이름과 부서 이름을 출력하라. SELECTE.ENAME,D.DNAMEFROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDE.ENAMELIKE\u0026#39;%A%\u0026#39;--25\u0026gt; Dallas에서 근무하는 모든 사원의 이름, 직업, 부서번호 및 부서이름을 출력하라. SELECTE.ENAME,E.JOB,E.DEPTNO,D.DNAMEFROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDD.LOC=\u0026#39;Dallas\u0026#39;--26\u0026gt; 사원이름 및 사원번호, 해당 관리자이름 및 관리자 번호를 출력하되, --각 컬럼명을 employee,emp#,manager,mgr#으로 표시하여 출력하라. SELECTE.ENAMEAS\u0026#34;EMPPLOYEE\u0026#34;,E.EMPNOAS\u0026#34;EMP#\u0026#34;,M.ENAMEAS\u0026#34;MANAGER\u0026#34;,M.EMPNOAS\u0026#34;MGR#\u0026#34;FROMEMPE,EMPMWHEREE.MGR=M.EMPNO--27\u0026gt; 모든 사원의 이름,직업,부서이름,급여 및 등급을 출력하라. SELECTE.ENAME,E.JOB,D.DNAME,E.SAL,S.GRADEFROMEMPE,DEPTD,SALGRADESWHEREE.DEPTNO=D.DEPTNOANDE.SALBETWEENS.LOSALANDS.HISAL--28\u0026gt; Smith보다 늦게 입사한 사원의 이름 및 입사일을 출력하라. SELECTENAME,HIREDATEFROMEMPWHEREHIREDATE\u0026gt;(SELECTHIREDATEFROMEMPWHEREENAME=\u0026#39;SMITH\u0026#39;)--29\u0026gt; 자신의 관리자보다 먼저 입사한 모든 사원의 이름, 입사일, --관리자의 이름, 관리자의 입사일을 출력하되 각각 컬럼명을 Employee,EmpHiredate,Manager,MgrHiredate로표시하여출력하라.SELECTE.ENAMEAS\u0026#34;Employee\u0026#34;,E.HIREDATEAS\u0026#34;EmpHIredate\u0026#34;,M.ENAMEAS\u0026#34;Manager\u0026#34;,M.HIREDATEAS\u0026#34;MgrHiredate\u0026#34;FROMEMPE,EMPMWHEREE.MGR=M.EMPNOANDE.HIREDATE\u0026lt;M.HIREDATE--30\u0026gt; 모든 사원의 급여 최고액,최저액,총액 및 평균액을 출력하되 --각 컬럼명을 Maximum, Minimum, Sum, Average로 지정하여 출력하라. SELECTMAX(SAL)AS\u0026#34;Maximum\u0026#34;,MIN(SAL)AS\u0026#34;Minimum\u0026#34;,SUM(SAL)AS\u0026#34;Sum\u0026#34;,AVG(SAL)AS\u0026#34;Average\u0026#34;FROMEMP--31\u0026gt; 각 직업별로 급여 최저액.최고액,총액 및 평균액을 출력하라. SELECTJOB,MAX(SAL),MIN(SAL),SUM(SAL),AVG(SAL)FROMEMPGROUPBYJOB--32\u0026gt; 직업이 동일한 사람 수를 직업과 같이 출력하라. SELECTJOB,COUNT(JOB)FROMEMPGROUPBYJOB--33\u0026gt; 관리자의 수를 출력하되, 관리자 번호가 중복되지 않게하라. 그리고, --컬럼명을 Number of Manager로 지정하여 출력하라. SELECTCOUNT(DISTINCT(MGR))AS\u0026#34;Number of Manager\u0026#34;FROMEMP--34\u0026gt; 최고 급여와 최저 급여의 차액을 출력하라. SELECTMAX(SAL)-MIN(SAL)FROMEMP--35\u0026gt; 관리자 번호 및 해당 관리자에 속한 사원들의 최저 급여를 출력하라. --단, 관리자가 없는 사원 및 최저 급여가 1000 미만인 그룹은 제외시키고 급여를 기준으로 --출력 결과를 내림차순으로 정렬하라. SELECTMGR,MIN(SAL)FROMEMPWHEREMGRISNOTNULLGROUPBYMGRHAVINGMIN(SAL)\u0026gt;=1000ORDERBYMIN(SAL)--36\u0026gt; 부서별로 부서이름, 부서위치, 사원 수 및 평균 급여를 출력하라. --그리고 각각의 컬럼명을 부서명,위치,사원의 수,평균급여로 표시하라. --SELECT E.DEPTNO AS \u0026#34;부서명\u0026#34;, D.DNAME AS \u0026#34;부서이름\u0026#34;, D.LOC AS \u0026#34;위치\u0026#34;, COUNT(E.EMPNO)AS\u0026#34;사원의 수\u0026#34;,AVG(E.SAL)AS\u0026#34;평균급여\u0026#34;FROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOGROUPBYE.DEPTNO,D.DNAME,D.LOC--37\u0026gt; Smith와 동일한 부서에 속한 모든 사원의 이름 및 입사일을 출력하라. --단, Smith는 제외하고 출력하시오 SELECTENAME,TO_CHAR(HIREDATE,\u0026#39;YYYY-MM-DD\u0026#39;)FROMEMPWHEREDEPTNOIN(SELECTDEPTNOFROMEMPWHEREENAME=\u0026#39;SMITH\u0026#39;)ANDENAME!=\u0026#39;SMITH\u0026#39;--38\u0026gt; 자신의 급여가 평균 급여보다 많은 모든 사원의 사원 번호, 이름, 급여를 --표시하는 질의를 작성하고 급여를 기준으로 결과를 내림차순으로 정렬하라. SELECTEMPNO,ENAME,SALFROMEMPWHERESAL\u0026gt;(SELECTAVG(SAL)FROMEMP)ORDERBYSALDESC--39\u0026gt; 이름에 T가 들어가는 사원의 속한 부서에서 근무하는 모든 사원의 --사원번호 및 이름을 출력하라. SELECTEMPNO,ENAMEFROMEMPWHEREDEPTNOIN(SELECTDEPTNOFROMEMPWHEREENAMELIKE\u0026#39;%T%\u0026#39;)--40\u0026gt; 부서위치가 Dallas인 모든 사원의 이름,부서번호 및 직위를 출력하라. SELECTE.ENAME,E.DEPTNO,E.JOBFROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDD.LOC=\u0026#39;DALLAS\u0026#39;--41\u0026gt; KING에게 보고하는 모든 사원의 이름과 급여를 출력하라. SELECTENAME,SALFROMEMPWHEREMGR=(SELECTEMPNOFROMEMPWHEREENAME=\u0026#39;KING\u0026#39;)--42\u0026gt; Sales 부서의 모든 사원에 대한 부서번호, 이름 및 직위를 출력하라. SELECTE.DEPTNO,E.ENAME,E.JOBFROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDD.DNAME=\u0026#39;SALES\u0026#39;SELECTE.DEPTNO,E.ENAME,E.JOBFROMEMPEinnerjoinDEPTDonE.DEPTNO=D.DEPTNOwhereD.DNAME=\u0026#39;SALES\u0026#39;--43\u0026gt; 자신의 급여가 평균 급여보다 많고 이름에 T가 들어가는 사원과 --동일한 부서에 근무하는 모든 사원의 사원 번호, 이름 및 급여를 출력하라. SELECTEMPNO,ENAME,SALFROMEMPWHERESAL\u0026gt;(SELECTAVG(SAL)FROMEMP)ANDDEPTNOIN(SELECTDEPTNOFROMEMPWHEREENAMELIKE\u0026#39;%T%\u0026#39;)--44\u0026gt; 커미션을 받는 사원과 급여가 일치하는 사원의 이름,부서번호,급여를 출력하라. SELECTENAME,DEPTNO,SALFROMEMPWHERESALIN(SELECTSALFROMEMPWHERECOMMISNOTNULL)--45\u0026gt; Dallas에서 근무하는 사원과 직업이 일치하는 사원의 이름,부서이름, 및 급여를 출력하시오 SELECTE.ENAME,D.DNAME,E.SALFROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDE.JOBIN(SELECTE.JOBFROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDD.LOC=\u0026#39;DALLAS\u0026#39;)--46\u0026gt; Scott과 동일한 급여 및 커미션을 받는 모든 사원의 이름, 입사일 및 급여를 출력하시오 SELECTENAME,HIREDATE,SALFROMEMPWHERESAL=(SELECTSALFROMEMPWHEREENAME=\u0026#39;SCOTT\u0026#39;)ANDNVL(COMM,0)=(SELECTNVL(COMM,0)FROMEMPWHEREENAME=\u0026#39;SCOTT\u0026#39;)--47\u0026gt; 직업이 Clerk 인 사원들보다 더 많은 급여를 받는 사원의 사원번호, 이름, 급여를 출력하되, --결과를 급여가 높은 순으로 정렬하라. SELECTEMPNO,ENAME,SALFROMEMPWHERESAL\u0026gt;ALL(SELECTSALFROMEMPWHEREJOB=\u0026#39;CLERK\u0026#39;)--결국 최대값과 비교 any 최소값과 비교 ORDERBYSALDESC--48\u0026gt; 이름에 A가 들어가는 사원과 같은 직업을 가진 사원의 이름과 월급, 부서번호를 출력하라. SELECTENAME,SAL,DEPTNOFROMEMPWHEREJOBIN(SELECTJOBFROMEMPWHEREENAMELIKE\u0026#39;%A%\u0026#39;)--49\u0026gt; New York 에서 근무하는 사원과 급여 및 커미션이 같은 사원의 사원이름과 부서명을 출력하라. select*fromempjoindeptonemp.deptno=dept.deptnoanddept.loc=\u0026#39;NEW YORK\u0026#39;;SELECTE.ENAME,D.DNAMEFROMEMPE,DEPTDWHEREe.deptno=d.deptnoANDE.SALIN(SELECTE.SALFROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDLOC=\u0026#39;NEW YORK\u0026#39;)ANDNVL(COMM,0)IN(SELECTNVL(COMM,0)FROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDLOC=\u0026#39;NEW YORK\u0026#39;);--50\u0026gt; Dallas에서 근무하는 사원과 직업 및 관리자가 같은 사원의 사원번호,사원이름, --직업,월급,부서명,커미션을 출력하되 커미션이 책정되지 않은 사원은 NoCommission으로 표시하고, --커미션의 컬럼명은 Comm으로 나오게 출력하시오. (단, 최고월급부터 출력되게 하시오) SELECTE.EMPNO,E.ENAME,E.JOB,E.SAL,D.DNAME,NVL((TO_CHAR(E.COMM)),\u0026#39;NoCommision\u0026#39;)AS\u0026#34;COMM\u0026#34;FROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDJOBIN(SELECTJOBFROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDLOC=\u0026#39;DALLAS\u0026#39;)ANDMGRIN(SELECTMGRFROMEMPE,DEPTDWHEREE.DEPTNO=D.DEPTNOANDLOC=\u0026#39;DALLAS\u0026#39;)","date":"2020-09-16T00:00:00Z","permalink":"https://yansigit.github.io/blog/oracle-db-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C-%EB%AA%A8%EC%9D%8C/","title":"ORACLE DB 연습문제 모음"},{"content":"ORACLE DB 이론 정리\n이론 1. 자료 자료와 정보  자료  현실세계의 값, 가공하지 않은 값   정보  자료를 가공하여 가치 있는 형태로 만든 것 의사 결정에 의미 있는 값    표현 단위  위로 갈수록 컴퓨터, 아래로 갈수록 사람 중심의 개념\n  비트  자료 표현 최소 단위   바이트  문자 표현 최소 단위   워드  명령 처리 기본 단위 (주소 표현의 최소 단위) 4바이트 문자가 모여 워드가 된다   필드  자료 처리 (정보 표현)의 최소 단위 예) 포털 사이트에서 이름 아이디 등 입력하는 거 항목, 아이템이라고도 함   레코드  필드의 모임   파일  레코드의 모임   데이터베이스  관련이 있는 파일의 집합    2. 데이터베이스 관리 시스템 파일 시스템  데이터를 파일로 관리하기 위해 파일을 생성, 관리하는 기능을 제공하는 소프트웨어 응용 프로그램마다 필요한 데이터를 별도의 파일로 관리 문제점  같은 내용의 데이터가 중복 저장 응용 프로그램이 파일에 종속적  사용하는 파일의 구조가 변하면 응용 프로그램도 고쳐야 함   동시 공유, 보안, 회복 기능 부족 응용 프로그램 개발이 어려움 데이터 무결성 유지가 어려움    데이터베이스 관리 시스템  DBMS 라고도 함 데이터베이스 관리와 사용자의 데이터 처리 요구 수행 파일 시스템의 문제 해결 모든 응용 프로그램이 데이터베이스 시스템 공유 가능  DBMS의 주요 기능  정의 기능  데이터베이스 구조를 정의하거나 수정   조작 기능  데이터를 삽입, 삭제, 수정, 검색   제어 기능  데이터를 정확하고 안전하게 유지    DMBS의 주요 구성 요소  질의 처리기 (Query Processor)  사용자의 데이터 처리 요구를 해석하여 처리   저장 데이터 관리자 (Stored Data Manager)  디스크에 저장된 데이터베이스와 데이터 사전을 관리하고 접근    3. DBMS 발전 과정 1세대  계층 DMBS  트리 구조 상위 레코드인 부모가 하위 레코드인 자식을 복수개 담음 데이터 중복 문제가 존재   네트워크 DBMS  데이터 중복 문제 해결 노트와 간선을 이용한 그래프 구조 복잡한 구조로 변경에 어려움 존재    2세대  관계 DBMS  데이터베이스를 테이블 형태로 구현    3세대  객체지향 DBMS  멀티미디어 데이터 원활한 처리 관계형 DBMS의 비즈니스 데이터만 처리하는 것을 보완하기 위함 객체를 이용해 데이터베이스 구성   객체관계 DBMS: 객체지향 DB + 관계형 DB  4세대  NoSQL DBMS  비정형 데이터를 처리하는데 적합 안정성과 일관성 유지를 위해 복잡한 기능 포기 데이터 구조를 미리 정해두지 않아 유연함 확장성이 뛰어남  여러 대의 서버에 분산해 저장 처리 가능     NewSQL DBMS  관계 DBMS + NoSQL    4. 데이터베이스 시스템  데이터베이스에 데이터를 저장하고, 이를 관리하여 조직에 필요한 정보를 생성해주는 시스템\n 구조  스키마  데이터베이스에 저장되는 데이터 구조와 제약조건을 정의한 것 필드의 이름과 자료형을 정의한 것   인스턴스  스키마에 따라 데이터베이스에 실제로 저장된 값 예) 고객번호:100 이름:홍길동 나이:25    3단계 데이터베이스 구조  외부 단계로 갈수록 추상화가 높아진다\n  쉽게 말해 집 주인은 인테리어만 보고, 설계자는 철골이나 기반 등 까지 생각한다는 것\n  image \n 외부 단계  개별 사용자 관점 데이터베이스를 개별 사용자 관점에서 이해하고 표현하는 단계 데이터베이스 하나에 외부 스키마가 여러개 존재할 수 있음   개념 단계  조직 전체의 관점 데이터베이스 하나에 개념 스키마가 하나만 존재함   내부 단계  물리적인 저장 장치의 관점 내부 스키마는 하나만 존재    3단계 데이터베이스 구조의 매핑(사상)  image \n 스키마 사이의 대응 관계  외부-개념 매핑  응용 인터페이스 라고도 함   개념-내부 매핑  저장 인터페이스 라고도 함     데이터 독립성을 위해 매핑하여 정의  데이터 독립성 : 하위 스키마를 바꾸더라도 상위 스키마가 영향을 받지 않는것 논리적 데이터 독립성  개념 스키마가 변경되어도 외부 스키마는 영향을 받지 않음 외부-개념 스키마 사이의 매핑만 수정하면 됨   물리적 데이터 독립성  내부 스키마가 변경되어도 개념 스키마는 영향을 받지 않음 개념-물리 스키마 사이의 매핑만 수정하면 됨     사용자가 원하는 데이터에 접근을 쉽게 하기 위해서도 있음  데이터 사전  시스템 카탈로그 라고도 함 메타 데이터를 유지  스키마, 매핑 정보, 제약조건 등을 저장   DBMS가 스스로 생성하고 유지 일반 사용자도 접근할 수 있으나 열람만 가능  데이터 디렉토리  데이터 사전에 있는 데이터에 실제로 접근하는데 필요한 위치정보를 저장하는 시스템 데이터베이스 일반 사용자의 접근 불가  사용자 데이터베이스  사용자가 실제로 이용하는 데이터가 저장되어 있는 일반 데이터베이스  5. 데이터베이스 사용자  데이터베이스를 이용하기 위해 접근하는 모든 사람\n  image \n 데이터베이스 관리자  데이터베이스 시스템을 운영 및 관리   최종 사용자  데이터베이스에 접근하여 데이터를 조작   응용 프로그래머  응용 프로그램 개발 시 데이터베이스를 이용    6. 데이터 언어  image \n image \n 데이터 정의어 (DDL; Data Definition Language)  스키마를 정의하거나 수정 또는 삭제하기 위해 사용   데이터 조작어 (DML; Data Manipulation Language)  데이터의 삽입, 삭제, 수정, 검색 등의 처리를 요구하기 위해 사용 절차적 데이터 조작어  사용자가 어떤 데이터를 원하고 (What) 그 데이터를 얻기 위해 어떻게 (How) 처리해야 하는지도 설명   비절차적 데이터 조작어  사용자가 어떤 데이터를 원하는지만 설명     데이터 제어어 (DCL; Data Control Language)  내부적으로 필요한 규칙이나 기법을 정의하기 위해 사용 사용 목적  무결성 보안 회복 동시성 제어      7. 데이터 모델링  현실 세계에 존재하는 데이터를 조직이 선별한 데이터만을 선별해 데이터베이스로 옮기는 과정\n  데이터베이스 설계의 핵심 과정\n  image \n2단계 데이터 모델링  image \n 개념적 데이터 모델링  현실 세계의 중요 데이터를 추출해 개념 세계로 옮기는 작업   논리적 데이터 모델링  개념 세계의 데이터를 데이터베이스에 저장하는 구조로 표현하는 작업    8. 데이터 모델  데이터 모델링의 결과물을 표현하는 도구\n  image \n 개념적 데이터 모델  사람의 머리로 이해할 수 있도록 현실 세계를 개념적 모데링하여 데이터베이스의 개념적 구조로 표현하는 도구   논리적 데이터 모델  개념적 구조를 논리적 모델링하여 데이터베이스의 논리적 구조로 표현하는 도구    개체 관계 모델 (E-R model)  개체와 개체 간의 관계를 이용해 현실 세계를 개념적 구조로 구현\n  개체   사람, 사물, 개념, 사건 등\n  다른 개체와 구별되는 이름을 가짐\n  각 개체만의 고유한 특성, 상태 등 속성을 하나 이상 가짐\n  서점에 필요한 개체: 고객, 책\n  학교에 필요한 개체: 학과, 과목\n image \n  개체 타입\n 개체를 고유의 이름과 속성들로 정의한 것    개체 인스턴스\n 개체를 구성하고 있는 속성이 실제 값을 가짐으로서 실체화된 개체    개체 집합\n 특정 개체 타입에 대한 개체 인스턴스들을 모아놓은 것     속성  개체나 관계가 가지고 있는 고유의 특성 의미 있는 데이터의 가장 작은 논리적 단위 분류 방법  갯수  단일 값 속성  고객아이디, 고객명 등   다중 값 속성  복수 전공을 할 경우의 전공값 등     의미의 분해 가능성  단순 속성  의미를 더 이상 분해 불가능 책 이름, ISBN 등   복합 속성  의미를 분해할 수 있는 속성 주소 : 국가, 도, 시, 동, 면, 리 등 세분화 가능 생년월일 : 연, 월, 일 등 세분화 가능     유도 속성  다른 속성에서 유도되어 결정되는 속성 할인율에 따른 판매가격 등   NULL 속성  NULL 값이 허용되는 속성   KEY 속성  각 개체 인스턴트를 식별하는 데 사용되는 속성 ID, 고객번호 등       관계   개체와 개체가 맺고 있는 의미있는 연관성\n  즉 매핑을 의미\n  관계의 유형\n 관계에 참여하는 개체 타입의 수  이항 관계 삼항 관계 순환 관계  개체 타입 하나가 자기 자신과 맺는 관계     매핑 카디널리티   개체들간에 매핑되는 원소 개수\n  일대일 관계\n image \n  일대다 관계\n image \n  다대다 관계\n image \n      관계 참여 특성\n 전체 참여  모든 개체 인스턴스가 관계에 반드시 참여해야함 모든 학생은 반드시 학과 수업을 들어야 한다   부분 참여  개체 인스턴스 중 일부만 선택적으로 관계에 참여해도 됨 고객 중 일부만 상품을 구매해도 된다      관계 종속성\n 개체 A가 존재해야 객체 B가 존재할 수 있음 개체 A가 삭제되면 객체 B도 삭제됨 약한 개체  다른 개체의 존재 여부에 의존적임   강한 개체  다른 개체의 존재 여부를 결정   특징  강한 개체와 약한 개체는 일반적으로 일대다의 관계를 가짐 약한 개체는 강한 개체와의 관계에 필수적으로 참여 약한 개체는 강한 개체의 키를 포함하여 키를 구성        개체-관계 모델 다이어그램  image \n /posts/oracle-db-theory/Untitled_Diagram_(1).png \n9. 논리적 데이터 모델  E-R 다이어그램으로 표현된 개념적 구조를 데이터베이스에 저장할 형태로 표현한 논리적 구조\n  데이터베이스의 논리적 구조 = 데이터베이스 스키마\n  사용자가 생각하는 데이터베이스의 모습 또는 구조\n 관계 데이터 모델  2차원 테이블 형태 일반적으로 많이 사용  10. 데이터베이스 설계 정규화를 이용 나중에 다룸\nE-R 모델과 릴레이션 변환 규칙을 이용  image \n 5단계의 과정이 있음 도중에 오류가 생기면 이전 단계로 돌아갈 수도 있음  1. 요구사항 분석  image \n 사용자의 요구 사항을 수집, 분석해 DB 용도 결정 DB를 실제 사용할 주요 사용자의 범위를 결정 면담, 설문조사, 업무관련 문서 분석 등으로 요구사항 수집 결과물: 요구사항 명세서  2. 개념적 설계  요구사항 명세서를 토대로 개념적 구조로 표현 → 개념적 모델링 일반적으로 E-R 모델 (위에서 배운 개체-관계 모델) 을 많이 사용  작업 과정 A. 개체 추출 : 각 개체의 주요 속성과 키 속성 선별  image \n 개체 : 저장할 만한 가치가 있는 중요 데이터를 가진 사람이나 사물  병원 운영에 필요한 사람: 환자, 의사 간호사 등 병원 운영에 필요한 사물: 병실, 수술실, 의료 장비 등   개체 추출 방법 : 업무에 관련이 깊은 명사를 찾아 개체, 속성으로 분류 위의 예에서는  한빛 마트는 프로젝트의 이름 회원의 속성으로 회원아이디, 비밀번호, 이름, 나이, 직업, 등급, 적립금 회원아이디는 키 속성으로 분류 이렇게 할 수 있겠다   최종 추출 결과 (연습 많이 할 것)   image \n image \n image \nB. 개체 간의 관계 설정  image \n  요구 사항 문장에서 의미 있는 동사를 찾자\n  위의 예시에서는\n 회원 개체와 상품 개체의 관계 : 다대 다 관계 주문 관계의 속성 : 주문번호, 배송지, 주문일자 를 추출 가능    최종\n image \n image \n image \n  C. E-R 다이어그램을 총합해 표현  image \n","date":"2020-09-16T00:00:00Z","permalink":"https://yansigit.github.io/blog/oracle-db-%EC%9D%B4%EB%A1%A0-%EC%A0%95%EB%A6%AC/","title":"ORACLE DB 이론 정리"},{"content":"ORACLE DB 테이블 조인\n테이블 조인 EQUI JOIN  두 테이블에서 공통적으로 존재하는 컬럼의 값이 일치하는 행을 연결하여 결과를 생성\n  컬럼명 앞에 테이블명을 기술해 어느 소속 컬럼인지 확실히 할 수 있다.\n  만약 같은 절에 같은 컬럼명이 두개이상 있다면 명확히 해줘야한다.\n  별칭을 사용할 수도 있음 from emp e, dept d\n selectemp.empno,emp.ename,dept.dnamefromemp,deptwhereemp.deptno=dept.deptno;EMPNOENAMEDNAME---------- ---------- -------------- 7369SMITHRESEARCH7499ALLENSALES7521WARDSALES7566JONESRESEARCH7654MARTINSALES7698BLAKESALES7782CLARKACCOUNTING7839KINGACCOUNTING7844TURNERSALES7900JAMESSALES7902FORDRESEARCHEMPNOENAMEDNAME---------- ---------- -------------- 7934MILLERACCOUNTINGselecte.empno,e.ename,d.dnamefromempe,deptdwheree.deptno=d.deptno;EMPNOENAMEDNAME---------- ---------- -------------- 7369SMITHRESEARCH7499ALLENSALES7521WARDSALES7566JONESRESEARCH7654MARTINSALES7698BLAKESALES7782CLARKACCOUNTING7839KINGACCOUNTING7844TURNERSALES7900JAMESSALES7902FORDRESEARCHEMPNOENAMEDNAME---------- ---------- -------------- 7934MILLERACCOUNTINGSQL\u0026gt;r1selecte.empno,e.ename,d.dname2fromempe,deptd3wheree.deptno=d.deptno4*ande.ename=\u0026#39;ALLEN\u0026#39;EMPNOENAMEDNAME---------- ---------- -------------- 7499ALLENSALESNON-EQUI JOIN  WHERE 절에 = 연산자 이외의 비교 연산자 사용\n SQL\u0026gt;selecte.ename,e.sal,s.grade2fromempe,salgrades3wheree.sal\u0026gt;=s.losalande.sal\u0026lt;=s.hisal;ENAMESALGRADE---------- ---------- ---------- SMITH8001JAMES9501WARD12502MARTIN12502MILLER13002TURNER15003ALLEN16003CLARK24504BLAKE28504JONES29754FORD30004ENAMESALGRADE---------- ---------- ---------- KING50005SQL\u0026gt;r1selecte.ename,e.sal,s.grade2fromempe,salgrades3*wheree.salbetweens.losalands.hisalENAMESALGRADE---------- ---------- ---------- SMITH8001JAMES9501WARD12502MARTIN12502MILLER13002TURNER15003ALLEN16003CLARK24504BLAKE28504JONES29754FORD30004ENAMESALGRADE---------- ---------- ---------- KING50005EQUI + NON-EQUI JOIN SQL\u0026gt;r1selecte.ename,d.dname,s.grade2fromempe,deptd,salgrades3wheree.deptno=d.deptno4*ande.salbetweens.losalands.hisalENAMEDNAMEGRADE---------- -------------- ---------- MILLERACCOUNTING2CLARKACCOUNTING4KINGACCOUNTING5SMITHRESEARCH1JONESRESEARCH4FORDRESEARCH4JAMESSALES1WARDSALES2MARTINSALES2TURNERSALES3ALLENSALES3ENAMEDNAMEGRADE---------- -------------- ---------- BLAKESALES4SELF JOIN  원하는 데이터가 하나의 테이블에 모두 있음\n  자신의 테이블을 별칭을 통해 연결해 원하는 값을 검색\n SQL\u0026gt;r1selecte.ename\u0026#34;사원\u0026#34;,m.ename\u0026#34;팀장\u0026#34;2fromempe,empm3*wheree.mgr=m.empno사원팀장---------- ---------- FORDJONESALLENBLAKEWARDBLAKEMARTINBLAKETURNERBLAKEJAMESBLAKEMILLERCLARKJONESKINGBLAKEKINGCLARKKINGSMITHFORDSQL\u0026gt;r1selecte.ename||\u0026#39; 사원의 매니저는 \u0026#39;||m.ename||\u0026#39;입니다\u0026#39;2fromempe,empm3*wheree.mgr=m.empnoE.ENAME||\u0026#39;사원의매니저는\u0026#39;||M.ENAME||\u0026#39;입니다\u0026#39;----------------------------------------------------- FORD사원의매니저는JONES입니다ALLEN사원의매니저는BLAKE입니다WARD사원의매니저는BLAKE입니다MARTIN사원의매니저는BLAKE입니다TURNER사원의매니저는BLAKE입니다JAMES사원의매니저는BLAKE입니다MILLER사원의매니저는CLARK입니다JONES사원의매니저는KING입니다BLAKE사원의매니저는KING입니다CLARK사원의매니저는KING입니다SMITH사원의매니저는FORD입니다11행이선택되었습니다.OUTER JOIN  조인 조건을 만족하지 못하더라도 해당 행을 결과에 포함\n LEFT OUTER JOIN  where e.mgr = m.empno(+);\n SQL\u0026gt;selecte.ename,m.ename2fromempe,empm3wheree.mgr=m.empno(+);ENAMEENAME---------- ---------- FORDJONESALLENBLAKEWARDBLAKEMARTINBLAKETURNERBLAKEJAMESBLAKEMILLERCLARKJONESKINGBLAKEKINGCLARKKINGSMITHFORDENAMEENAME---------- ---------- KINGSQL\u0026gt;r1selecte.ename\u0026#34;사원\u0026#34;,m.ename\u0026#34;관리자\u0026#34;2fromempeleftouterjoinempm3*one.mgr=m.empno사원관리자---------- ---------- FORDJONESALLENBLAKEWARDBLAKEMARTINBLAKETURNERBLAKEJAMESBLAKEMILLERCLARKJONESKINGBLAKEKINGCLARKKINGSMITHFORD사원관리자---------- ---------- KINGRIGHT OUTER JOIN SQL\u0026gt;r1selecte.ename,d.dname2fromempe,deptd3*wheree.deptno(+)=d.deptnoENAMEDNAME---------- -------------- SMITHRESEARCHALLENSALESWARDSALESJONESRESEARCHMARTINSALESBLAKESALESCLARKACCOUNTINGKINGACCOUNTINGTURNERSALESJAMESSALESFORDRESEARCHENAMEDNAME---------- -------------- MILLERACCOUNTINGOPERATIONSSQL\u0026gt;r1selecte.ename,d.dname2fromemperightouterjoindeptd3*one.deptno=d.deptnoENAMEDNAME---------- -------------- SMITHRESEARCHALLENSALESWARDSALESJONESRESEARCHMARTINSALESBLAKESALESCLARKACCOUNTINGKINGACCOUNTINGTURNERSALESJAMESSALESFORDRESEARCHENAMEDNAME---------- -------------- MILLERACCOUNTINGOPERATIONS","date":"2020-09-16T00:00:00Z","permalink":"https://yansigit.github.io/blog/oracle-db-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%A1%B0%EC%9D%B8/","title":"ORACLE DB 테이블 조인"},{"content":"ORACLE DB 팁 정리\n팁 1. 예전 명령어 체계 사용 계정 생성, 권한 부여 등 편하게 할 수 있음\nalter session set \u0026quot;_ORACLE_SCRIPT\u0026quot;=true;\n1. 날짜 포맷 변경 DATE Format을 변경하는 방법은 크게는 4가지 방법이 있습니다.\n여기서 4번은 일회성이고 나머지 1-3은 반 영구적인 변경방법 입니다.\n1. INIT[dbname].ora 화일 수정  NLS_DATE_FORMAT = \u0026lsquo;RR-MM-DD\u0026rsquo; 이와 같이 변수와 값을 추가.  2. Shell 프로그램 이용   C Shell: OS 상태에서 setenv NLS_DATE_FORMAT 'RR/MM/DD'추가.\n  B Shell: NLS_DATE_FORMAT='RR/MM/DD'\nexport NLS_DATE_FORMAT 추가.\n  K Shell: B Shell 방법과 추가로 export NLS_DATE_FORMAT='RR/MM/DD' 로 표현 가능\n  3. SYS.PROPS$ VIEW를 이용하여 UPDATE하는 방법 4. Session 에서 set 하는 방법  SQLPLUS 상태에서 ALTER SESSION SET \u0026quot;NLS_DATE_FORMAT\u0026quot;='RR/MM/DD' 실행 단 SESSION 내에서만 활용가능  2. 서버 인코딩 변경 출처: http://egloos.zum.com/sstories/v/9584689\n-- SYS 계정 로그인 후 select*fromnls_database_parameterswhereparameterlike\u0026#39;%CHARACTERSET%\u0026#39;;selectVALUE$fromsys.props$wherename=\u0026#39;NLS_LANGUAGE\u0026#39;;updatesys.props$setvalue$=\u0026#39;AL32UTF8\u0026#39;wherename=\u0026#39;NLS_CHARACTERSET\u0026#39;;updatesys.props$setvalue$=\u0026#39;AL32UTF8\u0026#39;wherename=\u0026#39;NLS_NCHAR_CHARACTERSET\u0026#39;;updatesys.props$setvalue$=\u0026#39;KOREAN_KOREA.AL32UTF8\u0026#39;wherename=\u0026#39;NLS_LANGUAGE\u0026#39;;commit;shutdownimmediate;startup;nano /etc/profile # 끝부분에 아래 명령어 추가 export NLS_LANG=KOREAN_KOREA.AL32UTF8 # 다음 재접속 하거나 source /etc/profile -- 그래도 안될 경우에 다음꺼 해보자 (난 안해도 됬었음) -- 다음 다시 sqlplus에서 sys 계정으로 로그인하고 altersystemenablerestrictedsession;altersystemsetjob_queue_processes=0;altersystemsetaq_tm_processes=0;alterdatabaseopen;alterdatabasecharactersetAL32UTF8;shutdownimmidiate;startupmount;","date":"2020-09-16T00:00:00Z","permalink":"https://yansigit.github.io/blog/oracle-db-%ED%8C%81-%EC%A0%95%EB%A6%AC/","title":"ORACLE DB 팁 정리"},{"content":"ORACLE DB 함수 정리\n함수 1. DUAL 테이블  SELECT 절에 기술할 테이블이 없을 경우 사용\n 간혹 10+30 결과를 보는 등 쿼리 작업에서 연산식만 사용하는 경우가 있는데\n실행되려면 테이블 값이 꼭 들어가야 하므로 더미 테이블을 사용하는 것\n기존에 사용하는 테이블을 사용하면 해당 테이블의 행 만큼 출력되어 버림\nSQL\u0026gt;select10+30fromdept;10+30---------- 40404040SQL\u0026gt;select10+30fromdual;10+30---------- 402. 숫자 처리 함수 ROUND (반올림) 함수  지정한 자리 수 이하에서 반올림한 결과를 구해주는 함수\n ROUND(숫자, 반올림자리수)\n image \n  반올림 방법\n 반올림자리(N)가 0 또는 양수이면 N+1 위치에서 반올림 반올림자리가 음수이면 N 위치에서 반올림  SQL\u0026gt;selectround(46.592,0)fromdual;ROUND(46.592,0)--------------- 47SQL\u0026gt;selectround(46.592,1)fromdual;ROUND(46.592,1)--------------- 46.6SQL\u0026gt;selectround(46.592,2)fromdual;ROUND(46.592,2)--------------- 46.59SQL\u0026gt;selectround(46.592,-1)fromdual;ROUND(46.592,-1)---------------- 50SQL\u0026gt;selectround(46.592,-2)fromdual;-- 자리값에서 벗어나면 0 출력하는듯 ROUND(46.592,-2)---------------- 0  TRUNC(버림) 함수  지정한 자리 수 이하에서 버린 결과를 구해주는 함수\n TRUNC(숫자, 버림자리수)\n  버림 방법\n 버림자리수도 반올림 자리수와 마찬가지의 방식을 따른다.  SQL\u0026gt;selecttrunc(46.592,0)fromdual;TRUNC(46.592,0)--------------- 46SQL\u0026gt;selecttrunc(46.592,2)fromdual;TRUNC(46.592,2)--------------- 46.59SQL\u0026gt;selecttrunc(46.592,-1)fromdual;TRUNC(46.592,-1)---------------- 40  MOD(나머지) 함수  나누기 연산을 한 후 나머지를 결과로 리턴\n MOD(컬럼 | 숫자, 나누기값)\nSQL\u0026gt;selectmod(5,2)fromdual;MOD(5,2)---------- 1SQL\u0026gt;selectmod(sal,100)fromempwheredeptno=10;MOD(SAL,100)------------ 50003. 문자 처리 함수 UPPER(대문자), LOWER(소문자) 함수  소문자는 대문자로, 대문자는 소문자로 변환해 출력\n SQL\u0026gt;selectupper(\u0026#39;hello\u0026#39;),lower(\u0026#39;HELLO\u0026#39;)fromdual;UPPERLOWER----- ----- HELLOhelloSQL\u0026gt;selectlower(ename)fromempwhereenamelike\u0026#39;%A%\u0026#39;;LOWER(ENAM---------- allenwardmartinblakeclarkadamsjamesINITCAP 함수  단어의 첫글자만 대문자로 변환해 출력\n SQL\u0026gt;selectinitcap(\u0026#39;HELLO\u0026#39;),initcap(\u0026#39;hello\u0026#39;)fromdual;INITCINITC----- ----- HelloHelloSQL\u0026gt;selectinitcap(ename)fromempwhereenamelike\u0026#39;%A%\u0026#39;;INITCAP(EN---------- AllenWardMartinBlakeClarkAdamsJamesLENGTH 함수  문자열의 길이를 구하여 출력\n SQL\u0026gt;selectlength(\u0026#39;hellohello\u0026#39;)fromdual;LENGTH(\u0026#39;HELLOHELLO\u0026#39;)-------------------- 10SQL\u0026gt;selectename,length(ename)fromemp;ENAMELENGTH(ENAME)---------- ------------- SMITH5ALLEN5WARD4JONES5MARTIN6BLAKE5CLARK5SCOTT5KING4TURNER6ADAMS5ENAMELENGTH(ENAME)---------- ------------- JAMES5FORD4MILLER614rowsselected.INSTR 함수  특정 컬럼 또는 문자열에서 지정 문자의 위치를 반환\n  검색 문자 순서를 생략하면 첫번째로 발견한 검색문자를 반환\n  검색 시작 위치를 생략하면 처음부터 검색\n INSTR(컬럼 | 문자열, 컬럼 | 문자열, [검색할 시작위치], [반환할 검색문자 순서])\n-- \u0026#39;welcome to oracle\u0026#39;의 첫번째부터 소문자 \u0026#39;o\u0026#39;를 검색 selectinstr(\u0026#39;welcome to oracle\u0026#39;,\u0026#39;o\u0026#39;)fromdual;INSTR(\u0026#39;WELCOMETOORACLE\u0026#39;,\u0026#39;O\u0026#39;)---------------------------- 5-- \u0026#39;welcome to oracle\u0026#39;의 6번째부터 소문자 \u0026#39;o\u0026#39;를 검색 selectinstr(\u0026#39;welcome to oracle\u0026#39;,\u0026#39;o\u0026#39;,6)fromdual;INSTR(\u0026#39;WELCOMETOORACLE\u0026#39;,\u0026#39;O\u0026#39;,6)------------------------------ 10-- \u0026#39;welcome to oracle\u0026#39;의 3번째부터 3번째로 검색된 소문자 \u0026#39;o\u0026#39;를 검색 selectinstr(\u0026#39;welcome to oracle\u0026#39;,\u0026#39;o\u0026#39;,3,3)fromdual;INSTR(\u0026#39;WELCOMETOORACLE\u0026#39;,\u0026#39;O\u0026#39;,3,3)-------------------------------- 12SUBSTR 함수  특정 컬럼 또는 문자열에서 지정한 일부분을 추출해 반환\n SUBSTR(컬럼 | 문자열, 시작위치, [추출문자 개수])\nSQL\u0026gt;selectsubstr(\u0026#39;welcome to oracle\u0026#39;,4,3)fromdual;SUB--- comSQL\u0026gt;selectsubstr(\u0026#39;welcome to oracle\u0026#39;,10)fromdual;SUBSTR(\u0026#39; -------- o oracle LPAD, RPAD 함수  오른쪽(왼쪽) 정렬 후 지정 문자를 왼쪽(오른쪽)에 채우는 함수\n LPAD(컬럼 | 문자열, 자리수, '채울문자')\nSQL\u0026gt;selectlpad(\u0026#39;oracle\u0026#39;,10,\u0026#39;*\u0026#39;),rpad(\u0026#39;database\u0026#39;,10,\u0026#39;*\u0026#39;)fromdual;LPAD(\u0026#39;ORAC RPAD(\u0026#39;DATA---------- ---------- ****oracledatabase**SQL\u0026gt;selectlpad(\u0026#39;morning\u0026#39;,16,\u0026#39;#%\u0026#39;)fromdual;LPAD(\u0026#39;MORNING\u0026#39;,1---------------- #%#%#%#%#morningLTRIM, RTRIM 함수  왼쪽(오른쪽) 지정 문자가 연속이면 지정 문자를 삭제\n LTRIM(컬럼 | 문자열, '삭제문자');\nSQL\u0026gt;selectltrim(\u0026#39;****oracle\u0026#39;,\u0026#39;*\u0026#39;),rtrim(\u0026#39;oracle****\u0026#39;,\u0026#39;*\u0026#39;)fromdual;LTRIM(RTRIM(------ ------ oracleoracleSQL\u0026gt;selectltrim(\u0026#39;****ora**cle**\u0026#39;,\u0026#39;*\u0026#39;)fromdual;LTRIM(\u0026#39;*** ---------- ora**cle** TRIM 함수  양쪽에 지정 문자가 연속이면 지정 문자를 삭제\n trim('삭제할문자' from '문자열')\nSQL\u0026gt;selecttrim(\u0026#39;*\u0026#39;from\u0026#39;****ora**cle*****\u0026#39;)fromdual;TRIM(\u0026#39;*\u0026#39;-------- ora**cle4. 날짜 처리 함수  대부분 일 단위로 계산\n SYSDATE 함수  시스템에 저장된 현재 날짜와 시간을 반환\n  SYSDATE+1 (내일 날짜), SYSDATE-1 (어제 날짜)\n SQL\u0026gt;selectsysdatefromdual;SYSDATE--------- 15-APR-20SQL\u0026gt;selectsysdate+1fromdual;SYSDATE+1--------- 16-APR-20SQL\u0026gt;selectsysdate-1fromdual;SYSDATE-1--------- 14-APR-20-- 20번 부서 사원들의 현재까지 근무 일수를 출력 SQL\u0026gt;selectename,hiredate,sysdate-hiredate\u0026#34;근무일수\u0026#34;fromempwheredeptno=20;ENAMEHIREDATE근무일수---------- -------- ---------- SMITH80/12/1714364.8731JONES81/04/0214258.8731SCOTT87/04/1912050.8731ADAMS87/05/2312016.8731FORD81/12/0314013.8731SQL\u0026gt;selectename,hiredate,trunc(sysdate-hiredate,0)\u0026#34;근무일수\u0026#34;fromempwheredeptno=20;ENAMEHIREDATE근무일수---------- -------- ---------- SMITH80/12/1714364JONES81/04/0214258SCOTT87/04/1912050ADAMS87/05/2312016FORD81/12/0314013MONTHS_BETWEEN 함수  날짜와 날짜 사이의 개월 수를 구하는 함수\n MONTHS_BETWEEN(최근날짜, 이전날짜)\nSQL\u0026gt;selectename,hiredate,months_between(sysdate,hiredate)fromemp;ENAMEHIREDATEMONTHS_BETWEEN(SYSDATE,HIREDATE)---------- -------- -------------------------------- SMITH80/12/17471.963657ALLEN81/02/20469.866883WARD81/02/22469.802367JONES81/04/02468.447528MARTIN81/09/28462.608818BLAKE81/05/01467.479786CLARK81/06/09466.221722SCOTT87/04/19395.899141KING81/11/17460.963657TURNER81/09/08463.25398ADAMS87/05/23394.770109ENAMEHIREDATEMONTHS_BETWEEN(SYSDATE,HIREDATE)---------- -------- -------------------------------- JAMES81/12/03460.41527FORD81/12/03460.41527MILLER82/01/23458.77010914행이선택되었습니다.ADD_MONTHS 함수  지정한 개월 수를 더한 날짜를 구하는 함수\n ADD_MONTHS(날짜, 더할 개월 수)\nSQL\u0026gt;selectsysdate,add_months(sysdate,12)fromdual;SYSDATEADD_MONT-------- -------- 20/04/1521/04/15SQL\u0026gt;selecthiredate,add_months(hiredate,6)fromempwheredeptno=20;HIREDATEADD_MONT-------- -------- 80/12/1781/06/1781/04/0281/10/0287/04/1987/10/1987/05/2387/11/2381/12/0382/06/03LAST_DAY 함수  해당 날짜가 속한 달의 마지막 날짜를 반환\n LAST_DAY(날짜)\nSQL\u0026gt;selecthiredate,last_day(hiredate)fromempwheredeptno=20;HIREDATELAST_DAY-------- -------- 80/12/1780/12/3181/04/0281/04/3087/04/1987/04/3087/05/2387/05/3181/12/0381/12/31NEXT_DAY 함수  해당 날짜 이후로 명시된 요일에 해당되는 날짜를 반환\n  요일 파라미터에는\n  \u0026lsquo;월\u0026rsquo;, \u0026lsquo;화\u0026rsquo;, \u0026lsquo;MON\u0026rsquo;, \u0026lsquo;TUE\u0026rsquo;, 1(일), 2(월), 3(화) 등 사용 가능\n NEXT_DAY(날짜, 요일)\nselectnext_day(sysdate,\u0026#39;월\u0026#39;)fromdual;5. 데이터형 변환 함수  숫자, 문자, 날짜의 데이터형을 변환해야 하는 경우 사용\n TO_NUMBER 함수 # 문자 → 숫자 TO_NUMBER('숫자문자열')\nSQL\u0026gt;selectto_number(\u0026#39;15522\u0026#39;)fromdual;SQL\u0026gt;selectto_number(\u0026#39;1444\u0026#39;)+1fromdual;TO_NUMBER(\u0026#39;1444\u0026#39;)+1------------------- 1445TO_CHAR 함수 # 숫자|날짜 → 문자 TO_CHAR(숫자|날짜, 형별포맷)\n image \nselectto_char(sysdate,\u0026#39;YYYY/MM/DD HH24:MI:SS DAY\u0026#39;)fromdual;selectto_char(sal,\u0026#39;L999,999\u0026#39;)fromempwheredeptno=20;TO_DATE 함수 # 문자 → 날짜  DATE형은 날짜와 시간을 포함한다\n TO_DATE(문자열, 해당문자열의 날짜 포맷)\n image \nselectto_date(\u0026#39;2020-01-20\u0026#39;,\u0026#39;YYYY-MM-DD\u0026#39;)fromdual;selectto_date(\u0026#39;2020-1월-20\u0026#39;,\u0026#39;YYYY-MON-DD\u0026#39;)fromdual;selectto_date(\u0026#39;20-1월-20\u0026#39;,\u0026#39;YY-MON-DD\u0026#39;)fromdual;6. 기타 함수 NVL 함수 NVL(컬럼, 변환값)\n NULL이 있으면 0 또는 다른 값으로 변환\n SQL\u0026gt;selectempno,commfromemp;EMPNOCOMM---------- ---------- 7369749930075215007566765414007698778277887839784407876EMPNOCOMM---------- ---------- 79007902793414행이선택되었습니다.SQL\u0026gt;selectempno,nvl(comm,0)fromemp;EMPNONVL(COMM,0)---------- ----------- 73690749930075215007566076541400769807782077880783907844078760EMPNONVL(COMM,0)---------- ----------- 79000790207934014행이선택되었습니다.DECODE 함수  SWITCH CASE 와 유사\n  마지막에 비교값 없이 처리값만 넣으면 else 처럼 동작. (즉 기본값)\n DECODE(표현식|컬럼명, 비교1, 처리1, 비교2, 처리2, ...)\n-- deptno 값을 보고 그에 맞는 문자열 출력 selectename,deptno,decode(deptno,10,\u0026#39;회계\u0026#39;,20,\u0026#39;영업\u0026#39;,30,\u0026#39;마케팅\u0026#39;,40,\u0026#39;경영\u0026#39;)\u0026#34;부서명\u0026#34;fromemp;ENAMEDEPTNO부서명---------- ---------- --------------------------- SMITH20영업ALLEN30마케팅WARD30마케팅JONES20영업MARTIN30마케팅BLAKE30마케팅CLARK10회계SCOTT20영업KING10회계TURNER30마케팅ADAMS20영업ENAMEDEPTNO부서명---------- ---------- --------------------------- JAMES30마케팅FORD20영업MILLER10회계-- 기본값 테스트 selectename,deptno,decode(deptno,10,\u0026#39;회계\u0026#39;,20,\u0026#39;영업\u0026#39;,\u0026#39;테스트\u0026#39;)\u0026#34;부서명\u0026#34;fromemp;ENAMEDEPTNO부서명---------- ---------- --------------------------- SMITH20영업ALLEN30테스트WARD30테스트JONES20영업MARTIN30테스트BLAKE30테스트CLARK10회계SCOTT20영업KING10회계TURNER30테스트ADAMS20영업ENAMEDEPTNO부서명---------- ---------- --------------------------- JAMES30테스트FORD20영업MILLER10회계CASE 함수  DECODE 함수는 값이 같을때만 가능\n  CASE 함수는 다양한 비교 연산 가능\n selectename,deptno,casewhendeptno=10then\u0026#39;회계\u0026#39;whendeptno=20then\u0026#39;마케팅\u0026#39;whendeptno=30then\u0026#39;영업\u0026#39;whendeptno=40then\u0026#39;경영\u0026#39;end\u0026#34;부서명\u0026#34;fromemp;ENAMEDEPTNO부서명---------- ---------- --------------------------- SMITH20마케팅ALLEN30영업WARD30영업JONES20마케팅MARTIN30영업BLAKE30영업CLARK10회계SCOTT20마케팅KING10회계TURNER30영업ADAMS20마케팅ENAMEDEPTNO부서명---------- ---------- --------------------------- JAMES30영업FORD20마케팅MILLER10회계14행이선택되었습니다.selectename,job,casewhenjob=\u0026#39;CLERK\u0026#39;thensal+(sal*0.2)whenjob=\u0026#39;ANALYST\u0026#39;thensal+(sal*0.15)whenjob=\u0026#39;MANAGER\u0026#39;thensal+(sal*0.1)elsesalend\u0026#34;salary\u0026#34;fromemp;7. 그룹 함수  전체 데이터를 그룹별로 구분해 통계적인 결과를 구할 때 사용\n  기본 select 쿼리 절에서는 그룹함수와 단순 컬럼 함께 사용 불가\n SQL\u0026gt;selectmax(sal),enamefromemp;selectmax(sal),enamefromemp*1행에오류:ORA-00937:단일그룹의그룹함수가아닙니다단일행 함수 입력 데이터를 하나씩 처리하는 함수\n image \nselectlength(ename)fromemp;LENGTH(ENAME)------------- 55456554654LENGTH(ENAME)------------- 6다중행 함수 입력 데이터를 한 번에 처리해 나오는 결과값이 하나\n image \nselectcount(ename)fromemp;COUNT(ENAME)------------ 12SUM 함수  지정한 컬럼 값들의 총합을 구하는 함수 (Null 제외)\n selectsum(sal)fromemp;SUM(SAL)---------- 24925AVG 함수  지정한 컬럼 값들의 평균을 구함\n selectround(avg(sal),1)\u0026#34;평균급여\u0026#34;fromemp;AVG(SAL)---------- 2077.08333MAX, MIN 함수  지정한 컬럼 값들의 최대값, 최소값을 구함\n  문자, 날짜 데이터에도 사용 가능 (사전상 빠른 문자열, 오래된 날짜가 Min)\n selectmin(sal)\u0026#34;최소급여\u0026#34;,max(sal)\u0026#34;최대급여\u0026#34;fromemp;최소급여최대급여---------- ---------- 8005000selectmin(ename),max(ename),min(hiredate),max(hiredate)fromemp;MIN(ENAME)MAX(ENAME)MIN(HIREMAX(HIRE---------- ---------- -------- -------- ALLENWARD80/12/1782/01/23COUNT 함수  테이블 전체 또는 컬럼의 총 행의 갯수를 출력 (Null 제외)\n selectcount(*)fromsometable;-- 테이블의 총 행의 갯수 반환 selectcount(col)fromsometable;-- 해당 컬럼의 총 행의 갯수 반환 selectcount(comm)fromemp;-- 널 값이 있는 행은 제외됨 COUNT(COMM)----------- 4GROUP BY 절  전체 데이터를 그룹별로 나눠 정렬해줌\n  GROUP BY 절을 사용하면 해당 그룹 함수와 함께 해당 컬럼을 같이 select 해 사용 가능\n  image \nSQL\u0026gt;selectdeptno,avg(sal)fromempgroupbydeptno;DEPTNOAVG(SAL)---------- ---------- 301566.66667102916.66667202258.33333SQL\u0026gt;selectdeptno,count(*),count(comm)fromempgroupbydeptno;DEPTNOCOUNT(*)COUNT(COMM)---------- ---------- ----------- 306410302030SQL\u0026gt;selectjob,count(*),avg(sal)fromempgroupbyjob;JOBCOUNT(*)AVG(SAL)--------- ---------- ---------- CLERK31016.66667SALESMAN41400ANALYST13000MANAGER32758.33333PRESIDENT15000HAVING 절  GROUP BY 절에 의해 생성된 결과 중 원하는 조건을 만족하는 데이터만 출력\n  WHERE 절에는 그룹함수를 사용할 수 없음\n SQL\u0026gt;selectdeptno,avg(sal)fromempgroupbydeptnohavingavg(sal)\u0026gt;=2000;DEPTNOAVG(SAL)---------- ---------- 102916.66667202258.33333-- 급여를 1000이상 받는 사원들의 평균 급여가 2000이상인 부서의 번호와 부서별 평균 급여 출력 SQL\u0026gt;selectdeptno,avg(sal)fromempwheresal\u0026gt;=1000groupbydeptnohavingavg(sal)\u0026gt;=2000;DEPTNOAVG(SAL)---------- ---------- 102916.66667202987.5","date":"2020-09-16T00:00:00Z","permalink":"https://yansigit.github.io/blog/oracle-db-%ED%95%A8%EC%88%98-%EC%A0%95%EB%A6%AC/","title":"ORACLE DB 함수 정리"},{"content":" 지금까지 배운 화소단위 처리는 새로운 영상을 생성할 때 특정 화소만의 값을 이용해 처리\n  영역처리는 출력 화소를 만들기 위해 입력화소 뿐만 아니라 그 이웃한 화소들도 이용\n  영역처리 방법  컨볼루션 (회선) 양각효과 평균값 필터링 중간값 필터링 샤프닝 윤곽선 검출    컨볼루션 (회선)  출력화소의 값을 계산하기 위해 입력화소, 이웃화소값에 회선 마스크의 값을 곱하여 구하는 기법\n  image \n 회선마스크의 경우 대부분 3X3, 5X5 크기를 많이 사용. 회선마스크의 크기가 증가할수록 계산의 양은 지수함수적으로 증가 이 방법으로는 구할수없는 영상의 가장자리 픽셀들의 경우  빈 마스크의 계수를 0으로 가정하여 계산하거나 계산을 아예 하지 않거나 (제일 많이 사용) 경계부분의 화소를 복사   보통 RGB의 경우 HSI 컬러 스페이스로 변환해 밝기 채널에 대해서만 연산을 수행한다  # 컨볼루션 연산 담당 함수 result = cv2.filter2D(소스이미지, -1, 필터) 평균값 필터링 (블러링)  현 픽셀의 값을 주위 픽셀들의 평균값으로 대체\n  image \n 평균값의 마스크의 경우 위와같이 모든 구역의 합은 1이 되도록한다.  import cv2 import numpy as np img = cv2.imread(\u0026#39;dog.jpg\u0026#39;) blur_filter = np.ones((5, 5))/25 blured = cv2.filter2D(img, -1, blur_filter) # 필터 가지고 직접 생성 blured = cv2.blur(img, (5, 5)) # 자동으로 필터 생성 후 블러처리까지 blured = cv2.boxFilter(img, -1, (5, 5)) # 역시 자동으로 필터 생성 후 블러처리까지 cv2.imshow(\u0026#39;결과\u0026#39;, blured) cv2.waitKey() cv2.destroyAllWindows() 이미지 합치기 (팁) # 가로로 스택처럼 합쳐짐 merged = np.hstack((img1, img2, img3)) 가우시안 블러링  중앙 값이 가장 크고 멀어질수록 그 값이 작아지는 가중 평균값 필터를 사용\n  image \n# 직접 필터 생성하여 블러 k1 = np.array([[1, 2, 1], [2, 4, 2], [1, 2, 1]]) * (1/16) blur1 = cv2.filter2D(img, -1, k1) k2 = cv2.getGaussianKernel(3, 0) blur2 = cv2.filter2D(img, -1, k2*k2.T) # 1차원 배열 2차원으로 # cv2.GaussianBlur(이미지, 필터크기, 표준편차) blur3 = cv2.GaussianBlur(img, (3,3), 0) 중간값 필터링  현 픽셀 주위에 있는 픽셀값들을 정렬해 그것들의 중간값으로 현 픽셀의 값을 대체\n  Salt and Pepper의 노이즈는 0또는 255같은 극단값이기에 그러한 잡음을 제거하는데 효과적\n  image \n# (소스, 커널크기) blur = cv2.medianBlur(img, 5)  수채화 효과가 나타나기도 함  바이레터럴 필터  블러링 필터는 잡음을 제거하는데 효과가 있으나 경계가 흐릿해짐\n  개선을 위해 가우시안 필터 + 경계 필터 2개를 사용. 속도는 느림.\n # (소스, 필터직경, 컬러스페이스_표준편차, 좌표공간_표준편차) # 보통 두개 표준편차는 같은 값 씀 blur = cv2.bilateralFilter(img, 5, 75, 75) 경계선 검출  색상값 또는 밝기의 변화가 큰 부분이 경계 부분이라고 가정하고 추출\n 에지의 요인  image \n 물체면의 차이 Surface-Normal Discontinuity  물체 표면의 법선 벡터가 급격히 변하는 곳 뚜껑 윗부분과 벽 부분처럼 거의 90도 차이가 남   거리의 차이 Depth Discontinuity  카메라로부터 거리가 급격히 변하는 곳 병과 그 배경은 깊이감이 다름   물체표면 반사도의 차이 Surface-Reflectance Discontinuity  기하학적으로는 차이가 없지만 색깔이 급변하는 곳 글씨가 쓰여있고 안쓰여있고   조명의 차이 Illumination Discontinuity  그림자가 있는 부분 없는 부분    에지 프로파일  밝기의 변화를 그래프화 한 것\n  스텝 에지  계단처럼 밝기가 급격히 변화   램프 에지  밝기가 서서히 변화   라인 에지  두 개의 스텝 에지가 겹침   루프 에지  두 개의 램프 에지가 겹침    로버츠 마스크 # 로버츠 커널 gx_kernel = np.array([[1, 0], [0, -1]]) gy_kernel = np.array([[0, 1], [-1, 0]]) edge_gx = cv2.filter2D(img, -1, gx_kernel) edge_gy = cv2.filter2D(img, -1, gy_kernel) marged = edge_gx + edge_gy  가장 먼저 고안됨 마스크 크기가 작아 연산이 빠름 잡음에 민감  프리윗 마스크  image \ngx_kernel = np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]]) gy_kernel = np.array([[-1, -1, -1], [0, 0, 0], [1, 1, 1]]) edge_gx = cv2.filter2D(img, -1, gx_kernel) edge_gy = cv2.filter2D(img, -1, gy_kernel) marged = edge_gx + edge_gy  대각선보다 수평 에지와 수직 에지를 잘 검출 소벨 마스크보다는 연산 빠름  소벨 마스크  image \ngx_kernel = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]) gy_kernel = np.array([[-1, -2, -1], [0, 0, 0], [1, 2, 1]]) edge_gx = cv2.filter2D(img, -1, gx_kernel) edge_gy = cv2.filter2D(img, -1, gy_kernel) # (소스, -1, x여부, y여부, ksize=(필터크기)) # 사실 x여부, y여부가 아니라 미분 차수라는데 난 잘 모르니깐.. sobelx = cv2.Sobel(img, -1, 1, 0, ksize=3) sobely = cv2.Sobel(img, -1, 0, 1, ksize=3)  수평, 수직보다 대각선 에지를 잘 검출 비교적 잡음에 강함  라플라시안 마스크  image \nedge = cv2.Laplacian(img, -1)  잡음에 매우 민감해 사전에 가우시안 필터로 노이즈를 제거하고 사용하는것을 추천 X, Y 동시에 검출하는 모습  케니 엣지  가장 유명한 엣지 검출법. 네 가지의 단계를 거쳐 엣지 검출\n # (소스, minVal, maxVal) # 보통 2배, 3배 차이 권장 edges = cv2.Canny(img, 150, 300)  Noise Reduction  이미지의 노이즈를 제거. 5 X 5의 가우시안 필터 사용   Edge Gradient Detection  Gradient들의 방향과 각도 확인 경계값에서는 주변과 색이 다르기 때문에 미분값이 급속도로 변함 이를 통해 경계값 후보군 선별 소벨 엣지를 쓴다   Non maximum Suppression  이미지의 픽셀을 Full Scan하여 엣지가 아닌 픽셀은 제거   Hysteresis Thresholding  지금까지 엣지로 판단된 픽셀이 진짜 엣지인지 판별 maxVal, minVal을 설정  maxVal 이상은 강한 엣지, minVal ~ maxVal 은 약한 엣지로 설정 약한 엣지가 진짜 엣지인지 확인  강한 엣지와 연결이 되어있으면 엣지로 판단 아니라면 제거       ","date":"2020-09-16T00:08:03+09:00","permalink":"https://yansigit.github.io/blog/opencv-spatial-domain/","title":"OpenCV Spatial Domain"},{"content":"정수배의 확대  /files/보간1.png \n 가장 간단한 방법 정해진 배율만큼 화소를 반복적으로 복사 화질이 좋지 않음  정수배의 역수만큼 축소  /files/보간2.png \n 정해진 배율만큼 건너뛰면서 화소 선택 예를 들어 2분의 1로 축소하는 경우 모든 짝수번째 행과 짝수번째 열의 모든 픽셀을 출력 영상에 복사 영상의 세밀한 정보 (특히 문서의 경우)가 소실될 수 있다  사상 (Mapping)  주어진 조건에 따라 한 좌표가 다른 좌표로 대응\n 전방향 매핑 (Forward Mapping)  입력 영상의 좌표값을 출력 영상의 좌표값으로 변환 홀과 오버랩 문제가 발생 가능   /files/보간3.png \n- **홀** : 출력영상으로 매핑되는 입력화소가 없는 경우 - **오버랩** : 두 입력화소가 같은 출력화소에 매핑되는 경우 - 위의 그림의 경우 아래 두 화소는 정상적으로 하나씩 매핑이 되었으나 출력영상의 첫째 픽셀에 두개의 화소가 매핑되어 오버랩이 발생하고 두번째 픽셀에는 아무 픽셀도 매핑되지 않아 홀이 발생한 모습  전방향 매핑의 문제점  크기가 5인 1차원 배열 소스를 1.4배 확대한다고 가정한다면..  destination (pixel) index = source index * 1.4 인데\u0026hellip;  인덱스값은 정수가 되어야 하므로 반올림해줘야 한다. 즉 소스가 0, 1, 2, 3, 4 일 경우 destination은 0, 1, 3, 4, 6이 되는데 이러면 2, 5가 빠져버리는 홀이 발생하게 된다. 그래서 source index = destination index / 1.4 이렇게 역으로 취해줘서 (역방향 매핑) 각 destination 픽셀에 맞는 정수 인덱스에 대응하는 소스 픽셀값을 가져오면 된다.     크기가 7인 1차원 배열 소스를 1.4배 축소한다고 하면\u0026hellip;  destination index = source index / 1.4  소스={0,1,2,3,4} 일 경우 {0,1,1,2,3} 으로 중복으로 매핑되어버리는 오버랩이 발생. 해결책은 역시 source index = destination index * 1.4 로 역방향 매핑해주어 destination index를 하나하나 차근차근 대입하여 소스 픽셀값을 가져오는 것      역방향 매핑 (Reverse Mapping) - 확대  출력 영상의 좌표값을 입력 영상의 좌표값으로 변환   /files/보간4.png \n 출력영상의 픽셀 좌표들을 줄이면 그게 매핑되야할 입력 영상의 좌표들이다.  역방향 매핑 (Reverse Mapping) - 축소  /files/보간5.png \n 역시 출력영상을 늘리면 그게 매핑되어야 할 입력 영상의 좌표들이 된다.  보간법  영상의 크기가 너무 작아서 확대해야 하거나 크기가 너무 커서 적당한 크기로 축소해야 하는 경우 등에서 영상을 보간해야 할 필요가 있을 수 있다 영상의 화질이 좋기 위해서는 처리량(수행시간)이 늘어나야 함  최근접 이웃 보간법  /files/보간6.png \n 생성된 주소에 가장 가까운 화소를 출력 화소로 결정  위의 예에서는 (실수값으로 온) T가 A에 제일 가까우므로 A로 결정   처리속도가 빠름 화질이 좋지못함  양선형 보간법  /files/보간7.png \n /files/보간8.png \n /files/보간9.png \n 생성된 주소에 가장 가까운 네 화소들의 가중 합으로 출력 화소 결정 각 가중치는 각 화소로부터의 거리에 반비례  형광칠한 부분이 그거 의미. 위 그림 보면서 이해하면 매우 쉬움.   최근접 이웃 보간법보다 화질 좋으나, 더 많은 계산 소요 ","date":"2020-09-16T00:06:46+09:00","permalink":"https://yansigit.github.io/blog/opencv-linear-interpolation/","title":"OpenCV Linear Interpolation"},{"content":" 임의의 기하학적 변환에 의해 화소들의 위치와 화소값을 변경\n  화소들을 움직이거나 새로운 화소를 보간법에 의해 생성\n 1. 선형 크기 변환  /files/기하학적1.png \n 직선은 그대로 직선으로, 평행은 그대로 평행으로 Affine 변환이라고도 함  이동, 확대/축소, 회전  /files/기하학적2.png \n어핀 변환  /files/기하학적3.png \npts1 = np.float32([[100, 50], [200, 50], [100, 200]]) # 입력 3 좌표 pts2 = np.float32([[80, 70], [210, 60], [250, 120]]) # 출력 3 좌표 mtrx = cv2.getAffineTransform(pts1, pts2) # 입력좌표를 출력좌표로 옮기는 Affine 변환 매트릭스 생성 res = cv2.warpAffine(img, mtrx, (cols, rows)) cv2.imshow(\u0026#39;45\u0026#39;, res) 찌그러뜨림 (Shear Transform)  /files/기하학적4.png \n거울상  /files/기하학적5.png \n2. 비선형 기하 변환  선의 평생성이 보존되지 않는 변환 perspective 변환 영상을 찌그러뜨리는 warping 과 morphing 기법 ","date":"2020-09-16T00:06:11+09:00","permalink":"https://yansigit.github.io/blog/opencv-geometric-transform/","title":"OpenCV Geometric Transform"},{"content":"1. 개요  이미지의 밝기 분포를 그래프로 표현한 방식\n  즉 각 픽셀의 밝기를 모아 그래프로 표현한 것\n  image \n# cv2.calcHist([image], [채널], [마스크], [histSize], [ranges] # histSize는  hist = cv2.calcHist([image], [0], None, [256], [0, 255]) plt.plot(hist, color) import cv2 import matplotlib.pylab as plt img = cv2.imread(\u0026#39;dog.jpg\u0026#39;) cv2.imshow(\u0026#39;img\u0026#39;, img) channels = cv2.split(img) # b, g, r의 픽셀값들이 각각 나뉘어 들어감 colors = (\u0026#39;b\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;) # 이거랑 zip 해주면 # 인덱싱하듯 (b의 화솟값들, b) (g 화솟값들, g) 이런식으로 됨 for (ch, color) in zip(channels, colors): hist = cv2.calcHist([ch], [0], None, [256], [0, 255]) plt.plot(hist, color) plt.show()  BINS: 히스토그램 그래프의 X축의 간격. OpenCV에서는 hisSize로 표현 Ranges : 화소가 가지는 값의 범위 리스트로 줄 수 있으므로 이렇게 For로 안하고 리스트로 몇개씩 한꺼번에 넣어 그래프를 그릴수도 있다.  채널은 이렇게 한꺼번에 줄 때..  예를들어 칼라 이미지 2개를 주고 채널 [0,4]를 넣어준다면 그 이미지의 G, B, R 순으로.. 이미지 1의 G, 이미지 2의 B 채널을 선택해 해당 채널의 화소 분포 그래프를 그려줄 것이다.      2. 히스토그램 평탄화 (이퀄라이즈)  이미지의 대비를 좀 더 높게\n  image \nequalized_img = cv2.equalizeHist(img) hist = cv2.calcHist([equalized_img], [0], None, [256], [0, 256]) plt.plot(hist) 컬러 이미지 이퀄라이즈 img = cv2.imread(\u0026#39;image.jpg\u0026#39;) # yuv로 변경 img_yuv = cv2.cvtColor(img, cv2.COLOR_BGR2YUV) # yuv의 첫번째 컬러 스케일에 대해 이퀄라이즈 적용 (밝기) img_yuv[:,:,0] = cv2.equalizeHist(img_yuv[:,:,0]) # 다시 bgr로 변경 img = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR) cv2.imshow(\u0026#39;Result\u0026#39;, img2) cv2.waitKey() cv2.destroyAllWindows() 일정 부분별로 나눠 이퀄라이즈 적용 # clibLimit : Contrast 제한 경계 값. 기본 40.0 # tileGridSize : 영역 크기. 기본 8 X 8 clahe = cv2.createCLAHE(clipLimit, tileGridSize) # src : 이미지 clahe.apply(src) clahe = cv2.createCLAHE(3.0, (8, 8)) img_yuv[:,:,0] = clahe.apply(img_yuv[:,:,0]) img_result = cv2.cvtColor(img_yuv, cv2.COLOR_YUV2BGR) cv2.imshow(img_result) ","date":"2020-09-16T00:05:22+09:00","permalink":"https://yansigit.github.io/blog/opencv-histogram/","title":"OpenCV Histogram"},{"content":"카메라 처리 # cv2.VideoCapture(카메라번호) cap = cv2.VideoCapture(0) cap.get(cv2.CAP_PROP_FRAME_WIDTH) cap.get(cv2.CAP_PROP_FRAME_HEIGHT) cap.set(cv2.CAP_PROP_FRAME_WIDTH, 320) cap.set(cv2.CAP_PROP_FRAME_WIDTH, 240) if cap.isOpened(): while True: ret, img = cap.read() # 다음 프레임 읽기 if ret: cv2.imshow(\u0026#39;camera\u0026#39;, img) if cv2.waitKey(1) != -1: # 1ms 동안 키 입력 대기 cv2.imwrite(\u0026#39;snapshot.jpg\u0026#39;, img) # 키 입력 있으면 프레임 저장 break else: print(\u0026#39;프레임 없음\u0026#39;) break else: print(\u0026#34;카메라 오픈 오류\u0026#34;) cap.release() cv2.destroyAllWindows() 비디오 일부분 레코드 cap = cv2.VideoCapture(0) if cap.isOpened: file_path = \u0026#39;./record_fps.avi\u0026#39; # fps = 15.0 fps = cap.get(cv2.CAP_PROP_FPS) print(\u0026#39;fps=\u0026#39;, fps) fourcc = cv2.VideoWriter_fourcc(*\u0026#39;DIVX\u0026#39;) # 인코딩 포맷 width = cap.get(cv2.CAP_PROP_FRAME_WIDTH) height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT) size = (int(width), int(height)) # cv2.VideoWriter(저장될_녹화파일_경로, 인코딩포맷, FPS, (가로길이, 세로길이)) out = cv2.VideoWriter(file_path, fourcc, fps, size) # VideoWriter 객체 생성 while True: ret, frame = cap.read() if ret: cv2.imshow(\u0026#39;camera-recording\u0026#39;, frame) out.write(frame) if cv2.waitKey(int(1000/fps) != -1 : break else: print(\u0026#39;no frame\u0026#39;) break out.release() else: print(\u0026#39;열 수 없습니다\u0026#39;) cap.release() cv2.destroyAllWindows() ","date":"2020-09-16T00:04:34+09:00","permalink":"https://yansigit.github.io/blog/dealing-with-camera-on-opencv/","title":"Dealing With Camera on OpenCV"},{"content":"비트 연산 bitAnd = cv2.bitwise_and(img1, img2) bitOr = cv2.bitwise_or(img1, img2) bitXor = cv2.bitwise_xor(img1, img2) bitNot = cv2.bitwise_not(img1) 비트 연산으로 이미지 마스킹 mask = np.zeros_like(img) cv2.circle(mask, (150,140), 100, (255, 255, 255), -1) masked = cv2.bitwise_and(img, mask) # 2차원 배열만 사용 mask = np.zeros[img.shape[:2], dtype=np.uint8) cv2.circle(mask, (150,140), 100, (255, 255, 255), -1) masked = cv2.bitwise_and(img, img, mask=mask) 영상의 차이  틀린 그림 찾기\n # 두 영상의 절대값 차 연산 diff = cv2.absdiff(img1_gray, img2_gray) # 두 이미지 차이 부분만 픽셀값 남아있음 # 차 영상을 극대화하기 위해 쓰레드홀드 처리 및 칼라 변환 _, diff = cv2.threshold(diff, 1, 255, cv2.THRESH_BINARY) # 두 이미지 차이부분 모두 255 diff_red = cv2.cvtColor(diff, cv2.COLOR_GRAY2BGR) # 차이 부분 (255, 255, 255)로 바뀜 cv2.imshow(\u0026#39;diff_red\u0026#39;, diff_red) diff_red[:,:,2] = 0 # 차이 부분 (255, 255, 0)으로 바뀜 cv2.imshow(\u0026#39;diff_red\u0026#39;, diff_red) # 두 번째 이미지에 변화 부분 표시 spot = cv2.bitwise_xor(img2, diff_red) # 차이 부분 (0, 0, 255)로 바뀜 (빨강) # 결과 영상 출력 cv2.imshow(\u0026#39;img1\u0026#39;, img1) ","date":"2020-09-16T00:04:09+09:00","permalink":"https://yansigit.github.io/blog/opencv-%EB%B9%84%ED%8A%B8%EC%97%B0%EC%82%B0/","title":"OpenCV 비트연산"},{"content":"12. 블렌딩  OpenCV는 Saturation 연산을 하고, Numpy는 Modulo 연산을 한다\n a = np.uint8([[200, 50]]) b = np.uint8([[100, 100]]) add1 = a + b # [[44 150]] (오버플로우된 값이 반영) add2 = cv2.add(a, b) # [[255 150]] (uint8 한계치인 255까지만 반영) sub1 = a - b # [[100 206]] (음수 오버플로우되어 반영) sub2 = cv2.substract(a, b) # [[100 0]] (unit 한계치인 0까지만 반영)  Saturation : 0~255까지 한계치를 두고 연산 Modulo : 오버플로우가 일어나면 그 일어난 값만큼 다시 한계치에서 더해줌  알파 블렌딩  이미지를 합칠 때 가중치를 두어 합치는 방법\n  image \nimport cv2 import numpy as np alpha = 0.5 # 합성에 사용할 알파 값 img1 = cv2.imread(\u0026#39;img1.jpg\u0026#39;) img2 = cv2.imread(\u0026#39;img2.jpg\u0026#39;) blended = img*alpha + img2*(1-alpha) blended = blended.astype(np.uint8) # 소수점 발생 제거 cv2.imshow(\u0026#39;numpy 배열 직접 연산\u0026#39;, blended) # cv2.addWeighted(합성대상1, 합성대상1_가중치, 합성대상2, 합성대상2_가중치, 연산결과에_가감할_상수) dst = cv2.addWeighted(img1, alpha, img2, (1-alpha), 0) cv2.imshow(\u0026#39;cv2의 addWeighted 사용\u0026#39;, dst) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2020-09-16T00:03:51+09:00","permalink":"https://yansigit.github.io/blog/opencv-blending/","title":"OpenCV Blending"},{"content":"기본 # 1. numpy 이용 threst_np = np.zeros_like(img) # 원본과 동일한 크기의 0으로 채워진 이미지 생성 threst_np[img \u0026gt; 127] = 255 # 127보다 큰 값만 255로 변경 # 2. opencv 이용 # 사용된_경계값, 이미지_결과 = cv2.threshold(img, 경계_값, 적용_값, 타입_플래그) ret, thresh_cv = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY) plt.imshow(thresh_cv, cmap=\u0026#39;gray\u0026#39;)  threshold 타입 플래그  cv2.THRESH_BINARY : 픽셀값이 경계값을 넘으면 적용값을 지정, 아니면 0 cv2.THRESH_BINARY_INV : 위의 반대 cv2.THRESH_TRUNC : 픽셀값이 경계값을 넘으면 적용값을 지정, 아니면 그대로 cv2.THRESH_TOZERO : 픽셀값이 경계값을 넘으면 원래 값 유지, 아니면 0 cv2.THRESH_TOZERO_INV : 위의 반대    오츠의 알고리즘  대충 그래프상 분포가 peak가 2개가 있다면 그 중간값으로 결정\n  속도가 느림. 노이즈가 많은 영상에는 부적합\n ret, thresh_cv = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU) print(ret) # 전달된 경계값이 무시되고 OTSU 알고리즘에 따라 결정된 경계값이 반환됨 적응형 쓰레스홀딩  이미지를 여러 구역으로 나눠 그 주변 픽셀값만 가지고 계산\n  조명이 일정하지 않거나 배경색이 여럿인 경우에도 앞의 방법들보다 잘나옴\n # cv2.adaptiveThreshold(입력_영상, 적용값, 경계값_결정_방법, 타입_플래그, 블록_사이즈, 계산된_경계값에서_가감할_상수) # 블록 사이즈는 홀수 blk_size = 9 C = 5 th2 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THREST_BINARY, blk_size, C) th3 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THREST_BINARY, blk_size, C)  가우시안 분포를 사용하면 선명함은 떨어지지만 노이즈가 훨씬 적다 ","date":"2020-09-16T00:01:55+09:00","permalink":"https://yansigit.github.io/blog/opencv-thresholding/","title":"OpenCV Thresholding"},{"content":"1. 이진 이미지  한개의 픽셀을 두가지 값으로만 표현 흰색과 검은색으로만 이미지를 표시  2. 그레이스케일 이미지  흔히 말하는 흑백사진 명암으로만 사진을 표현 한개의 픽셀을 0~255 값으로 표현해 명암의 정도를 표현 빛이 하나도 없는 0 상태가 가장 어두운 것  3. 컬러 이미지  RGB, BGR, RGBA 등  img = cv2.imread(\u0026#39;img.png\u0026#39;) bgra= cv2.imread(img.png\u0026#39;, cv2.IMREAD_UNCHANGED) print(img.shape) # (width, height, 3=bgr) print(bgra.shape) # (width, height, 4=bgra) cv2.imshow(\u0026#39;bgr\u0026#39;, img) cv2.imshow(\u0026#39;bgra\u0026#39;, bgra) cv2.imshow(\u0026#39;alpha\u0026#39;, bgra[:,:,3]) # alpha만 출력 cv2.waitKey(0) cv2.destroyAllWindows() 컬러 스페이스 변환 : BGR → 그레이스케일 import cv2 import numpy as np img = cv2.imread(\u0026#39;dog.jpg\u0026#39;) img2 = img.astype(np.uint16) # dtype 변경 b,g,r = cv2.split(img2) # b,g,r = img2[:,:,0], img2[:,:,1], img2[:,:,2] gray1 = ((b+g+r)/3).astype(np.uint8) # 직접 3개의 채널 평균 계산 후 dtype 변경 gray2 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # cv2Color 메소드 이용해 그레이스케일로 변경 gray3 = (0.114*b + 0.587*g + 0.299*r).astype(np.uint8) # 미국 NTSC에서 제시한 그레이스케일 변경식 cv2.imshow(\u0026#39;/3\u0026#39;, gray1) cv2.imshow(\u0026#39;cvtColor\u0026#39;, gray2) cv2.imshow(\u0026#39;NTSC\u0026#39;, gray3) cv2.waitKey(0) cv2.destroyAllWindows() HSV  H 색조 S 채도 V 명도\n  픽셀의 색상이 궁금할 때 앞의값만 비교하면 되므로 효과적\n red_hsv = cv2.cvtColor(red_bgr, cv2.COLOR_BGR2HSV) # 0 255 255 green_hsv = cv2.cvtColor(green_bgr, cv2.COLOR_BGR2HSV) # 60 255 255 blue_hsv = cv2.cvtColor(blue_bgr, cv2.COLOR_BGR2HSV) # 120 255 255 yellow_hsv = cv2.cvtColor(yellow_bgr, cv2.COLOR_BGR2HSV) # 30 255 255 YUV  Y 밝기, U 밝기와 파란색과의 색 차, V 밝기와 빨간색과의 색 차\n  밝기를 제어할 때 Y만 비교하면 되므로 효과적\n (0, 128, 128) # dark (127, 128, 128) # middle (255, 128, 128) # bright ","date":"2020-09-16T00:00:18+09:00","permalink":"https://yansigit.github.io/blog/opencv-%EC%BB%AC%EB%9F%AC-%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4/","title":"OpenCV 컬러 스페이스"},{"content":"ROI  전체 이미지에서 관심있는 부분만 잘라서 연산 (연산량 단축, 알고리즘 단순화)\n  주의: 보통 width, height 순인데 이건 행렬 순이므로 height, width 순서\n import cv2 import numpy as np img = cv2.imread(\u0026#39;image.jpg\u0026#39;) x=320; y=150; w=50; h=50; roi = img[y:y+h, x:x+w] # y ~ y+y-1행, x ~ x+x-1 열 까지 슬라이싱 img2 = roi.copy() img[y:y+h, x+w:x+w+w] = img2 # 바로 옆에다 관심영역 복사 cv2.imshow(\u0026#34;img\u0026#34;, img) cv2.imshow(\u0026#34;roi\u0026#34;, roi) cv2.waitKey(0) cv2.destroyAllWindows() 마우스 드래그로 ROI 지정  선택한 영역의 x,y 좌표와 width, height를 반환.\n  영역을 선택하고 나서 스페이스나 엔터를 누르면 실행\n  C를 누르면 선택 취소. 이때는 width, height 둘다 0 반환\n cv2.selectROI([창_이름,] img [, 크로스바_보이기=True, 마우스시작_중심으로=True]) x,y,w,h = cv2.selectROI(\u0026#39;img\u0026#39;, img, False) if w and h: # 둘 다 0이 아니면 roi = img[y:y+h, x:x+w] cv2.imshow(\u0026#39;cropped\u0026#39;, roi) cv2.imshow(\u0026#39;img\u0026#39;, img) # 이건 딱히 추가안해도 selectROI에서 이미지 보여주는듯 cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2020-09-15T23:58:13+09:00","permalink":"https://yansigit.github.io/blog/opencv-%EC%98%81%EC%97%AD-roi-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0/","title":"openCV 영역 (ROI) 지정하기"},{"content":"Numpy import cv2 import numpy as np img = np.zeros((120,240), dtype=np.uint8) # 120,240 2차원 배열 생성 img[25:35, :] = 255 img[55:65, :] = 115 img[85:95, :] = 160 img[:, 35:45] = 205 img[:, 75:85] = 255 cv2.imshow(\u0026#39;Gray\u0026#39;, img) if cv2.waitKey(0) \u0026amp; 0xFF = 27: cv2.destroyAllWindows() import cv2 import numpy as np img = np.zeros((120,240,3), dtype=np.uint8) # 120,240 2차원 배열 생성, 3채널 컬러 이미지 img[25:35, :] = [255, 0, 0] img[55:65, :] = [0, 255, 0] img[85:95, :] = [0, 0, 160] img[:, 35:45] = [205, 255, 0] img[:, 75:85] = [255, 0, 255] cv2.imshow(\u0026#39;BGR\u0026#39;, img) if cv2.waitKey(0) \u0026amp; 0xFF = 27: cv2.destroyAllWindows() Matplotlib  데이터 시각화 라이브러리 도표 혹은 차트 등 쉽게 그리기 가능  1. 그림 여러개 띄우기  OpenCV에서는 한 화면에 여러 이미지를 띄우는 용도로 많이 사용\n import cv2 import matplotlib.pyplot as plt img = cv2.imread(\u0026#39;dog.jpg\u0026#39;) plt.imshow(img) # cv2는 B,G,R 순서, plt.imshow()는 R,G,B 순서로 데이터를 읽으므로 B,G,R 순서인 cv2 데이터를 그대로 읽으면 색이 이상하게 나옴 plt.title(\u0026#34;1\u0026#34;) plt.yticks([]) # y좌표 눈금 제거 plt.xticks([]) # x좌표 눈금 제거 plt.show() plt.imshow(img[:, :, ::-1]) # 이렇게 순서를 바꿔주면 정상적으로 보인다 plt.title(\u0026#34;2\u0026#34;) plt.yticks([]) # y좌표 눈금 제거 plt.xticks([]) # x좌표 눈금 제거 plt.show() plt.imshow(img[:, :, (2,1,0)]) # 이렇게도 가능 plt.title(\u0026#34;3\u0026#34;) plt.yticks([]) # y좌표 눈금 제거 plt.xticks([]) # x좌표 눈금 제거 plt.show() plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)) # 구글 검색해보니 이렇게해도 되는듯 plt.title(\u0026#34;4\u0026#34;) plt.yticks([]) # y좌표 눈금 제거 plt.xticks([]) # x좌표 눈금 제거 plt.show() 2. 그래프 그리기  image \nimport matplotlib.pyplot as plt import numpy as np x = np.arange(10) # 0 ~ 9 y = x ** 2 # 0, 1, 4, 9, 16, 25, 36 ... plt.plot(x,y) plt.show() 그래프 옵션들 # 조합 가능 plt.plot(x, \u0026#39;r--\u0026#39;) # red, -- (이음선) plt.plot(x, \u0026#39;g.\u0026#39;) # green, ● plt.plot(y, \u0026#39;bv\u0026#39;) # blue, ▼ plt.plot(y, \u0026#39;ks\u0026#39;) # blacK, square ■ SubPlot 구획을 나눠 한 화면에 보여줌\nplt.subplot(2,2,1) # 2행 2열 중 1번째 plt.plot(x, \u0026#39;r--\u0026#39;) # red, -- (이음선) plt.subplot(2,2,1) # 2행 2열 중 2번째 plt.plot(x, \u0026#39;g.\u0026#39;) # green, ● plt.subplot(223) # 2행 2열 중 3번째 plt.plot(y, \u0026#39;bv\u0026#39;) # blue, ▼ plt.subplot(224) 2행 2열 중 4번째 plt.plot(y, \u0026#39;ks\u0026#39;) # blacK, square ■ ","date":"2020-09-15T23:50:14+09:00","permalink":"https://yansigit.github.io/blog/numpy-and-matplotlib/","title":"Numpy and Matplotlib"},{"content":"1. 키보드 이벤트 key = cv2.waitKey(0) \u0026amp; OxFF # 8비트 마스킹. 몇몇 64비트 환경에서는 32비트를 반환하기 때문에 ord() 값으로 비교하면 다르게 나올 수 있음. if key == ord(\u0026#39;a\u0026#39;): # 키보드 입력이 a 이면 print(\u0026#39;a 입력됨\u0026#39;) 2. 마우스 이벤트  마우스 입력을 받으려면 이벤트를 처리할 함수를 미리 선언해놓고 cv2.setMouseCallBack() 함수에 함수 전달  def onMouse(event, x, y, flags, param): # 함수 정의 pass # win_name = 이벤트를 등록할 윈도우 이름 # onMouse = 이벤트 처리를 위해 미리 선언해놓은 콜백 함수 # param = 필요에 따라 onMouse에 전달할 인자 cv2.setMouseCallBack(win_name, onMouse [, param])   콜백 함수에서 받아야 할 파라미터들은 다음과 같다\n event : 마우스 이벤트 종류. cv2.EVENT_로 시작하는 상수  cv2.EVENT_MOUSEOVER cv2.EVENT_(L,R,M)BUTTON(DOWN,UP,BLCLK)  BLCLK : 더블클릭   cv2.EVENT_MOUSEWHEEL cv2.EVENT_MOUSEHWHEEL  휠 가로 스크롤     x, y : 마우스 좌표 flags : 마우스 동작과 함께 일어난 상태, cv2.EVENT_FLAG_ 로 시작하는 상수  cv2.EVENT_FLAG_LBUTTON (1) cv2.EVENT_FLAG_RBUTTON (2) cv2.EVENT_FLAG_MBUTTON (4) cv2.EVENT_FLAG_CTRLKEY (8) cv2.EVENT_FLAG_SHIFTKEY (16) cv2.EVENT_FLAG_ALTKEY (32)      flags 처리에서는 상수들이 2비트 자릿수에 맞는 값을 가짐\n 따라서 \u0026amp; (AND) 연산을 이용해 각각의 비트 자릿수를 보고 해당 키가 눌려져있는지 상태 비교 가능  if flags \u0026amp; cv2.EVENT_FLAG_LBUTTON: # 마우스 왼쪽 버튼이 눌렸는지 pass   3. 트랙바 def onChange(value): v = cv2.getTrackbarPos(\u0026#39;trackbar\u0026#39;, \u0026#39;win_name\u0026#39;) # 이렇게 직접 트랙바의 밸류 얻을수도 있음 # cv2.createTrackbar(트랙바이름, 윈도우이름, 시작포인트, 끝포인트, 할당할_함수) cv2.createTrackbar(\u0026#39;trackbar\u0026#39;, \u0026#39;win_name\u0026#39;, 0, 100, onChange) ","date":"2020-09-15T23:46:10+09:00","permalink":"https://yansigit.github.io/blog/dealing-with-events-on-opencv/","title":"Dealing With Events on Opencv"},{"content":"openCV에서 창 관리\n1. 이름을 갖는 창 열기 # title = 창 이름 # option = 창의 옵션 # cv2.WINDOW_NORMAL: 임의의 크기. 창 크기 조정 가능 # cv2.WINDOW_AUTOSIE: 이미지와 같은 크기. 창 크기 조정 불가능 cv2.namedWindow(title [, option]) 2. 창 위치 이동 # title = 위치를 변경할 창 이름 cv2.moveWindow(title, x, y) 3. 창 크기 변경 cv2.resizeWindow(title, width, height) 4. 창 닫기 cv2.destroyWindow(title) 5. 모든 창 닫기 cv2.destroyAllWindows() ","date":"2020-09-15T23:45:14+09:00","permalink":"https://yansigit.github.io/blog/managing-windows-on-opencv/","title":"Managing Windows on Opencv"},{"content":"1. 직선 그리기 img = cv2.imread(\u0026#39;blank_500.jpg\u0026#39;) # start와 end 점을 연결하여 직선을 그림 # img = 이미지를 그릴 이미지 # start = 시작 좌표 ex; (0,0) # end = 종료 좌표 ex; (500,500) # color = BGR 형태의 color ex; (255, 0, 0) # thickness (int) = 선의 두께, pixel # lineType = 선 그리기 형식. 픽셀 계단 현상 완화 등.. ex; cv2.LINE_AA (안티앨리어싱), cv2.LINE_4 (브레젠햄 4연결) cv2.line(img, start, end, color[, thickness, lineType]) 2. 사각형 그리기 # thickness가 -1이면 채우기 cv2.rectangle(img, start, end, color[, thickness, lineType]) 3. 다각형 그리기  여기서는 좌표를 numPy 형식으로 지정한다.  points = np.array([[50,50], [150,150], [100,140], [200,240]], dtype=np.int32) # isCloused(Bool) = 닫힌 도형 여부 # thickness = 여기서는 -1로 채우기 작동 안됨 cv2.polylines(img, points, isClosed, color[, thickness, lineType]) 4. 원, 타원 # center = 원점 좌표 ex; (50,50) # radius = 원점 반지름 (int) cv2.circle(img, center, radius, color [, thickness, lineType]) # axes = 기준 축 길이 (50, 75) # angle = 기준 축 회전 각도 (int) # from,, to = 호를 그릴 시작 각도와 끝 cv2.ellipse(img, center, axes, angle, from, to, color [, thickness, lineType]) 5. 이미지에 Text 추가 # text(str) = 표시할 문자열 # point = 문자열이 표시될 위치. 문자열의 좌측 아래가 기준 ex; (50,30) # font = 폰트 글꼴. ex; CV2.FONT_XXX # fontScale = 폰트 사이즈 스케일 cv2.putText(img, text, point, fontFace, fontScale, color [, thickness, lineType])  fontFace  FONT_HERSHEY_COMPLEX : 상대적으로 복잡한 모양 FONT_HERSHEY_SIMPLEX : 단순한 모양   ","date":"2020-09-15T23:44:12+09:00","permalink":"https://yansigit.github.io/blog/drawing-things-on-opencv/","title":"Drawing Things on Opencv"},{"content":"1. 이미지 읽어 표시하기 import cv2 # fileName(string) = 경로 # flag(int) 이미지 파일을 읽을 때 옵션 # cv2.IMREAD_COLOR : 1 # cv2.IMREAD_GRAYSCALE : 0 # cv2.IMREAD_UNCHANGED : -1. 이미지 파일을 alpha channel까지 포함 해 읽음 # Returns = 이미지 객체 행렬 (Numpy 행렬) # img 값은 numpy의 ndarray type이다. img = cv2.imread(fileName, flag) if img is not None: # title(str) = 윈도우 창의 타이틀 cv2.imshow(title, img) # Return = 입력한 키. -1이면 대기시간 동안 입력 없음 # delay = 입력한 정수 동안 대기. 0 이거나 없으면 무한대기 key = cv2.waitKey([delay]) cv2.destroyAllWindows() else: print(\u0026#39;No image file.\u0026#39;) 2. 이미지 저장 cv2.imread(\u0026#39;image.jpg\u0026#39;, cv2.IMREAD_GRAYSCALE) # 확장자를 다르게하면 다른 포맷으로 저장 가능 cv2.imwrite(\u0026#39;image_gray.jpg\u0026#39;, img) 3. 동영상 파일 프레임 재생 import cv2 cap = cv2.VideoCapture(\u0026#39;video.avi\u0026#39;) # 동영상 캡쳐 객체 생성 if cap.isOpened(): # 캡쳐 객체 초기화 확인 while: True: ret, img = cap.read() # 다음 프레임 읽기 if ret: # 프레임을 읽었으면 cv2.imshow(\u0026#39;동영상 재생\u0026#39;, img) # 프레임 보이기 cv2.waitKey(25) # 지연시간 25ms 설정 else: break else: print(\u0026#39;동영상을 열 수 없습니다\u0026#39;) cap.release() # 자원 반납 cv2.destroyAllWindows() 동영상의 속성을 이용해 재생 import cv2 cap = cv2.VideoCapture(\u0026#39;video.avi\u0026#39;) # 동영상 캡쳐 객체 생성 if cap.isOpened(): # 캡쳐 객체 초기화 확인 fps = cap.get(cv2.CAP_PROP_FPS) # 프레임 수 구하기 delay = int(1000/fps) # 딜레이 구하기 print(\u0026#34;FPS: %f, Delay: %dms\u0026#34; %(fps, delay)) while: True: ret, img = cap.read() # 다음 프레임 읽기 if ret: # 프레임을 읽었으면 cv2.imshow(\u0026#39;동영상 재생\u0026#39;, img) # 프레임 보이기 cv2.waitKey(delay) # 지연시간 25ms 설정 else: break else: print(\u0026#39;동영상을 열 수 없습니다\u0026#39;) cap.release() # 자원 반납 cv2.destroyAllWindows() ","date":"2020-09-15T23:38:41+09:00","permalink":"https://yansigit.github.io/blog/reading-and-writing-media-on-opencv/","title":"Reading and Writing Media on Opencv"},{"content":"Telnet으로 포트 열기 https://developer.android.com/studio/run/emulator-networking?hl=ko\ntelnet localhost 5554 # putty에서는 raw로 연결 add \u0026lt;protocol\u0026gt;:\u0026lt;host-port\u0026gt;:\u0026lt;guest-port\u0026gt; ADB로 포트 열기 (이 방법 추천) https://developer.android.com/studio/command-line/adb?hl=ko#forwardports\nadb forward tcp:6100 tcp:7100 ","date":"2020-09-15T23:31:39+09:00","permalink":"https://yansigit.github.io/blog/port-forwarding-on-android-emulator/","title":"Port Forwarding on Android Emulator"},{"content":"맥의 경우 # .bash_profile 혹은 .zshrc 파일에 아래 내용 작성 export ANDROID_HOME=$HOME/Library/Android/sdk export ANDROID_SDK_ROOT=$ANDROID_HOME export PATH=$PATH:$ANDROID_HOME/emulator export PATH=$PATH:$ANDROID_HOME/tools export PATH=$PATH:$ANDROID_HOME/tools/bin export PATH=$PATH:$ANDROID_HOME/platform-tools ","date":"2020-09-15T23:29:35+09:00","permalink":"https://yansigit.github.io/blog/setting-react-native-environment-variable/","title":"Setting React Native Environment Variable"},{"content":"컴포넌트 기본 구조 App.js\nimport React, { Component } from \u0026#39;react\u0026#39;; // Hello Component (View) // 이제 해당 컴포넌트는 JSX 내부에 \u0026lt;Hello /\u0026gt; 식으로 사용 가능 class Hello extends Component { render() { return ( \u0026lt;h1\u0026gt;hello, {this.props.name}\u0026lt;/h1\u0026gt; ); } } export default Hello; index.js\nimport React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; import App from \u0026#39;./App\u0026#39;; // App.js  // React.StrictMode -\u0026gt; UI 렌더 시 에러 일어나면 에러 띄워준다고 함. ReactDOM.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;App name=\u0026#34;yoon\u0026#34; /\u0026gt; \u0026lt;/React.StrictMode\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) ); index.html\n\u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Props vs State Props  사용자 입장에서 컨포넌트를 조작할 수 있는 기능 아이폰의 버튼, UI 즉 태그에다 Prop을 사용해 사용환경 조작 컴포넌트 밖에서 Props를 조작해야 함  컴포넌트 내부에서 Props를 조작하는 것은 금지되어 있음 (에러 발생)    State  개발자 입장에서 컨포넌트를 조작하는 기능 아이폰의 부품  Constructor \u0026amp; State class comp extends Component { constructor(props) { super(props); this.state = { subject:{title:\u0026#39;jemok\u0026#39;,sub:\u0026#39;buje\u0026#39;}, thumbs: [{name:\u0026#39;flower.jpg\u0026#39;, width:\u0026#39;150px\u0026#39;}, {name=\u0026#39;guitar.jpg\u0026#39;, width=\u0026#39;100px\u0026#39;}] }; } render() { return( \u0026lt;Subject title={this.state.subject.title} /\u0026gt; \u0026lt;Thumb resource={this.state.thumbs} /\u0026gt; // 내부적으로 리스트를 이용해 순차적으로 출력  ); } }  Component  컴포넌트가 실행될 때 먼저 실행되는 부분    State 에 값 추가하기 class test extends Component { constructor(props) { this.state = { Jade : {grade:\u0026#39;A\u0026#39;, country=\u0026#39;USA\u0026#39;}, Holmes : {grade:\u0026#39;S\u0026#39;, country=\u0026#39;England\u0026#39;}, SomeExp : { Sci : { teacher:\u0026#39;Matt\u0026#39;, rate:\u0026#39;A+\u0026#39; }, Korean : { teacher:\u0026#39;Kim\u0026#39;, rate:\u0026#39;B+\u0026#39; } } }; render() { return( \u0026lt;button onClick={ function() { var _new = this.state.SomeExp.concat({History : { teacher:\u0026#39;Tom\u0026#39;, rate:\u0026#39;A\u0026#39; }); this.setState({ SomeExp : _new }); }.bind(this) }\u0026gt;\u0026lt;/button\u0026gt; ) } } Event  React에서는 Props나 State가 변경되면 render()가 자동으로 호출되어 다시 그림  단 setProp, setState을 이용하여 변경했을 때   태그에 onClick (HTML과 다르게 대문자를 꼭 지켜서 적어줘야한다) 를 적어서 실행시킬 함수를 호출  익명함수 function() {} 사용 가능   해당 함수에 인자 e (event)를 주어 이벤트를 쉽게 핸들링 가능  e.preventDefault() 함수를 이용하면, 이벤트가 가지고 있는 기본적인 동작을 방지 가능 즉 페이지 리로드 등 해당 함수 내에서 this (component)를 사용하고 싶다면  function(e){}.bind(this) 를 이용하여 this 값을 포함시킬 수 있다     함수도 Prop를 통하여 전달이 가능하다.  // App.js \u0026lt;Subject onPageChanged={ function() { alert(\u0026#39;hello\u0026#39;) }.bind(this) } // Subject.js .. \u0026lt;a href=\u0026#34;/\u0026#34; onClick={ function(e) { e.preventDefault(); this.props.onPageChanged(); }\u0026gt;테스트\u0026lt;/a\u0026gt; .. Form  onSubmit  폼을 Submit할 때 내부의 함수를 자동으로 실행   폼의 elements 들의 value 값을 얻는 방법  onSubmit를 통해 function(e)를 실행할 때  e.target 은 폼 그 자체가 됨 e.target.element_name을 통해 해당 폼의 엘리먼트를 가져올 수 있음      shouldComponentUpdate() class Test extends Component { shouldComponentUpdate(newProps, newState) { return false; // 부모 컴포넌트의 State가 바뀌더라도 render() 호출 안하게  } render() { return(...); } }  기본적으로 부모 함수가 render() 되면 자식 컴포넌트도 함께 render() 된다.  즉 성능 낭비가 일어날 여지가 있다   해당 함수를 사용하고 return false; 를 해주면  부모 컴포넌트의 State가 바뀌더라도 render() 호출하여 다시 그려주지 않음    Immutable Javascript나 Python에서는 변수를 다른 변수에 재할당할 때 같은 메모리 주소를 가르키는 경우가 많다.\n즉 재할당 할 시 참조만 하게 한다는 소리다.\n따라서 얕은 복사, 깊은 복사 등을 써서 아예 다른 메모리 주소에 복사해줘야 한다.\n관련한 방법은 이곳을 참고\n얕은 복사 (Shallow Copy) 가장 상위에 위치한 객체들만 복사하고 내부 객체들은 참조만 함\n깊은 복사 (Deep Copy) 모든 객체들을 복사 (새로 생성)\n","date":"2020-09-15T23:24:53+09:00","permalink":"https://yansigit.github.io/blog/react-native-simple-notes/","title":"React Native Simple Notes"},{"content":"iOS 향 빌드 시 체크사항  Xcode - 속성 - 컴포넌트에 iOS 시뮬레이터 깔려있는지 확인 (가상머신 이용 시) Location 에서 Command Line Tools가 제대로 지정되어 있는지 확인  없을 시 Command Line Tools 설치 후 설정    Android 5554 Offline 문제 안드로이드 가상머신 실행을 Hot reload 말고 Cold booting을 한다 (공장 초기값으로 실행)\nAndroid 빌드 시 gradle 오류가 날 경우  android 폴더의 gradlew 실행파일에 실행 권한이 있는지 확인해보자  iOS 빌드 시 오류 날 경우  ios 폴더에서 pod install 한번 실행해주자 아니면 ios 폴더에서 rm -rf build/ 를 실행시켜 줘보자  Android에서 아이콘 제대로 표시 안될 때  https://github.com/oblador/react-native-vector-icons#android /android/app/build.gradle 맨 끝에 apply from: \u0026quot;../../node_modules/react-native-vector-icons/fonts.gradle\u0026quot; 추가  React-native-image-picker 사용 시 카메라 안될 때  Couldn't get file path for photo이런 오류를 일으키며 카메라가 안켜진다 그럴때는 android:requestLegacyExternalStorage=\u0026quot;true\u0026quot; 위 태그를 AndroidManifest.xml의 Applicaiton 태그에 속성으로 삽입 API 28 부터인가 사용 가능한 태그라고 해도 무시하고 그냥 삽입  attempt to invoke virtual method android.graphics.drawable.drawable react native  react-natvie start —reset-cache로 캐시 정리 안드로이드 앱 삭제 후 react-natve run-android ","date":"2020-09-15T22:56:51+09:00","permalink":"https://yansigit.github.io/blog/react-native-quick-error-fixes/","title":"React Native Quick Error Fixes"},{"content":"1. 개요 맥을 사자니 돈이 너무 없고, 해킨토시를 하자니 노트북이라 깔고 설정하기 귀찮다면\n답은 바로 가상머신\n2. VMDK 다운받기 먼저 vmdk 가상 하드파일을 다운받는다. 구글에 검색하면 많이 나온다. 눈치껏 제일 안전할 것 같은 사이트를 고르자.\n대략 8GB 정도이며 구글드라이브 주소가 제공된 경우 대역폭 초과로 다운로드가 안될 확률이 많으니 토렌트를 이용하는게 좋다.\n속도도 빨라50MB/S 정도 나온다.\n3. 버추얼박스 Extension Pack 설치 버추얼박스는 이미 설치되어 있을테니 Extension Pack만 받아 설치하자\n버추얼박스 다운로드 페이지에 있다.\n4. 가상머신 생성 이제 가상머신을 만들 차례다.\n메모리는 넉넉잡아 8GB 정도 잡아주고, 디스크는 다운 받아놓은 .vmdk 디스크를 임포트 해주자.\n이제 다 끝났으면 좋겠지만.. 아직 설정할게 남았다.\n5. 가상머신 설정 가상머신 설정 창으로 들어간다.\n 시스템 - 마더보드 - 칩셋 부분을 PIIX3으로 시스템 - 마더보드 - 프로세서 에서 프로세서 개수를 실제 프로세스 개수의 반 (최소 4개) 디스플레이 - 비디오메모리  부분을 128MB USB - USB 컨트롤러 사용하기 부분을 USB 3.0 컨트롤러로 설정  그 다음 cmd창을 켜고\ncd \u0026#34;C:\\Program Files\\Oracle\\VirtualBox\\\u0026#34; VBoxManage modifyvm \u0026#34;\u0026lt;가상머신이름\u0026gt;\u0026#34; --cpuidset 00000001 000106e5 00100800 0098e3fd bfebfbff VBoxManage setextradata \u0026#34;\u0026lt;가상머신이름\u0026gt;\u0026#34; \u0026#34;VBoxInternal/Devices/efi/0/Config/DmiSystemProduct\u0026#34; \u0026#34;iMac11,3\u0026#34; VBoxManage setextradata \u0026#34;\u0026lt;가상머신이름\u0026gt;\u0026#34; \u0026#34;VBoxInternal/Devices/efi/0/Config/DmiSystemVersion\u0026#34; \u0026#34;1.0\u0026#34; VBoxManage setextradata \u0026#34;\u0026lt;가상머신이름\u0026gt;\u0026#34; \u0026#34;VBoxInternal/Devices/efi/0/Config/DmiBoardProduct\u0026#34; \u0026#34;Iloveapple\u0026#34; VBoxManage setextradata \u0026#34;\u0026lt;가상머신이름\u0026gt;\u0026#34; \u0026#34;VBoxInternal/Devices/smc/0/Config/DeviceKey\u0026#34; \u0026#34;ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc\u0026#34; VBoxManage setextradata \u0026#34;\u0026lt;가상머신이름\u0026gt;\u0026#34; \u0026#34;VBoxInternal/Devices/smc/0/Config/GetKeyFromRealSMC\u0026#34; 1 위 명령어를 쭉쭉 쳐준다.\nourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc 부분이 참으로 인상깊다.. 미안해요 애플!\n6. 가상머신 실행 다음 가상머신을 실행하면 해킨토시 깔 때 봤던 커널 로그들이 조르륵 뜨기 시작한다.\n괜시리 또 마음이 쫄린다. 무한부팅 걸리거나 커널 패닉이 일어나면 지금까지 했던게 말짱 도루묵이다.\n부팅이 되기를 간절히 기도하며 기다리다 보면.. 안된다..\n 2020/09/15 추가 아무래도 Hyper-V 떄문에 안되었던 모양인데, 지금은 아예 해킨토시로 사용하고 있기 때문에 테스트는 해보지 않았다.\n해킨토시 설치 과정과 Intel 무선랜 칩에서 Broadcom 무선랜카드로 변경한 과정은 나중에 포스팅하겠다.\n","date":"2020-02-20T23:33:21+09:00","permalink":"https://yansigit.github.io/blog/installing-mac-os-on-virtualbox-on-windows/","title":"Installing Mac OS on Virtualbox on Windows"},{"content":"쉬운 설정법 버추얼박스 6.0 버전부터 Hyper-V를 켠 상태로도 이용할 수 있게 되었다.\ncd \u0026quot;C:\\Program Files\\Oracle\\VirtualBox\\\u0026quot; vboxmanage setextradata \u0026quot;\u0026lt;가상머신이름\u0026gt;\u0026quot; \u0026quot;VBoxInternal/NEM/UseRing0Runloop\u0026quot; 0 cmd를 켜고 위와 같이 해주면 끝\n","date":"2020-02-20T00:00:00Z","permalink":"https://yansigit.github.io/blog/virtualbox-with-dockerhyper-v/","title":"Virtualbox With Docker(hyper V)"},{"content":"HTTP/2 나온지 얼마나 됬다고\u0026hellip;\nhttps://evan-moon.github.io/2019/10/08/what-is-http3/\n image \n요약: TCP 대신 UDP 기반의 QUIC 프로토콜을 이용해 통신하는 것으로 변경\n","date":"2020-02-16T17:01:05+09:00","permalink":"https://yansigit.github.io/blog/about-http/3/","title":"About Http/3"},{"content":"Scan var test [5]int for i:=0; i\u0026lt;5; i++ { fmt.Scan(\u0026amp;test[i]) } fmt.Print(test) // 입력 1 4 5 2 3 // 출력 [1,4,5,2,3]  사족 간단한 건데 난 처음에 For문으로 돌아가며 Scan으로 입력 받으면 하나하나 입력을 따로 넣어줘야 한다고 생각했었는데\n그냥 입력을 한꺼번에 그냥 공백으로 나눠줘도 알맞게 들어가는 듯 하다.\n덕분에 쉬운 백준 코딩 문제를 몇번이나 틀렸다.. ㅠㅠ\n Sort import ( \u0026#34;sort\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { str := []string{\u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} sort.Strings(str) fmt.Println(\u0026#34;Strings: \u0026#34;, str) // 출력: a b c  ints := []int{70, 2, 4} sort.Ints(ints) fmt.Println(\u0026#34;Ints: \u0026#34;, ints) // 출력: 2 4 70  s := sort.IntsAreSorted(ints) fmt.Println(\u0026#34;Sorted: \u0026#34;, s) // 출력: true  mySlice := make([]myDataType, 0) mySlice = append(mySlice, myDataType{\u0026#34;김형준\u0026#34;, 42}) mySlice = append(mySlice, myDataType{\u0026#34;홍길동\u0026#34;, 28}) mySlice = append(mySlice, myDataType{\u0026#34;임꺽정\u0026#34;, 38}) sort.Slice(mySlice, func(i, j int) bool { return mySlice[i].age \u0026lt; mySlice[j].age }) fmt.Println(mySlice) // 출력: [{홍길동 28} {임꺽정 38} {김형준 42}] } 입력 값 읽기 fmt.scanln() 는 공백 EOF으로 판단하고 자꾸 자르는 경향이 있어 불편했다.\nscanner := bufio.NewScanner(os.Stdin) scanner.Scan() // 한번만 읽기 for scanner.Scan() { line := scanner.Text() fmt.Println(line) } // 계속 읽기 이렇게 스캐너로 읽어 들이거나\nr := bufio.NewReader(os.Stdin) str, err := r.ReadString(\u0026#39;\\n\u0026#39;) 버퍼 리더를 이용해 읽어 들어야 정상적으로 스페이스를 포함해 들어간다\nScanner 버퍼 용량 늘리기 스캐너 버퍼의 기본 크기는 65536 바이트이다.\n만약 입력값이 커 이 크기를 더 늘리고 싶다면\nscanner := bufio.NewScanner(os.Stdin) buff := make([]byte, 1200000) scanner.Buffer(buff, 1200000) 이렇게 버퍼 크기를 재 설정 해주면 된다.\nTry - Catch 구현하기 고 언어에서는 Try - Catch 구문이 지원되지 않는다.\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;result:\u0026#34;, divide(1, 0)) fmt.Println(\u0026#34;Today is good day.\u0026#34;) } func divide(a, b int) int { defer func() { if err := recover(); err != nil { fmt.Println(err) } }() return a / b } 대신 이렇게 defer 함수를 통해 (종료 시 반드시 호출이 보장된다) recover() 함수를 호출해 복구시킨다.\nrecover() 함수는 응용프로그램이 패닉 상태라면 에러값을 얻고 정상 상태로 복구해준다.\n","date":"2020-02-10T14:27:41+09:00","permalink":"https://yansigit.github.io/blog/golang-cheet-sheets-for-algo-test/","title":"Golang Cheet Sheets for Algo Test"},{"content":"mgm init _ = mgm.SetDefaultConfig(nil, \u0026#34;Wiki_DB\u0026#34;, options.Client().ApplyURI(\u0026#34;mongodb://localhost:27017\u0026#34;)) creating a single index name, err := mgm.Coll(\u0026amp;Doc{}).Indexes().CreateOne(context.TODO(), mongo.IndexModel{ Keys: bson.M{\u0026#34;title\u0026#34;: 1}, Options: options.Index().SetUnique(true), }) if err != nil { panic(err) } fmt.Println(name) // 성공 시 생성된 index name 반환 ","date":"2020-02-09T00:57:11+09:00","permalink":"https://yansigit.github.io/blog/mongodb-cheat-sheet-for-golang/","title":"Mongodb Cheat Sheet for Golang"},{"content":"고 언어에서 nil 과 null\nNull ==\u0026gt; Nil 고 언어에서는 null 대신 nil을 사용한다.\n다만 기억할 것은 고 언어에서 nil 값을 리턴해주는 것은 금지다.\npackage main import \u0026#34;fmt\u0026#34; func main() { someRandom := getString() fmt.Println(someRandom) } func getString() string { return nil // This WON\u0026#39;T compile } 다만 포인터, 즉 주소값이 nil 인것은 기능하다\npackage main import \u0026#34;fmt\u0026#34; type SomeStruct struct { name string } func main() { s := getSomeStruct() fmt.Println(s.name) // It will crash here } func getSomeStruct() *SomeStruct { return nil // This WILL compile } 출저: newfivefour.com\n","date":"2020-02-08T21:08:49+09:00","permalink":"https://yansigit.github.io/blog/understanding-nil-and-null-in-golang/","title":"Understanding Nil and Null in Golang"},{"content":"ODM for MongoDB MongoDB에도 ORM과 비슷한 ODM 프레임웍이 있는데 바로 MGM 이라는 프로젝트. 저번달에 따끈따끈하게 나온 프로젝트인거 같다.\n사실 MongoDB 같은 경우에는 SQL 기반이 아니라 JSON 혹은 BSON 기반이라 ODM을 쓸것까지는 없을 것 같지만, 아직 MongoDB에 익숙하지 않기도 하고 짜여진 구조체를 기반으로 편리하게 데이터베이스와 소통할 수 있다는 장점과 빠른 개발이 가능할것이라는 생각에 한번 사용해보기로 했다.\nimport ( \u0026#34;github.com/Kamva/mgm\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo/options\u0026#34; ) func init() { // Setup mgm default config  err := mgm.SetDefaultConfig(nil, \u0026#34;mgm_lab\u0026#34;, options.Client().ApplyURI(\u0026#34;mongodb://root:12345@localhost:27017\u0026#34;)) } 공식 MongoDB 드라이버 기반이라 이렇게 옵션 부분을 같이 Import 해줘야 한다.\n사용하는 방법도 간편하다. 이렇게 mgm.SetDefaultConfig을 이용해 데이터베이스와 연결시켜 준 다음 mgm 객체를 통해 편리하게 문서를 쓰고 지우면 된다.\n","date":"2020-02-07T22:40:26+09:00","permalink":"https://yansigit.github.io/blog/using-mongodb-in-golang/","title":"Using Mongodb in Golang"},{"content":"Mongo DB 관리 클라이언트, MongoDB Compass\nMongoDB Compass MongoDB를 위한 관리 툴은 여러 종류가 있는데, scoop에는 compass 하나밖에 없는 듯 하여 해당 소프트웨어를 사용하는 것으로 결정했다.\n설치는 다음 명령어를 통해 가능하다.\nscoop install mongodb-compass-community 다음 접속 스키마를 통해 클라이언트에서 MongoDB 서버로 연결하는데\nMongoDB가 로컬에 기본포트인 27013에서 연결되어 있다면 따로 뭐 적을 필요 없이 버튼 클릭하면 자동으로 접속된다.\n혹은 직접\nmongodb://localhost:27017/ 이런 식으로 적어주고 버튼을 눌러줘도 된다\n","date":"2020-02-07T22:40:13+09:00","permalink":"https://yansigit.github.io/blog/client-software-for-mongo-db-mongodb-compass/","title":"Client Software for Mongo Db Mongodb Compass"},{"content":"Time format in Go Language 보통 프로그래밍 언어에서 시간과 날짜를 다룰 때 레이아웃은 YYYY-MM-DD HH:MM:SS와 같이 영문자를 이용한 방식이다.\n고 언어에서는 타 언어와 다르게 숫자로 포맷을 지정해줘야 한다.\n2006-01-02 15:04:05 언뜻 보기에 보통의 날짜와 시간을 나타내는 문자열로 보일 수 있는데 사실 date 명령어를 쓸 때 출력 되는 결과의 순서라고 한다.\n$ date Mon Jan 2 15:04:05 -0700 MST 2006 0 1 2 3 4 5 6 해당 레이아웃 법칙을 이용해 직접 포맷을 지정해 줄 수 있고, 혹은 통상적으로 사용되는 포맷일 경우 미리 정해둔 상수를 통해서 정해 줄 수도 있다.\nconst ( ANSIC = \u0026#34;Mon Jan _2 15:04:05 2006\u0026#34; UnixDate = \u0026#34;Mon Jan _2 15:04:05 MST 2006\u0026#34; RubyDate = \u0026#34;Mon Jan 02 15:04:05 -0700 2006\u0026#34; RFC822 = \u0026#34;02 Jan 06 15:04 MST\u0026#34; RFC822Z = \u0026#34;02 Jan 06 15:04 -0700\u0026#34; // RFC822 with numeric zone  RFC850 = \u0026#34;Monday, 02-Jan-06 15:04:05 MST\u0026#34; RFC1123 = \u0026#34;Mon, 02 Jan 2006 15:04:05 MST\u0026#34; RFC1123Z = \u0026#34;Mon, 02 Jan 2006 15:04:05 -0700\u0026#34; // RFC1123 with numeric zone  RFC3339 = \u0026#34;2006-01-02T15:04:05Z07:00\u0026#34; RFC3339Nano = \u0026#34;2006-01-02T15:04:05.999999999Z07:00\u0026#34; Kitchen = \u0026#34;3:04PM\u0026#34; // Handy time stamps.  Stamp = \u0026#34;Jan _2 15:04:05\u0026#34; StampMilli = \u0026#34;Jan _2 15:04:05.000\u0026#34; StampMicro = \u0026#34;Jan _2 15:04:05.000000\u0026#34; StampNano = \u0026#34;Jan _2 15:04:05.000000000\u0026#34; ) ","date":"2020-02-06T23:30:05+09:00","permalink":"https://yansigit.github.io/blog/time-format-in-golang/","title":"Time Format in Golang"},{"content":"Markdown Editor 지금까지 블로그 글을 쓸 때, 나는 Webstorm의 마크다운 플러그인을 이용해 IDE에서 직접 써왔다.\n마크다운 전용 에디터가 존재하는 것은 알고 있었지만 깔기도 귀찮았을 뿐더러 사용에 지장도 딱히 없다고 느꼈기 때문이다.\n그러나 오랫동안 사용해보니 여러가지 기능이라던가 이미지 삽입, 글을 쓸때의 가독성이 아쉬워져 마크다운 전용 에디터의 필요성을 느끼게 되었다.\n내가 선택한 에디터는 Typora.\n image \n이래저래 심플한게 마음에 들기도 하고, 무엇보다 라이브 화면에서 직접 글을 쓸 수 있다는게 마음에 들었다.\nInstall 설치는 다음과 같이 내가 애용하는 scoop을 이용해 간편하게 설치했다.\nscoop install typora 아직 마크다운 문법에 익숙하지 않은 나에게 맞춤형이라고 불릴 수도 있을만큼 아주 편리하고 강력하다.\nSummery 현재 베타버전이라 무료로 배포되고 있는데, 나중에 상용 프로그램으로 바뀌어도 구입해 사용할 것 같다.\n다만 아쉬운 점이 있다면, 이미지를 삽입할 때 상대경로로 삽입하는 게 어렵다. 상대 경로로 잡으면 Typora 설치 폴더를 기준으로 잡아버린다.\n","date":"2020-01-27T22:09:09+09:00","permalink":"https://yansigit.github.io/blog/markdown-editor-typora/","title":"Markdown Editor Typora"},{"content":"Hot Reloading 웹 어플리케이션을 개발할 때 항상 유용하게 사용하는 기능이 Hot-Reloading 기능이다.\n템플릿이나 기능을 약간 바꾸고 확인하고 싶을 때, 코드를 변경하고 일일히 빌드를 새로 해주기란 여간 귀찮은 일이 아니기 때문이다.\n닷넷 코어나 노드JS 기반 프레임워크들에서 작업했을 때는 항상 기본적으로 포함된 기능들이라 신경쓰지 않고 개발할 수 있었는데 고 언어에서 작업하려다 보니 여간 그리운게 아니라 관련 패키지가 있는지 검색했더니.. 역시나 개발자들 마음은 한가지인가 보다.\nAIR 깃허브 페이지\n사용법은 다음과 같다.\ngo get -u github.com/cosmtrek/air 먼저 go get 으로 해당 모듈을 다운받아 준다.\n해당 모듈에는 air.exe 파일이 포함되어 있으며 받자마자 바로 실행 가능하다.\n다음 프로젝트 루트 폴더로 들어가 air.conf 파일을 생성해준다. 혹은 air 모듈의 디렉토리 내부에 있는 air_example.conf 파일을 복사해 이름을 변경해주어도 된다.\n해당파일은 리눅스용이므로 적절히 윈도우에서 사용 가능하도록 변경해주었다.\n# Config file for [Air](https://github.com/cosmtrek/air) in TOML format # Working directory # . or absolute path, please note that the directories following must be under root. root = \u0026#34;.\u0026#34; tmp_dir = \u0026#34;tmp\u0026#34; [build] # Just plain old shell command. You could use `make` as well. cmd = \u0026#34;go build -o ./tmp/main.exe .\u0026#34; # Binary file yields from `cmd`. bin = \u0026#34;tmp/main.exe\u0026#34; # Customize binary. full_bin = \u0026#34;set APP_ENV=dev\u0026amp; set APP_USER=air\u0026amp; tmp\\\\main.exe\u0026#34; # Watch these filename extensions. include_ext = [\u0026#34;go\u0026#34;, \u0026#34;pug\u0026#34;, \u0026#34;html\u0026#34;] # Ignore these filename extensions or directories. exclude_dir = [\u0026#34;assets\u0026#34;, \u0026#34;tmp\u0026#34;, \u0026#34;vendor\u0026#34;, \u0026#34;frontend/node_modules\u0026#34;] # Watch these directories if you specified. include_dir = [] # Exclude files. exclude_file = [] # It\u0026#39;s not necessary to trigger build each time file changes if it\u0026#39;s too frequent. delay = 1000 # ms # Stop to run old binary when build errors occur. stop_on_error = true # This log file places in your tmp_dir. log = \u0026#34;air_errors.log\u0026#34; [log] # Show log time time = false [color] # Customize each part\u0026#39;s color. If no color found, use the raw app log. main = \u0026#34;magenta\u0026#34; watcher = \u0026#34;cyan\u0026#34; build = \u0026#34;yellow\u0026#34; runner = \u0026#34;green\u0026#34; [misc] # Delete tmp directory on exit clean_on_exit = true air -c air.conf 다음 air 커맨드를 통해 conf 파일을 지정하고 프로젝트를 watch 시키면, 파일이 변경될 때 마다 자동으로 재 빌드 작업하고 실행해줄 것이다.\n","date":"2020-01-27T19:47:58+09:00","permalink":"https://yansigit.github.io/blog/hot-reloading-on-golang-project/","title":"Hot Reloading on Golang Project"},{"content":"Go 언어에서 Float 변수 비교하기\nError of Floating Point 2진수로 데이터를 나타내는 컴퓨터에게 실수를 완벽하게 표현하는 것은 불가능하다.\n컴퓨터는 컴공과라면 컴퓨터 구조시간에 배울 \u0026lsquo;부동소수점\u0026rsquo;을 이용해 실수를 표현하게 되는데 고 언어에서도 역시 실수 연산 과정에서 오차가 나게 된다.\n그러므로 만약 아래의 코드를 돌린다면\nvar test float32 = 10.0 for i:=0; i\u0026lt;10; i++ { test -= 0.1 } fmt.Println(test) fmt.Println(test == 9.0) 8.999996 false 아래와 같이 의도치 않은 결과가 나올 수 있다.\n부동소수점 비교를 위해서는 다음과 같이 함수를 따로 짜주고 해당 함수를 통해 비교해줘야 한다.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) const float64EqualityThreshold = 1e-9 func almostEqual(a, b float64) bool { return math.Abs(a - b) \u0026lt;= float64EqualityThreshold // a - b 가 음수일 수 있기 때문에 math.Abs를 통해 절대값으로 만들어 줌 } func main() { a := 0.1 b := 0.2 fmt.Println(almostEqual(a + b, 0.3)) } 이렇게 하면 근사값을 통해 해당 두 실수가 거의 일치하는지 확인할 수 있다.\n","date":"2020-01-24T02:22:48+09:00","permalink":"https://yansigit.github.io/blog/comparing-float-in-golang/","title":"Comparing Float in Golang"},{"content":"INTRO 실험 대상은 넥서스 5. 굳이 넥서스 5를 고른 이유는, 구글의 레퍼런스 폰인만큼 부트로더 언락도 쉽고 이미 여러 프로젝트의 개발 1호기로 사용되고 있기에 우분투나 페도라 등에서 혹시 이미 넥서스5용 OS를 개발해놓지 않았을까 하는 기대감 때문이었다. 결과적으로는 NO 라고 이야기 할 수 있지만.\n리눅스 개발보드가 널렸는데 그런거나 사지 굳이 이런 삽질을 하는 이유는\u0026hellip;\n  재밌을 것 같다는 이유가 첫번째.\n  라즈베리 파이가 성능대비 너무 비싸다는게 두번째. 넥서스5는 중고나라에서 3만원에 구입했는데 제대로 구동되기만 한다면 화면과 스피커, 카메라, 와이파이 모듈까지 달린 SNAPDRAGON 800 ARM 개발보드를 단돈 3만원에 구입한거나 마찬가지.\n  세번째도 역시 재밌을 것 같아서.\n  WHICH OS? 1. Ubuntu Touch 처음에 생각했던 OS는 우분투 터치\n예전에 유튜브에서 우분투 터치가 넥서스 5 위에서 구동되는 것을 보기도 했고 캐노니컬에서 공식 프로젝트로 진행했었던 만큼 (현재는 개발중단되어 커뮤니티 차원에서 개발중이다.) 안정성 하나는 믿을 수 있지 않을까 싶어서였다.\n그러나 직접 써본 결과는..\n설치 애플리케이션부터 에러가 뿜어져 나오고 설치 이후에도 최적화의 문제인지 제대로 된 구동이 힘들어 건너뛰기.\n2. Termux 그래도 레퍼런스 기기인데 해외 괴수들에 의해 리눅스 배포판 중 하나라도 포팅이 되어있지 않을까\u0026hellip; 했지만\n의외로 우분투, 페도라 등 메이저 OS 중 하나도 포팅된 전력이 없었다.\n그래서 안드로이드를 갈아치우고 리눅스만 얹어보자는 야심찬 생각을 접어야 할까\n생각하며 시도한게 Termux.\nTermux는 안드로이드 터미널 에뮬레이터로 안드로이드상에서 리눅스와 유사한 환경을 제공한다.\n그리고 Chroot 와 비슷한 Proot라는 기술을 이용해 리눅스 배포판의 코어파일을 내려받고\n안드로이드 위에서 리눅스를 돌릴 수도 있게 한다!\nF-DROID 에 AnLinux 를 검색하면\n자동으로 스크립트를 생성해 제공해주는 어플을 내려받을 수 있다.\n의외로 쓸만하긴 했지만.. 그래도 여전히 안드로이듣 상에서 잡아먹는 쓸모없는 자원 낭비를 없애고 싶었다.\n3. PostmarketOS PostmarketOS는 안드로이드의 짧은 사후지원을 대체해 훨씬 긴 (15년 이상) 기간의 사후지원을 목표로 하는 프로젝트다.\n즉, 해당 프로젝트는 여전히 \u0026lsquo;휴대기기용\u0026rsquo; 운영체제가 주된 목적이다.\n그러나 내 관심을 끈 이유는 바로 해당 운영체제의 \u0026lsquo;완전한 리눅스 커널 기반\u0026rsquo;을 목표로 하는 것이다.\n실제로 해당 프로젝트는 Alpine Linux 기반이며, 넥서스 5는 공식적으로 지원하고 있는 기기 중 하나라 이미 리눅스 Mainline 커널이 적용되어 있다.\n다만 다른 기기들은 안드로이드 커널을 그대로 사용하는 수준인 듯 하다. 대부분의 기기들도 사용자들에 의해 포팅되어 구동 확인에 그친것 같고\u0026hellip;\nInstalling postmarketOS 아무튼, 해당 OS 펌웨어 파일을 내려받아 기기에 바로 적용시킬 수는 없고, 아직은 사용자가 스스로 빌드하여 적용해야 한다.\n빌드 환경은 리눅스만 지원하고 있어 윈도우 사용자라면 가상머신이나 도커를 이용해야 한다.\n나의 경우에는 도커 ubuntu 컨테이너를 통해 빌드환경을 조성했다.\n그리고 도커를 사용할 경우 반드시 --privileged 옵션을 주어야 한다! (개발자들한테 도커에서 빌드 안되는거 같다고 이슈 작성했다가 비추 먹었다..)\n리눅스 환경이 준비되었다면 빌드 및 사용에 필수적인 패키지들을 내려받는다.\napt install python3 python3-pip coreutils procps qemu binfmt-support qemu-user-static sudo nano git postmarketOS 빌드를 도와줄 pmbootstrap은 루트 사용자의 실행을 제한하고 있다. 새 사용자를 만들어주자.\nadduser \u0026lt;user name\u0026gt; 그리고 /etc/sudoer에 사용자를 추가해 sudo 명령어를 사용할 수 있게 한다.\n그리고 해당 사용자로 로그인해 다음 명령어를 실행, pmbootstrap을 설치한다.\npip3 install --user pmbootstrap 다음 환경변수 PATH 를 지정해 명령어를 바로 사용할 수 있게 한다.\n아래 명령어를 실행해 일시적으로 지정해주거나\nexport PATH=$PATH:~/.local/bin/ ~/.profile 파일을 수정해 시작 시 자동으로 지정해줄 수도 있다. (아마 대부분 기본 적용되어 있을 것이다)\n# set PATH so it includes user\u0026#39;s private bin if it exists if [ -d \u0026#34;$HOME/.local/bin\u0026#34; ] ; then PATH=\u0026#34;$HOME/.local/bin:$PATH\u0026#34; fi pmbootstrap 설치가 끝났다. 이제 빌드를 할 차례.\npmbootstrap init 위 명령어를 실행하면 빌드를 도와줄 마법사가 실행된다. 원하는 옵션을 넣으면 해당 옵션해 해당하는 세팅을 알아서 맞춰준다.\npmbootstrap install 위 명령어를 입력하면 init으로 세팅된 옵션에 맞춰 빌드를 시작한다.\n뒤에 아무 매개변수도 주지 않으면 나중에 pmbootstrap이나 직접 ADB 등을 통해 USB 연결을 통해 설치하게 되는데\n도커에서 아직 지원되는 부분이 아니라 아래와 같이 펌웨어를 zip파일로 만들어 TWRP 등 커스텀 리커버리로 올려줘야 한다.\npmbootstrap install --android-recovery-zip --recovery-install-partition data pmbootstrap export # /tmp/postmarketOS-export/ 내부에 zip 생성 이렇게 하면 /tmp/postmarketOS-export/ 내부에 펌웨어 파일이 생성된다. 이 파일을 내려받고 플래싱할 준비를 하자.\nfastboot format system fastboot format userdata 안드로이드 SDK 내부의 fastboot 를 이용하여 system, userdata 파티션을 깨끗이 포맷해준다.\n넥서스 5에서 system 파티션의 크기는 얼마 1G 남짓이다. 용량이 부족할 것 같아 설치 파티션을 변경하려 애썼는데, 명령어줄 상에서는 아무리 삽질해도 적용이 되지 않아 zip 파일의 스크립트를 직접 변경해주었다.\npmos-*.zip -\u0026gt; chroot 폴더 -\u0026gt; install_options 의 SYSTEM_PARTLABEL 옵션을 data로 바꿔 userdata 파티션을 사용하도록 변경했다.\nDEVICE='lg-hammerhead' FLAVOR='postmarketos-qcom-msm8974' FLASH_KERNEL='true' ISOREC='false' KERNEL_PARTLABEL='boot' INITFS_PARTLABEL='RECOVERY' SYSTEM_PARTLABEL='data' INSTALL_PARTITION='data' CIPHER='aes-cbc-plain64' FDE='false' 다음 TWRP의 sideload 기능을 이용해 zip 파일을 플래싱해주었다. 이 때 모든 파티션을 언마운트 해주고 플래싱해야 한다.\nadb sideload pmos-*.zip 다음 리부트하면, postmarketOS 로고가 뜨며 부팅될 것이다. 이제 안드로이드 대신 완전한 리눅스를 사용할 수 있다!\nWifi 연결이 필요하다면 수동으로 WIFI 연결을 지정해주거나\n$ sudo nmcli device wifi list ifname wlan0 $ sudo nmcli device wifi connect \u0026#34;$SSID\u0026#34; password \u0026#34;$PASSWORD\u0026#34; ifname \u0026#34;wlan0\u0026#34; 혹은 마법사를 이용할 수도 있다\nsudo nmtui ","date":"2020-01-22T21:31:21+09:00","permalink":"https://yansigit.github.io/blog/postmarketos-on-nexus5/","title":"PostmarketOS on Nexus5"},{"content":"HOW 고 언어의 장점 중 하나는 크로스-컴파일 및 멀티플랫폼 지원이 쉽다는 것이다.\n간단한 환경 변수 설정을 통해 얼마든지 다양한 플랫폼으로의 빌드가 가능하다.\n명령어로도 빌드가 얼마든지 가능하지만 좀 더 쉬운 접근을 위해 makefile 또한 이용 가능하다.\ncc_on_win: @echo \u0026#34;Cross Compile\u0026#34; set GOOS=linux\u0026amp; set GOARCH=arm\u0026amp; set GOARM=7\u0026amp; go build -o bin/linux_arm_v7 test.go set GOOS=windows\u0026amp; set GOARCH=amd64\u0026amp; go build -o bin/windows_x64 test.go set GOOS=linux\u0026amp; set GOARCH=386\u0026amp; go build -o bin/linux_x86 test.go cc_on_linux: @echo \u0026#34;Cross Compile\u0026#34; GOOS=linux GOARCH=arm GOARM=7 go build -o bin/linux_arm_v7 test.go GOOS=windows GOARCH=amd64 go build -o bin/windows_x64 test.go GOOS=linuxt GOARCH=386 go build -o bin/linux_x86 test.go ","date":"2020-01-22T21:16:37+09:00","permalink":"https://yansigit.github.io/blog/go-cross-compile/","title":"Go Cross Compile"},{"content":"고 모듈이 등장하기 전까지, 개발자들은 GOPATH 등의 환경변수를 이용해 프로젝트 및 패키지 종속성을 관리해야 했다.\n그러나 고 버전 1.11버전부터 공식적으로 고 모듈 기능이 추가되어 더욱 쉽고 간편하게 패키지를 관리하는 것이 가능해졌다.\nHOW TO USE 사용 방법은 다음과 같다.\n먼저 프로젝트 디렉토리로 사용할 디렉토리를 만든다. 어디든지 상관없다.\nmkdir goProject 다음 go mod init 명령어를 통해 모듈 프로젝트로 초기화시킨다.\ngo mod init github.com/yansigit/hello init 이후의 github.com/yansigit/hello 인수는 모듈의 이름이다.\n모듈 이름을 해당 명령어를 통해 작성할 수도 있고 소스코드 파일에\npackage \u0026lt;패키지명\u0026gt; // import github.com/yansigit/hello\n이런 식으로 주석으로 달아준 다음 go mod init만 해줘도 상관없는 듯 하다.\n아무튼 실행하게 되면, go.mod라는 파일 하나가 프로젝트 루트에 생성된다.\n파일을 열어보면 다음과 같이 되어있을 것이다.\nmodule github.com/yansigit/hello go 1.13 이제 소스파일을 작성해보자.\ntouch test.go package main import ( // \u0026#34;fmt\u0026#34; \t\u0026#34;github.com/gin-gonic/gin\u0026#34; // \u0026#34;net/http\u0026#34; ) func main() { r := gin.Default() r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;, }) }) r.Run() // listen and serve on 0.0.0.0:8080 } 다음, go 명령어를 사용하면 자동으로 import된 패키지를 찾고 GOPATH/pkg/mod 디렉터리 밑에 설치된다. 이 때 프로젝트 루트 디렉터리에 go.sum 파일도 함께 생성된다.\n이 파일은 설치된 모듈의 해시 값을 저장해두고, 매 go 커맨드가 실행되기 전에 설치 되어있는 모듈의 해시 값과 go.sum에 저장된 해시 값을 비교하여 설치된 모듈의 유효성을 검증하는 역할을 한다.\ngo get -u 명령어를 통해 import 시킨 패키지들을 받아온다.\n굳이 go 명령어를 사용하면 자동으로 받아오는데 왜 go get까지 해주냐면..\n이유는 모르겠으나 goland IDE에서 해당 명령어를 쳐주지 않으면 패키지를 찾을 수 없는지 빨갛게 뜬다.\nmodule github.com/yansigit/hello go 1.13 require ( github.com/gin-gonic/gin v1.5.0 github.com/go-playground/universal-translator v0.17.0 // indirect github.com/json-iterator/go v1.1.9 // indirect github.com/leodido/go-urn v1.2.0 // indirect github.com/mattn/go-isatty v0.0.12 // indirect github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect github.com/modern-go/reflect2 v1.0.1 // indirect golang.org/x/sys v0.0.0-20200121082415-34d275377bf9 // indirect gopkg.in/go-playground/validator.v9 v9.31.0 // indirect gopkg.in/yaml.v2 v2.2.7 // indirect ) go.mod에서도 의존성 관련 정보들이 업데이트 된다.\n필요할 때 마다 go.mod 파일을 수정해 모듈을 관리할 수 있다.\n만약, 새로운 모듈을 추가하고 싶다면 go get \u0026lt;module-path\u0026gt;@\u0026lt;module-query\u0026gt; 커맨드를 사용한다.\ngo get github.com/fatih/color@latest Module query에 대한 더 자세한 내용은 공식문서를 통해 확인하실 수 있다.\n버전 지정이 필요가 없다면 코드에서 바로 import 하면 go 커맨드가 실행될 때 자동으로 추가될 것이다.\n 참고 및 출처: https://velog.io/@kimmachinegun/Go-Go-Modules-살펴보기-7cjn4soifk\n","date":"2020-01-21T01:50:58+09:00","permalink":"https://yansigit.github.io/blog/about-go-module/","title":"About Go Module"}]